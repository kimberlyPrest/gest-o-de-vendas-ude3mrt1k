import { a as parseISO, c as startOfMonth, d as addDays, f as DollarSign, h as ArrowRightLeft, i as PopoverTrigger, m as ArrowUp, n as Popover, o as subDays, r as PopoverContent, t as Calendar$1, u as addMonths } from "./calendar-DRFsrAtP.js";
import { Bt as Search, C as DialogDescription, D as DialogTrigger, E as DialogTitle, G as differenceInDays, Gt as ChevronDown, H as endOfMonth, Ht as LoaderCircle, It as cn, Jt as createLucideIcon, Kt as Check, L as format, Lt as Video, N as useLivesStore, O as ptBR, Ot as Slot, Rt as Users, S as DialogContent, St as Separator, T as DialogHeader, Tt as Button, U as endOfDay, Ut as ChevronUp, Vt as RefreshCw, X as startOfDay, Xt as clsx_default, _ as CommandItem, a as CardTitle, at as googleSheetsService, b as Dialog, c as SelectItem, d as Switch, dn as require_react, f as Label$1, fn as __commonJSMin, g as CommandInput, h as CommandGroup, i as CardHeader, l as SelectTrigger, m as CommandEmpty, mn as __toESM, n as CardContent, o as Select, p as Command, pn as __export, qt as Calendar, r as CardDescription, s as SelectContent, sn as require_jsx_runtime, st as Skeleton, t as Card, tt as toDate, u as SelectValue, un as useToast, v as CommandList, w as DialogFooter, wt as Input, y as CommandSeparator, zt as TrendingUp } from "./index-ChSeICpI.js";
var ArrowDown = createLucideIcon("arrow-down", [["path", {
	d: "M12 5v14",
	key: "s699le"
}], ["path", {
	d: "m19 12-7 7-7-7",
	key: "1idqje"
}]]);
var ArrowUpDown = createLucideIcon("arrow-up-down", [
	["path", {
		d: "m21 16-4 4-4-4",
		key: "f6ql7i"
	}],
	["path", {
		d: "M17 20V4",
		key: "1ejh1v"
	}],
	["path", {
		d: "m3 8 4-4 4 4",
		key: "11wl7u"
	}],
	["path", {
		d: "M7 4v16",
		key: "1glfcx"
	}]
]);
var Award = createLucideIcon("award", [["path", {
	d: "m15.477 12.89 1.515 8.526a.5.5 0 0 1-.81.47l-3.58-2.687a1 1 0 0 0-1.197 0l-3.586 2.686a.5.5 0 0 1-.81-.469l1.514-8.526",
	key: "1yiouv"
}], ["circle", {
	cx: "12",
	cy: "8",
	r: "6",
	key: "1vp47v"
}]]);
var CalendarCheck = createLucideIcon("calendar-check", [
	["path", {
		d: "M8 2v4",
		key: "1cmpym"
	}],
	["path", {
		d: "M16 2v4",
		key: "4m81vk"
	}],
	["rect", {
		width: "18",
		height: "18",
		x: "3",
		y: "4",
		rx: "2",
		key: "1hopcy"
	}],
	["path", {
		d: "M3 10h18",
		key: "8toen8"
	}],
	["path", {
		d: "m9 16 2 2 4-4",
		key: "19s6y9"
	}]
]);
var ChartColumn = createLucideIcon("chart-column", [
	["path", {
		d: "M3 3v16a2 2 0 0 0 2 2h16",
		key: "c24i48"
	}],
	["path", {
		d: "M18 17V9",
		key: "2bz60n"
	}],
	["path", {
		d: "M13 17V5",
		key: "1frdt8"
	}],
	["path", {
		d: "M8 17v-3",
		key: "17ska0"
	}]
]);
var ChevronsUpDown = createLucideIcon("chevrons-up-down", [["path", {
	d: "m7 15 5 5 5-5",
	key: "1hf1tw"
}], ["path", {
	d: "m7 9 5-5 5 5",
	key: "sgt6xg"
}]]);
var FunnelX = createLucideIcon("funnel-x", [
	["path", {
		d: "M12.531 3H3a1 1 0 0 0-.742 1.67l7.225 7.989A2 2 0 0 1 10 14v6a1 1 0 0 0 .553.895l2 1A1 1 0 0 0 14 21v-7a2 2 0 0 1 .517-1.341l.427-.473",
		key: "ol2ft2"
	}],
	["path", {
		d: "m16.5 3.5 5 5",
		key: "15e6fa"
	}],
	["path", {
		d: "m21.5 3.5-5 5",
		key: "m0lwru"
	}]
]);
var Minus = createLucideIcon("minus", [["path", {
	d: "M5 12h14",
	key: "1ays0h"
}]]);
var Percent = createLucideIcon("percent", [
	["line", {
		x1: "19",
		x2: "5",
		y1: "5",
		y2: "19",
		key: "1x9vlm"
	}],
	["circle", {
		cx: "6.5",
		cy: "6.5",
		r: "2.5",
		key: "4mh3h7"
	}],
	["circle", {
		cx: "17.5",
		cy: "17.5",
		r: "2.5",
		key: "1mdrzq"
	}]
]);
var Plus = createLucideIcon("plus", [["path", {
	d: "M5 12h14",
	key: "1ays0h"
}], ["path", {
	d: "M12 5v14",
	key: "s699le"
}]]);
var SearchX = createLucideIcon("search-x", [
	["path", {
		d: "m13.5 8.5-5 5",
		key: "1cs55j"
	}],
	["path", {
		d: "m8.5 8.5 5 5",
		key: "a8mexj"
	}],
	["circle", {
		cx: "11",
		cy: "11",
		r: "8",
		key: "4ej97u"
	}],
	["path", {
		d: "m21 21-4.3-4.3",
		key: "1qie3q"
	}]
]);
var ShoppingCart = createLucideIcon("shopping-cart", [
	["circle", {
		cx: "8",
		cy: "21",
		r: "1",
		key: "jimo8o"
	}],
	["circle", {
		cx: "19",
		cy: "21",
		r: "1",
		key: "13723u"
	}],
	["path", {
		d: "M2.05 2.05h2l2.66 12.42a2 2 0 0 0 2 1.58h9.78a2 2 0 0 0 1.95-1.57l1.65-7.43H5.12",
		key: "9zh506"
	}]
]);
var TriangleAlert = createLucideIcon("triangle-alert", [
	["path", {
		d: "m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3",
		key: "wmoenq"
	}],
	["path", {
		d: "M12 9v4",
		key: "juzpu7"
	}],
	["path", {
		d: "M12 17h.01",
		key: "p32p05"
	}]
]);
var Trophy = createLucideIcon("trophy", [
	["path", {
		d: "M10 14.66v1.626a2 2 0 0 1-.976 1.696A5 5 0 0 0 7 21.978",
		key: "1n3hpd"
	}],
	["path", {
		d: "M14 14.66v1.626a2 2 0 0 0 .976 1.696A5 5 0 0 1 17 21.978",
		key: "rfe1zi"
	}],
	["path", {
		d: "M18 9h1.5a1 1 0 0 0 0-5H18",
		key: "7xy6bh"
	}],
	["path", {
		d: "M4 22h16",
		key: "57wxv0"
	}],
	["path", {
		d: "M6 9a6 6 0 0 0 12 0V3a1 1 0 0 0-1-1H7a1 1 0 0 0-1 1z",
		key: "1mhfuq"
	}],
	["path", {
		d: "M6 9H4.5a1 1 0 0 1 0-5H6",
		key: "tex48p"
	}]
]);
function isWithinInterval(date$4, interval, options) {
	const time$3 = +toDate(date$4, options?.in);
	const [startTime, endTime] = [+toDate(interval.start, options?.in), +toDate(interval.end, options?.in)].sort((a$2, b) => a$2 - b);
	return time$3 >= startTime && time$3 <= endTime;
}
function subMonths(date$4, amount, options) {
	return addMonths(date$4, -amount, options);
}
var import_react = /* @__PURE__ */ __toESM(require_react(), 1);
var isCheckBoxInput = (element) => element.type === "checkbox";
var isDateObject = (value) => value instanceof Date;
var isNullOrUndefined = (value) => value == null;
var isObjectType = (value) => typeof value === "object";
var isObject$13 = (value) => !isNullOrUndefined(value) && !Array.isArray(value) && isObjectType(value) && !isDateObject(value);
var getEventValue = (event) => isObject$13(event) && event.target ? isCheckBoxInput(event.target) ? event.target.checked : event.target.value : event;
var getNodeParentName = (name) => name.substring(0, name.search(/\.\d+(\.|$)/)) || name;
var isNameInFieldArray = (names, name) => names.has(getNodeParentName(name));
var isPlainObject$3 = (tempObject) => {
	const prototypeCopy = tempObject.constructor && tempObject.constructor.prototype;
	return isObject$13(prototypeCopy) && prototypeCopy.hasOwnProperty("isPrototypeOf");
};
var isWeb = typeof window !== "undefined" && typeof window.HTMLElement !== "undefined" && typeof document !== "undefined";
function cloneObject(data) {
	if (data instanceof Date) return new Date(data);
	const isFileListInstance = typeof FileList !== "undefined" && data instanceof FileList;
	if (isWeb && (data instanceof Blob || isFileListInstance)) return data;
	const isArray$15 = Array.isArray(data);
	if (!isArray$15 && !(isObject$13(data) && isPlainObject$3(data))) return data;
	const copy$2 = isArray$15 ? [] : Object.create(Object.getPrototypeOf(data));
	for (const key in data) if (Object.prototype.hasOwnProperty.call(data, key)) copy$2[key] = cloneObject(data[key]);
	return copy$2;
}
var isKey$4 = (value) => /^\w*$/.test(value);
var isUndefined = (val) => val === void 0;
var compact = (value) => Array.isArray(value) ? value.filter(Boolean) : [];
var stringToPath$2 = (input) => compact(input.replace(/["|']|\]/g, "").split(/\.|\[/));
var get$7 = (object$1, path$1, defaultValue) => {
	if (!path$1 || !isObject$13(object$1)) return defaultValue;
	const result = (isKey$4(path$1) ? [path$1] : stringToPath$2(path$1)).reduce((result$1, key) => isNullOrUndefined(result$1) ? result$1 : result$1[key], object$1);
	return isUndefined(result) || result === object$1 ? isUndefined(object$1[path$1]) ? defaultValue : object$1[path$1] : result;
};
var isBoolean$2 = (value) => typeof value === "boolean";
var isFunction$22 = (value) => typeof value === "function";
var set = (object$1, path$1, value) => {
	let index = -1;
	const tempPath = isKey$4(path$1) ? [path$1] : stringToPath$2(path$1);
	const length = tempPath.length;
	const lastIndex = length - 1;
	while (++index < length) {
		const key = tempPath[index];
		let newValue = value;
		if (index !== lastIndex) {
			const objValue = object$1[key];
			newValue = isObject$13(objValue) || Array.isArray(objValue) ? objValue : !isNaN(+tempPath[index + 1]) ? [] : {};
		}
		if (key === "__proto__" || key === "constructor" || key === "prototype") return;
		object$1[key] = newValue;
		object$1 = object$1[key];
	}
};
var EVENTS = {
	BLUR: "blur",
	FOCUS_OUT: "focusout",
	CHANGE: "change"
};
var VALIDATION_MODE = {
	onBlur: "onBlur",
	onChange: "onChange",
	onSubmit: "onSubmit",
	onTouched: "onTouched",
	all: "all"
};
var INPUT_VALIDATION_RULES = {
	max: "max",
	min: "min",
	maxLength: "maxLength",
	minLength: "minLength",
	pattern: "pattern",
	required: "required",
	validate: "validate"
};
var HookFormContext = import_react.createContext(null);
HookFormContext.displayName = "HookFormContext";
var useFormContext = () => import_react.useContext(HookFormContext);
var FormProvider = (props) => {
	const { children, ...data } = props;
	return import_react.createElement(HookFormContext.Provider, { value: data }, children);
};
var getProxyFormState = (formState, control, localProxyFormState, isRoot = true) => {
	const result = { defaultValues: control._defaultValues };
	for (const key in formState) Object.defineProperty(result, key, { get: () => {
		const _key = key;
		if (control._proxyFormState[_key] !== VALIDATION_MODE.all) control._proxyFormState[_key] = !isRoot || VALIDATION_MODE.all;
		localProxyFormState && (localProxyFormState[_key] = true);
		return formState[_key];
	} });
	return result;
};
var useIsomorphicLayoutEffect = typeof window !== "undefined" ? import_react.useLayoutEffect : import_react.useEffect;
function useFormState(props) {
	const methods = useFormContext();
	const { control = methods.control, disabled, name, exact } = props || {};
	const [formState, updateFormState] = import_react.useState(control._formState);
	const _localProxyFormState = import_react.useRef({
		isDirty: false,
		isLoading: false,
		dirtyFields: false,
		touchedFields: false,
		validatingFields: false,
		isValidating: false,
		isValid: false,
		errors: false
	});
	useIsomorphicLayoutEffect(() => control._subscribe({
		name,
		formState: _localProxyFormState.current,
		exact,
		callback: (formState$1) => {
			!disabled && updateFormState({
				...control._formState,
				...formState$1
			});
		}
	}), [
		name,
		disabled,
		exact
	]);
	import_react.useEffect(() => {
		_localProxyFormState.current.isValid && control._setValid(true);
	}, [control]);
	return import_react.useMemo(() => getProxyFormState(formState, control, _localProxyFormState.current, false), [formState, control]);
}
var isString$4 = (value) => typeof value === "string";
var generateWatchOutput = (names, _names, formValues, isGlobal, defaultValue) => {
	if (isString$4(names)) {
		isGlobal && _names.watch.add(names);
		return get$7(formValues, names, defaultValue);
	}
	if (Array.isArray(names)) return names.map((fieldName) => (isGlobal && _names.watch.add(fieldName), get$7(formValues, fieldName)));
	isGlobal && (_names.watchAll = true);
	return formValues;
};
var isPrimitive = (value) => isNullOrUndefined(value) || !isObjectType(value);
function deepEqual$1(object1, object2, _internal_visited = /* @__PURE__ */ new WeakSet()) {
	if (isPrimitive(object1) || isPrimitive(object2)) return Object.is(object1, object2);
	if (isDateObject(object1) && isDateObject(object2)) return object1.getTime() === object2.getTime();
	const keys1 = Object.keys(object1);
	const keys2 = Object.keys(object2);
	if (keys1.length !== keys2.length) return false;
	if (_internal_visited.has(object1) || _internal_visited.has(object2)) return true;
	_internal_visited.add(object1);
	_internal_visited.add(object2);
	for (const key of keys1) {
		const val1 = object1[key];
		if (!keys2.includes(key)) return false;
		if (key !== "ref") {
			const val2 = object2[key];
			if (isDateObject(val1) && isDateObject(val2) || isObject$13(val1) && isObject$13(val2) || Array.isArray(val1) && Array.isArray(val2) ? !deepEqual$1(val1, val2, _internal_visited) : !Object.is(val1, val2)) return false;
		}
	}
	return true;
}
function useWatch(props) {
	const methods = useFormContext();
	const { control = methods.control, name, defaultValue, disabled, exact, compute } = props || {};
	const _defaultValue = import_react.useRef(defaultValue);
	const _compute = import_react.useRef(compute);
	const _computeFormValues = import_react.useRef(void 0);
	const _prevControl = import_react.useRef(control);
	const _prevName = import_react.useRef(name);
	_compute.current = compute;
	const [value, updateValue] = import_react.useState(() => {
		const defaultValue$1 = control._getWatch(name, _defaultValue.current);
		return _compute.current ? _compute.current(defaultValue$1) : defaultValue$1;
	});
	const getCurrentOutput = import_react.useCallback((values) => {
		const formValues = generateWatchOutput(name, control._names, values || control._formValues, false, _defaultValue.current);
		return _compute.current ? _compute.current(formValues) : formValues;
	}, [
		control._formValues,
		control._names,
		name
	]);
	const refreshValue = import_react.useCallback((values) => {
		if (!disabled) {
			const formValues = generateWatchOutput(name, control._names, values || control._formValues, false, _defaultValue.current);
			if (_compute.current) {
				const computedFormValues = _compute.current(formValues);
				if (!deepEqual$1(computedFormValues, _computeFormValues.current)) {
					updateValue(computedFormValues);
					_computeFormValues.current = computedFormValues;
				}
			} else updateValue(formValues);
		}
	}, [
		control._formValues,
		control._names,
		disabled,
		name
	]);
	useIsomorphicLayoutEffect(() => {
		if (_prevControl.current !== control || !deepEqual$1(_prevName.current, name)) {
			_prevControl.current = control;
			_prevName.current = name;
			refreshValue();
		}
		return control._subscribe({
			name,
			formState: { values: true },
			exact,
			callback: (formState) => {
				refreshValue(formState.values);
			}
		});
	}, [
		control,
		exact,
		name,
		refreshValue
	]);
	import_react.useEffect(() => control._removeUnmounted());
	const controlChanged = _prevControl.current !== control;
	const prevName = _prevName.current;
	const computedOutput = import_react.useMemo(() => {
		if (disabled) return null;
		const nameChanged = !controlChanged && !deepEqual$1(prevName, name);
		return controlChanged || nameChanged ? getCurrentOutput() : null;
	}, [
		disabled,
		controlChanged,
		name,
		prevName,
		getCurrentOutput
	]);
	return computedOutput !== null ? computedOutput : value;
}
function useController(props) {
	const methods = useFormContext();
	const { name, disabled, control = methods.control, shouldUnregister, defaultValue, exact = true } = props;
	const isArrayField = isNameInFieldArray(control._names.array, name);
	const value = useWatch({
		control,
		name,
		defaultValue: import_react.useMemo(() => get$7(control._formValues, name, get$7(control._defaultValues, name, defaultValue)), [
			control,
			name,
			defaultValue
		]),
		exact
	});
	const formState = useFormState({
		control,
		name,
		exact
	});
	const _props = import_react.useRef(props);
	const _previousNameRef = import_react.useRef(void 0);
	const _registerProps = import_react.useRef(control.register(name, {
		...props.rules,
		value,
		...isBoolean$2(props.disabled) ? { disabled: props.disabled } : {}
	}));
	_props.current = props;
	const fieldState = import_react.useMemo(() => Object.defineProperties({}, {
		invalid: {
			enumerable: true,
			get: () => !!get$7(formState.errors, name)
		},
		isDirty: {
			enumerable: true,
			get: () => !!get$7(formState.dirtyFields, name)
		},
		isTouched: {
			enumerable: true,
			get: () => !!get$7(formState.touchedFields, name)
		},
		isValidating: {
			enumerable: true,
			get: () => !!get$7(formState.validatingFields, name)
		},
		error: {
			enumerable: true,
			get: () => get$7(formState.errors, name)
		}
	}), [formState, name]);
	const onChange = import_react.useCallback((event) => _registerProps.current.onChange({
		target: {
			value: getEventValue(event),
			name
		},
		type: EVENTS.CHANGE
	}), [name]);
	const onBlur = import_react.useCallback(() => _registerProps.current.onBlur({
		target: {
			value: get$7(control._formValues, name),
			name
		},
		type: EVENTS.BLUR
	}), [name, control._formValues]);
	const ref = import_react.useCallback((elm) => {
		const field$1 = get$7(control._fields, name);
		if (field$1 && field$1._f && elm) field$1._f.ref = {
			focus: () => isFunction$22(elm.focus) && elm.focus(),
			select: () => isFunction$22(elm.select) && elm.select(),
			setCustomValidity: (message) => isFunction$22(elm.setCustomValidity) && elm.setCustomValidity(message),
			reportValidity: () => isFunction$22(elm.reportValidity) && elm.reportValidity()
		};
	}, [control._fields, name]);
	const field = import_react.useMemo(() => ({
		name,
		value,
		...isBoolean$2(disabled) || formState.disabled ? { disabled: formState.disabled || disabled } : {},
		onChange,
		onBlur,
		ref
	}), [
		name,
		disabled,
		formState.disabled,
		onChange,
		onBlur,
		ref,
		value
	]);
	import_react.useEffect(() => {
		const _shouldUnregisterField = control._options.shouldUnregister || shouldUnregister;
		const previousName = _previousNameRef.current;
		if (previousName && previousName !== name && !isArrayField) control.unregister(previousName);
		control.register(name, {
			..._props.current.rules,
			...isBoolean$2(_props.current.disabled) ? { disabled: _props.current.disabled } : {}
		});
		const updateMounted = (name$1, value$1) => {
			const field$1 = get$7(control._fields, name$1);
			if (field$1 && field$1._f) field$1._f.mount = value$1;
		};
		updateMounted(name, true);
		if (_shouldUnregisterField) {
			const value$1 = cloneObject(get$7(control._options.defaultValues, name, _props.current.defaultValue));
			set(control._defaultValues, name, value$1);
			if (isUndefined(get$7(control._formValues, name))) set(control._formValues, name, value$1);
		}
		!isArrayField && control.register(name);
		_previousNameRef.current = name;
		return () => {
			(isArrayField ? _shouldUnregisterField && !control._state.action : _shouldUnregisterField) ? control.unregister(name) : updateMounted(name, false);
		};
	}, [
		name,
		control,
		isArrayField,
		shouldUnregister
	]);
	import_react.useEffect(() => {
		control._setDisabledField({
			disabled,
			name
		});
	}, [
		disabled,
		name,
		control
	]);
	return import_react.useMemo(() => ({
		field,
		formState,
		fieldState
	}), [
		field,
		formState,
		fieldState
	]);
}
var Controller = (props) => props.render(useController(props));
var appendErrors = (name, validateAllFieldCriteria, errors, type, message) => validateAllFieldCriteria ? {
	...errors[name],
	types: {
		...errors[name] && errors[name].types ? errors[name].types : {},
		[type]: message || true
	}
} : {};
var convertToArrayPayload = (value) => Array.isArray(value) ? value : [value];
var createSubject = () => {
	let _observers = [];
	const next = (value) => {
		for (const observer of _observers) observer.next && observer.next(value);
	};
	const subscribe = (observer) => {
		_observers.push(observer);
		return { unsubscribe: () => {
			_observers = _observers.filter((o$1) => o$1 !== observer);
		} };
	};
	const unsubscribe = () => {
		_observers = [];
	};
	return {
		get observers() {
			return _observers;
		},
		next,
		subscribe,
		unsubscribe
	};
};
function extractFormValues(fieldsState, formValues) {
	const values = {};
	for (const key in fieldsState) if (fieldsState.hasOwnProperty(key)) {
		const fieldState = fieldsState[key];
		const fieldValue = formValues[key];
		if (fieldState && isObject$13(fieldState) && fieldValue) {
			const nestedFieldsState = extractFormValues(fieldState, fieldValue);
			if (isObject$13(nestedFieldsState)) values[key] = nestedFieldsState;
		} else if (fieldsState[key]) values[key] = fieldValue;
	}
	return values;
}
var isEmptyObject = (value) => isObject$13(value) && !Object.keys(value).length;
var isFileInput = (element) => element.type === "file";
var isHTMLElement = (value) => {
	if (!isWeb) return false;
	const owner = value ? value.ownerDocument : 0;
	return value instanceof (owner && owner.defaultView ? owner.defaultView.HTMLElement : HTMLElement);
};
var isMultipleSelect = (element) => element.type === `select-multiple`;
var isRadioInput = (element) => element.type === "radio";
var isRadioOrCheckbox = (ref) => isRadioInput(ref) || isCheckBoxInput(ref);
var live = (ref) => isHTMLElement(ref) && ref.isConnected;
function baseGet$4(object$1, updatePath) {
	const length = updatePath.slice(0, -1).length;
	let index = 0;
	while (index < length) object$1 = isUndefined(object$1) ? index++ : object$1[updatePath[index++]];
	return object$1;
}
function isEmptyArray(obj) {
	for (const key in obj) if (obj.hasOwnProperty(key) && !isUndefined(obj[key])) return false;
	return true;
}
function unset(object$1, path$1) {
	const paths = Array.isArray(path$1) ? path$1 : isKey$4(path$1) ? [path$1] : stringToPath$2(path$1);
	const childObject = paths.length === 1 ? object$1 : baseGet$4(object$1, paths);
	const index = paths.length - 1;
	const key = paths[index];
	if (childObject) delete childObject[key];
	if (index !== 0 && (isObject$13(childObject) && isEmptyObject(childObject) || Array.isArray(childObject) && isEmptyArray(childObject))) unset(object$1, paths.slice(0, -1));
	return object$1;
}
var objectHasFunction = (data) => {
	for (const key in data) if (isFunction$22(data[key])) return true;
	return false;
};
function isTraversable(value) {
	return Array.isArray(value) || isObject$13(value) && !objectHasFunction(value);
}
function markFieldsDirty(data, fields = {}) {
	for (const key in data) {
		const value = data[key];
		if (isTraversable(value)) {
			fields[key] = Array.isArray(value) ? [] : {};
			markFieldsDirty(value, fields[key]);
		} else if (!isUndefined(value)) fields[key] = true;
	}
	return fields;
}
function getDirtyFields(data, formValues, dirtyFieldsFromValues) {
	if (!dirtyFieldsFromValues) dirtyFieldsFromValues = markFieldsDirty(formValues);
	for (const key in data) {
		const value = data[key];
		if (isTraversable(value)) if (isUndefined(formValues) || isPrimitive(dirtyFieldsFromValues[key])) dirtyFieldsFromValues[key] = markFieldsDirty(value, Array.isArray(value) ? [] : {});
		else getDirtyFields(value, isNullOrUndefined(formValues) ? {} : formValues[key], dirtyFieldsFromValues[key]);
		else {
			const formValue = formValues[key];
			dirtyFieldsFromValues[key] = !deepEqual$1(value, formValue);
		}
	}
	return dirtyFieldsFromValues;
}
var defaultResult = {
	value: false,
	isValid: false
};
var validResult = {
	value: true,
	isValid: true
};
var getCheckboxValue = (options) => {
	if (Array.isArray(options)) {
		if (options.length > 1) {
			const values = options.filter((option) => option && option.checked && !option.disabled).map((option) => option.value);
			return {
				value: values,
				isValid: !!values.length
			};
		}
		return options[0].checked && !options[0].disabled ? options[0].attributes && !isUndefined(options[0].attributes.value) ? isUndefined(options[0].value) || options[0].value === "" ? validResult : {
			value: options[0].value,
			isValid: true
		} : validResult : defaultResult;
	}
	return defaultResult;
};
var getFieldValueAs = (value, { valueAsNumber, valueAsDate, setValueAs }) => isUndefined(value) ? value : valueAsNumber ? value === "" ? NaN : value ? +value : value : valueAsDate && isString$4(value) ? new Date(value) : setValueAs ? setValueAs(value) : value;
var defaultReturn = {
	isValid: false,
	value: null
};
var getRadioValue = (options) => Array.isArray(options) ? options.reduce((previous, option) => option && option.checked && !option.disabled ? {
	isValid: true,
	value: option.value
} : previous, defaultReturn) : defaultReturn;
function getFieldValue(_f) {
	const ref = _f.ref;
	if (isFileInput(ref)) return ref.files;
	if (isRadioInput(ref)) return getRadioValue(_f.refs).value;
	if (isMultipleSelect(ref)) return [...ref.selectedOptions].map(({ value }) => value);
	if (isCheckBoxInput(ref)) return getCheckboxValue(_f.refs).value;
	return getFieldValueAs(isUndefined(ref.value) ? _f.ref.value : ref.value, _f);
}
var getResolverOptions = (fieldsNames, _fields, criteriaMode, shouldUseNativeValidation) => {
	const fields = {};
	for (const name of fieldsNames) {
		const field = get$7(_fields, name);
		field && set(fields, name, field._f);
	}
	return {
		criteriaMode,
		names: [...fieldsNames],
		fields,
		shouldUseNativeValidation
	};
};
var isRegex = (value) => value instanceof RegExp;
var getRuleValue = (rule) => isUndefined(rule) ? rule : isRegex(rule) ? rule.source : isObject$13(rule) ? isRegex(rule.value) ? rule.value.source : rule.value : rule;
var getValidationModes = (mode) => ({
	isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,
	isOnBlur: mode === VALIDATION_MODE.onBlur,
	isOnChange: mode === VALIDATION_MODE.onChange,
	isOnAll: mode === VALIDATION_MODE.all,
	isOnTouch: mode === VALIDATION_MODE.onTouched
});
var ASYNC_FUNCTION = "AsyncFunction";
var hasPromiseValidation = (fieldReference) => !!fieldReference && !!fieldReference.validate && !!(isFunction$22(fieldReference.validate) && fieldReference.validate.constructor.name === ASYNC_FUNCTION || isObject$13(fieldReference.validate) && Object.values(fieldReference.validate).find((validateFunction) => validateFunction.constructor.name === ASYNC_FUNCTION));
var hasValidation = (options) => options.mount && (options.required || options.min || options.max || options.maxLength || options.minLength || options.pattern || options.validate);
var isWatched = (name, _names, isBlurEvent) => !isBlurEvent && (_names.watchAll || _names.watch.has(name) || [..._names.watch].some((watchName) => name.startsWith(watchName) && /^\.\w+/.test(name.slice(watchName.length))));
var iterateFieldsByAction = (fields, action, fieldsNames, abortEarly) => {
	for (const key of fieldsNames || Object.keys(fields)) {
		const field = get$7(fields, key);
		if (field) {
			const { _f, ...currentField } = field;
			if (_f) {
				if (_f.refs && _f.refs[0] && action(_f.refs[0], key) && !abortEarly) return true;
				else if (_f.ref && action(_f.ref, _f.name) && !abortEarly) return true;
				else if (iterateFieldsByAction(currentField, action)) break;
			} else if (isObject$13(currentField)) {
				if (iterateFieldsByAction(currentField, action)) break;
			}
		}
	}
};
function schemaErrorLookup(errors, _fields, name) {
	const error = get$7(errors, name);
	if (error || isKey$4(name)) return {
		error,
		name
	};
	const names = name.split(".");
	while (names.length) {
		const fieldName = names.join(".");
		const field = get$7(_fields, fieldName);
		const foundError = get$7(errors, fieldName);
		if (field && !Array.isArray(field) && name !== fieldName) return { name };
		if (foundError && foundError.type) return {
			name: fieldName,
			error: foundError
		};
		if (foundError && foundError.root && foundError.root.type) return {
			name: `${fieldName}.root`,
			error: foundError.root
		};
		names.pop();
	}
	return { name };
}
var shouldRenderFormState = (formStateData, _proxyFormState, updateFormState, isRoot) => {
	updateFormState(formStateData);
	const { name, ...formState } = formStateData;
	return isEmptyObject(formState) || Object.keys(formState).length >= Object.keys(_proxyFormState).length || Object.keys(formState).find((key) => _proxyFormState[key] === (!isRoot || VALIDATION_MODE.all));
};
var shouldSubscribeByName = (name, signalName, exact) => !name || !signalName || name === signalName || convertToArrayPayload(name).some((currentName) => currentName && (exact ? currentName === signalName : currentName.startsWith(signalName) || signalName.startsWith(currentName)));
var skipValidation = (isBlurEvent, isTouched, isSubmitted, reValidateMode, mode) => {
	if (mode.isOnAll) return false;
	else if (!isSubmitted && mode.isOnTouch) return !(isTouched || isBlurEvent);
	else if (isSubmitted ? reValidateMode.isOnBlur : mode.isOnBlur) return !isBlurEvent;
	else if (isSubmitted ? reValidateMode.isOnChange : mode.isOnChange) return isBlurEvent;
	return true;
};
var unsetEmptyArray = (ref, name) => !compact(get$7(ref, name)).length && unset(ref, name);
var updateFieldArrayRootError = (errors, error, name) => {
	const fieldArrayErrors = convertToArrayPayload(get$7(errors, name));
	set(fieldArrayErrors, "root", error[name]);
	set(errors, name, fieldArrayErrors);
	return errors;
};
function getValidateError(result, ref, type = "validate") {
	if (isString$4(result) || Array.isArray(result) && result.every(isString$4) || isBoolean$2(result) && !result) return {
		type,
		message: isString$4(result) ? result : "",
		ref
	};
}
var getValueAndMessage = (validationData) => isObject$13(validationData) && !isRegex(validationData) ? validationData : {
	value: validationData,
	message: ""
};
var validateField = async (field, disabledFieldNames, formValues, validateAllFieldCriteria, shouldUseNativeValidation, isFieldArray) => {
	const { ref, refs, required: required$1, maxLength, minLength, min: min$3, max: max$4, pattern, validate, name, valueAsNumber, mount } = field._f;
	const inputValue = get$7(formValues, name);
	if (!mount || disabledFieldNames.has(name)) return {};
	const inputRef = refs ? refs[0] : ref;
	const setCustomValidity = (message) => {
		if (shouldUseNativeValidation && inputRef.reportValidity) {
			inputRef.setCustomValidity(isBoolean$2(message) ? "" : message || "");
			inputRef.reportValidity();
		}
	};
	const error = {};
	const isRadio = isRadioInput(ref);
	const isCheckBox = isCheckBoxInput(ref);
	const isRadioOrCheckbox$1 = isRadio || isCheckBox;
	const isEmpty = (valueAsNumber || isFileInput(ref)) && isUndefined(ref.value) && isUndefined(inputValue) || isHTMLElement(ref) && ref.value === "" || inputValue === "" || Array.isArray(inputValue) && !inputValue.length;
	const appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error);
	const getMinMaxMessage = (exceedMax, maxLengthMessage, minLengthMessage, maxType = INPUT_VALIDATION_RULES.maxLength, minType = INPUT_VALIDATION_RULES.minLength) => {
		const message = exceedMax ? maxLengthMessage : minLengthMessage;
		error[name] = {
			type: exceedMax ? maxType : minType,
			message,
			ref,
			...appendErrorsCurry(exceedMax ? maxType : minType, message)
		};
	};
	if (isFieldArray ? !Array.isArray(inputValue) || !inputValue.length : required$1 && (!isRadioOrCheckbox$1 && (isEmpty || isNullOrUndefined(inputValue)) || isBoolean$2(inputValue) && !inputValue || isCheckBox && !getCheckboxValue(refs).isValid || isRadio && !getRadioValue(refs).isValid)) {
		const { value, message } = isString$4(required$1) ? {
			value: !!required$1,
			message: required$1
		} : getValueAndMessage(required$1);
		if (value) {
			error[name] = {
				type: INPUT_VALIDATION_RULES.required,
				message,
				ref: inputRef,
				...appendErrorsCurry(INPUT_VALIDATION_RULES.required, message)
			};
			if (!validateAllFieldCriteria) {
				setCustomValidity(message);
				return error;
			}
		}
	}
	if (!isEmpty && (!isNullOrUndefined(min$3) || !isNullOrUndefined(max$4))) {
		let exceedMax;
		let exceedMin;
		const maxOutput = getValueAndMessage(max$4);
		const minOutput = getValueAndMessage(min$3);
		if (!isNullOrUndefined(inputValue) && !isNaN(inputValue)) {
			const valueNumber = ref.valueAsNumber || (inputValue ? +inputValue : inputValue);
			if (!isNullOrUndefined(maxOutput.value)) exceedMax = valueNumber > maxOutput.value;
			if (!isNullOrUndefined(minOutput.value)) exceedMin = valueNumber < minOutput.value;
		} else {
			const valueDate = ref.valueAsDate || new Date(inputValue);
			const convertTimeToDate = (time$3) => /* @__PURE__ */ new Date((/* @__PURE__ */ new Date()).toDateString() + " " + time$3);
			const isTime = ref.type == "time";
			const isWeek = ref.type == "week";
			if (isString$4(maxOutput.value) && inputValue) exceedMax = isTime ? convertTimeToDate(inputValue) > convertTimeToDate(maxOutput.value) : isWeek ? inputValue > maxOutput.value : valueDate > new Date(maxOutput.value);
			if (isString$4(minOutput.value) && inputValue) exceedMin = isTime ? convertTimeToDate(inputValue) < convertTimeToDate(minOutput.value) : isWeek ? inputValue < minOutput.value : valueDate < new Date(minOutput.value);
		}
		if (exceedMax || exceedMin) {
			getMinMaxMessage(!!exceedMax, maxOutput.message, minOutput.message, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);
			if (!validateAllFieldCriteria) {
				setCustomValidity(error[name].message);
				return error;
			}
		}
	}
	if ((maxLength || minLength) && !isEmpty && (isString$4(inputValue) || isFieldArray && Array.isArray(inputValue))) {
		const maxLengthOutput = getValueAndMessage(maxLength);
		const minLengthOutput = getValueAndMessage(minLength);
		const exceedMax = !isNullOrUndefined(maxLengthOutput.value) && inputValue.length > +maxLengthOutput.value;
		const exceedMin = !isNullOrUndefined(minLengthOutput.value) && inputValue.length < +minLengthOutput.value;
		if (exceedMax || exceedMin) {
			getMinMaxMessage(exceedMax, maxLengthOutput.message, minLengthOutput.message);
			if (!validateAllFieldCriteria) {
				setCustomValidity(error[name].message);
				return error;
			}
		}
	}
	if (pattern && !isEmpty && isString$4(inputValue)) {
		const { value: patternValue, message } = getValueAndMessage(pattern);
		if (isRegex(patternValue) && !inputValue.match(patternValue)) {
			error[name] = {
				type: INPUT_VALIDATION_RULES.pattern,
				message,
				ref,
				...appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, message)
			};
			if (!validateAllFieldCriteria) {
				setCustomValidity(message);
				return error;
			}
		}
	}
	if (validate) {
		if (isFunction$22(validate)) {
			const validateError = getValidateError(await validate(inputValue, formValues), inputRef);
			if (validateError) {
				error[name] = {
					...validateError,
					...appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message)
				};
				if (!validateAllFieldCriteria) {
					setCustomValidity(validateError.message);
					return error;
				}
			}
		} else if (isObject$13(validate)) {
			let validationResult = {};
			for (const key in validate) {
				if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) break;
				const validateError = getValidateError(await validate[key](inputValue, formValues), inputRef, key);
				if (validateError) {
					validationResult = {
						...validateError,
						...appendErrorsCurry(key, validateError.message)
					};
					setCustomValidity(validateError.message);
					if (validateAllFieldCriteria) error[name] = validationResult;
				}
			}
			if (!isEmptyObject(validationResult)) {
				error[name] = {
					ref: inputRef,
					...validationResult
				};
				if (!validateAllFieldCriteria) return error;
			}
		}
	}
	setCustomValidity(true);
	return error;
};
var defaultOptions = {
	mode: VALIDATION_MODE.onSubmit,
	reValidateMode: VALIDATION_MODE.onChange,
	shouldFocusError: true
};
function createFormControl(props = {}) {
	let _options = {
		...defaultOptions,
		...props
	};
	let _formState = {
		submitCount: 0,
		isDirty: false,
		isReady: false,
		isLoading: isFunction$22(_options.defaultValues),
		isValidating: false,
		isSubmitted: false,
		isSubmitting: false,
		isSubmitSuccessful: false,
		isValid: false,
		touchedFields: {},
		dirtyFields: {},
		validatingFields: {},
		errors: _options.errors || {},
		disabled: _options.disabled || false
	};
	let _fields = {};
	let _defaultValues = isObject$13(_options.defaultValues) || isObject$13(_options.values) ? cloneObject(_options.defaultValues || _options.values) || {} : {};
	let _formValues = _options.shouldUnregister ? {} : cloneObject(_defaultValues);
	let _state = {
		action: false,
		mount: false,
		watch: false,
		keepIsValid: false
	};
	let _names = {
		mount: /* @__PURE__ */ new Set(),
		disabled: /* @__PURE__ */ new Set(),
		unMount: /* @__PURE__ */ new Set(),
		array: /* @__PURE__ */ new Set(),
		watch: /* @__PURE__ */ new Set()
	};
	let delayErrorCallback;
	let timer = 0;
	const defaultProxyFormState = {
		isDirty: false,
		dirtyFields: false,
		validatingFields: false,
		touchedFields: false,
		isValidating: false,
		isValid: false,
		errors: false
	};
	const _proxyFormState = { ...defaultProxyFormState };
	let _proxySubscribeFormState = { ..._proxyFormState };
	const _subjects = {
		array: createSubject(),
		state: createSubject()
	};
	const shouldDisplayAllAssociatedErrors = _options.criteriaMode === VALIDATION_MODE.all;
	const debounce$2 = (callback) => (wait) => {
		clearTimeout(timer);
		timer = setTimeout(callback, wait);
	};
	const _setValid = async (shouldUpdateValid) => {
		if (_state.keepIsValid) return;
		if (!_options.disabled && (_proxyFormState.isValid || _proxySubscribeFormState.isValid || shouldUpdateValid)) {
			let isValid;
			if (_options.resolver) {
				isValid = isEmptyObject((await _runSchema()).errors);
				_updateIsValidating();
			} else isValid = await executeBuiltInValidation(_fields, true);
			if (isValid !== _formState.isValid) _subjects.state.next({ isValid });
		}
	};
	const _updateIsValidating = (names, isValidating) => {
		if (!_options.disabled && (_proxyFormState.isValidating || _proxyFormState.validatingFields || _proxySubscribeFormState.isValidating || _proxySubscribeFormState.validatingFields)) {
			(names || Array.from(_names.mount)).forEach((name) => {
				if (name) isValidating ? set(_formState.validatingFields, name, isValidating) : unset(_formState.validatingFields, name);
			});
			_subjects.state.next({
				validatingFields: _formState.validatingFields,
				isValidating: !isEmptyObject(_formState.validatingFields)
			});
		}
	};
	const _setFieldArray = (name, values = [], method, args, shouldSetValues = true, shouldUpdateFieldsAndState = true) => {
		if (args && method && !_options.disabled) {
			_state.action = true;
			if (shouldUpdateFieldsAndState && Array.isArray(get$7(_fields, name))) {
				const fieldValues = method(get$7(_fields, name), args.argA, args.argB);
				shouldSetValues && set(_fields, name, fieldValues);
			}
			if (shouldUpdateFieldsAndState && Array.isArray(get$7(_formState.errors, name))) {
				const errors = method(get$7(_formState.errors, name), args.argA, args.argB);
				shouldSetValues && set(_formState.errors, name, errors);
				unsetEmptyArray(_formState.errors, name);
			}
			if ((_proxyFormState.touchedFields || _proxySubscribeFormState.touchedFields) && shouldUpdateFieldsAndState && Array.isArray(get$7(_formState.touchedFields, name))) {
				const touchedFields = method(get$7(_formState.touchedFields, name), args.argA, args.argB);
				shouldSetValues && set(_formState.touchedFields, name, touchedFields);
			}
			if (_proxyFormState.dirtyFields || _proxySubscribeFormState.dirtyFields) _formState.dirtyFields = getDirtyFields(_defaultValues, _formValues);
			_subjects.state.next({
				name,
				isDirty: _getDirty(name, values),
				dirtyFields: _formState.dirtyFields,
				errors: _formState.errors,
				isValid: _formState.isValid
			});
		} else set(_formValues, name, values);
	};
	const updateErrors = (name, error) => {
		set(_formState.errors, name, error);
		_subjects.state.next({ errors: _formState.errors });
	};
	const _setErrors = (errors) => {
		_formState.errors = errors;
		_subjects.state.next({
			errors: _formState.errors,
			isValid: false
		});
	};
	const updateValidAndValue = (name, shouldSkipSetValueAs, value, ref) => {
		const field = get$7(_fields, name);
		if (field) {
			const defaultValue = get$7(_formValues, name, isUndefined(value) ? get$7(_defaultValues, name) : value);
			isUndefined(defaultValue) || ref && ref.defaultChecked || shouldSkipSetValueAs ? set(_formValues, name, shouldSkipSetValueAs ? defaultValue : getFieldValue(field._f)) : setFieldValue(name, defaultValue);
			_state.mount && !_state.action && _setValid();
		}
	};
	const updateTouchAndDirty = (name, fieldValue, isBlurEvent, shouldDirty, shouldRender) => {
		let shouldUpdateField = false;
		let isPreviousDirty = false;
		const output = { name };
		if (!_options.disabled) {
			if (!isBlurEvent || shouldDirty) {
				if (_proxyFormState.isDirty || _proxySubscribeFormState.isDirty) {
					isPreviousDirty = _formState.isDirty;
					_formState.isDirty = output.isDirty = _getDirty();
					shouldUpdateField = isPreviousDirty !== output.isDirty;
				}
				const isCurrentFieldPristine = deepEqual$1(get$7(_defaultValues, name), fieldValue);
				isPreviousDirty = !!get$7(_formState.dirtyFields, name);
				isCurrentFieldPristine ? unset(_formState.dirtyFields, name) : set(_formState.dirtyFields, name, true);
				output.dirtyFields = _formState.dirtyFields;
				shouldUpdateField = shouldUpdateField || (_proxyFormState.dirtyFields || _proxySubscribeFormState.dirtyFields) && isPreviousDirty !== !isCurrentFieldPristine;
			}
			if (isBlurEvent) {
				const isPreviousFieldTouched = get$7(_formState.touchedFields, name);
				if (!isPreviousFieldTouched) {
					set(_formState.touchedFields, name, isBlurEvent);
					output.touchedFields = _formState.touchedFields;
					shouldUpdateField = shouldUpdateField || (_proxyFormState.touchedFields || _proxySubscribeFormState.touchedFields) && isPreviousFieldTouched !== isBlurEvent;
				}
			}
			shouldUpdateField && shouldRender && _subjects.state.next(output);
		}
		return shouldUpdateField ? output : {};
	};
	const shouldRenderByError = (name, isValid, error, fieldState) => {
		const previousFieldError = get$7(_formState.errors, name);
		const shouldUpdateValid = (_proxyFormState.isValid || _proxySubscribeFormState.isValid) && isBoolean$2(isValid) && _formState.isValid !== isValid;
		if (_options.delayError && error) {
			delayErrorCallback = debounce$2(() => updateErrors(name, error));
			delayErrorCallback(_options.delayError);
		} else {
			clearTimeout(timer);
			delayErrorCallback = null;
			error ? set(_formState.errors, name, error) : unset(_formState.errors, name);
		}
		if ((error ? !deepEqual$1(previousFieldError, error) : previousFieldError) || !isEmptyObject(fieldState) || shouldUpdateValid) {
			const updatedFormState = {
				...fieldState,
				...shouldUpdateValid && isBoolean$2(isValid) ? { isValid } : {},
				errors: _formState.errors,
				name
			};
			_formState = {
				..._formState,
				...updatedFormState
			};
			_subjects.state.next(updatedFormState);
		}
	};
	const _runSchema = async (name) => {
		_updateIsValidating(name, true);
		return await _options.resolver(_formValues, _options.context, getResolverOptions(name || _names.mount, _fields, _options.criteriaMode, _options.shouldUseNativeValidation));
	};
	const executeSchemaAndUpdateState = async (names) => {
		const { errors } = await _runSchema(names);
		_updateIsValidating(names);
		if (names) for (const name of names) {
			const error = get$7(errors, name);
			error ? set(_formState.errors, name, error) : unset(_formState.errors, name);
		}
		else _formState.errors = errors;
		return errors;
	};
	const executeBuiltInValidation = async (fields, shouldOnlyCheckValid, context = { valid: true }) => {
		for (const name in fields) {
			const field = fields[name];
			if (field) {
				const { _f, ...fieldValue } = field;
				if (_f) {
					const isFieldArrayRoot = _names.array.has(_f.name);
					const isPromiseFunction = field._f && hasPromiseValidation(field._f);
					if (isPromiseFunction && _proxyFormState.validatingFields) _updateIsValidating([_f.name], true);
					const fieldError = await validateField(field, _names.disabled, _formValues, shouldDisplayAllAssociatedErrors, _options.shouldUseNativeValidation && !shouldOnlyCheckValid, isFieldArrayRoot);
					if (isPromiseFunction && _proxyFormState.validatingFields) _updateIsValidating([_f.name]);
					if (fieldError[_f.name]) {
						context.valid = false;
						if (shouldOnlyCheckValid) break;
					}
					!shouldOnlyCheckValid && (get$7(fieldError, _f.name) ? isFieldArrayRoot ? updateFieldArrayRootError(_formState.errors, fieldError, _f.name) : set(_formState.errors, _f.name, fieldError[_f.name]) : unset(_formState.errors, _f.name));
				}
				!isEmptyObject(fieldValue) && await executeBuiltInValidation(fieldValue, shouldOnlyCheckValid, context);
			}
		}
		return context.valid;
	};
	const _removeUnmounted = () => {
		for (const name of _names.unMount) {
			const field = get$7(_fields, name);
			field && (field._f.refs ? field._f.refs.every((ref) => !live(ref)) : !live(field._f.ref)) && unregister(name);
		}
		_names.unMount = /* @__PURE__ */ new Set();
	};
	const _getDirty = (name, data) => !_options.disabled && (name && data && set(_formValues, name, data), !deepEqual$1(getValues(), _defaultValues));
	const _getWatch = (names, defaultValue, isGlobal) => generateWatchOutput(names, _names, { ..._state.mount ? _formValues : isUndefined(defaultValue) ? _defaultValues : isString$4(names) ? { [names]: defaultValue } : defaultValue }, isGlobal, defaultValue);
	const _getFieldArray = (name) => compact(get$7(_state.mount ? _formValues : _defaultValues, name, _options.shouldUnregister ? get$7(_defaultValues, name, []) : []));
	const setFieldValue = (name, value, options = {}) => {
		const field = get$7(_fields, name);
		let fieldValue = value;
		if (field) {
			const fieldReference = field._f;
			if (fieldReference) {
				!fieldReference.disabled && set(_formValues, name, getFieldValueAs(value, fieldReference));
				fieldValue = isHTMLElement(fieldReference.ref) && isNullOrUndefined(value) ? "" : value;
				if (isMultipleSelect(fieldReference.ref)) [...fieldReference.ref.options].forEach((optionRef) => optionRef.selected = fieldValue.includes(optionRef.value));
				else if (fieldReference.refs) if (isCheckBoxInput(fieldReference.ref)) fieldReference.refs.forEach((checkboxRef) => {
					if (!checkboxRef.defaultChecked || !checkboxRef.disabled) if (Array.isArray(fieldValue)) checkboxRef.checked = !!fieldValue.find((data) => data === checkboxRef.value);
					else checkboxRef.checked = fieldValue === checkboxRef.value || !!fieldValue;
				});
				else fieldReference.refs.forEach((radioRef) => radioRef.checked = radioRef.value === fieldValue);
				else if (isFileInput(fieldReference.ref)) fieldReference.ref.value = "";
				else {
					fieldReference.ref.value = fieldValue;
					if (!fieldReference.ref.type) _subjects.state.next({
						name,
						values: cloneObject(_formValues)
					});
				}
			}
		}
		(options.shouldDirty || options.shouldTouch) && updateTouchAndDirty(name, fieldValue, options.shouldTouch, options.shouldDirty, true);
		options.shouldValidate && trigger(name);
	};
	const setValues = (name, value, options) => {
		for (const fieldKey in value) {
			if (!value.hasOwnProperty(fieldKey)) return;
			const fieldValue = value[fieldKey];
			const fieldName = name + "." + fieldKey;
			const field = get$7(_fields, fieldName);
			(_names.array.has(name) || isObject$13(fieldValue) || field && !field._f) && !isDateObject(fieldValue) ? setValues(fieldName, fieldValue, options) : setFieldValue(fieldName, fieldValue, options);
		}
	};
	const setValue = (name, value, options = {}) => {
		const field = get$7(_fields, name);
		const isFieldArray = _names.array.has(name);
		const cloneValue = cloneObject(value);
		set(_formValues, name, cloneValue);
		if (isFieldArray) {
			_subjects.array.next({
				name,
				values: cloneObject(_formValues)
			});
			if ((_proxyFormState.isDirty || _proxyFormState.dirtyFields || _proxySubscribeFormState.isDirty || _proxySubscribeFormState.dirtyFields) && options.shouldDirty) _subjects.state.next({
				name,
				dirtyFields: getDirtyFields(_defaultValues, _formValues),
				isDirty: _getDirty(name, cloneValue)
			});
		} else field && !field._f && !isNullOrUndefined(cloneValue) ? setValues(name, cloneValue, options) : setFieldValue(name, cloneValue, options);
		isWatched(name, _names) && _subjects.state.next({
			..._formState,
			name
		});
		_subjects.state.next({
			name: _state.mount ? name : void 0,
			values: cloneObject(_formValues)
		});
	};
	const onChange = async (event) => {
		_state.mount = true;
		const target = event.target;
		let name = target.name;
		let isFieldValueUpdated = true;
		const field = get$7(_fields, name);
		const _updateIsFieldValueUpdated = (fieldValue) => {
			isFieldValueUpdated = Number.isNaN(fieldValue) || isDateObject(fieldValue) && isNaN(fieldValue.getTime()) || deepEqual$1(fieldValue, get$7(_formValues, name, fieldValue));
		};
		const validationModeBeforeSubmit = getValidationModes(_options.mode);
		const validationModeAfterSubmit = getValidationModes(_options.reValidateMode);
		if (field) {
			let error;
			let isValid;
			const fieldValue = target.type ? getFieldValue(field._f) : getEventValue(event);
			const isBlurEvent = event.type === EVENTS.BLUR || event.type === EVENTS.FOCUS_OUT;
			const shouldSkipValidation = !hasValidation(field._f) && !_options.resolver && !get$7(_formState.errors, name) && !field._f.deps || skipValidation(isBlurEvent, get$7(_formState.touchedFields, name), _formState.isSubmitted, validationModeAfterSubmit, validationModeBeforeSubmit);
			const watched = isWatched(name, _names, isBlurEvent);
			set(_formValues, name, fieldValue);
			if (isBlurEvent) {
				if (!target || !target.readOnly) {
					field._f.onBlur && field._f.onBlur(event);
					delayErrorCallback && delayErrorCallback(0);
				}
			} else if (field._f.onChange) field._f.onChange(event);
			const fieldState = updateTouchAndDirty(name, fieldValue, isBlurEvent);
			const shouldRender = !isEmptyObject(fieldState) || watched;
			!isBlurEvent && _subjects.state.next({
				name,
				type: event.type,
				values: cloneObject(_formValues)
			});
			if (shouldSkipValidation) {
				if (_proxyFormState.isValid || _proxySubscribeFormState.isValid) {
					if (_options.mode === "onBlur") {
						if (isBlurEvent) _setValid();
					} else if (!isBlurEvent) _setValid();
				}
				return shouldRender && _subjects.state.next({
					name,
					...watched ? {} : fieldState
				});
			}
			!isBlurEvent && watched && _subjects.state.next({ ..._formState });
			if (_options.resolver) {
				const { errors } = await _runSchema([name]);
				_updateIsValidating([name]);
				_updateIsFieldValueUpdated(fieldValue);
				if (isFieldValueUpdated) {
					const previousErrorLookupResult = schemaErrorLookup(_formState.errors, _fields, name);
					const errorLookupResult = schemaErrorLookup(errors, _fields, previousErrorLookupResult.name || name);
					error = errorLookupResult.error;
					name = errorLookupResult.name;
					isValid = isEmptyObject(errors);
				}
			} else {
				_updateIsValidating([name], true);
				error = (await validateField(field, _names.disabled, _formValues, shouldDisplayAllAssociatedErrors, _options.shouldUseNativeValidation))[name];
				_updateIsValidating([name]);
				_updateIsFieldValueUpdated(fieldValue);
				if (isFieldValueUpdated) {
					if (error) isValid = false;
					else if (_proxyFormState.isValid || _proxySubscribeFormState.isValid) isValid = await executeBuiltInValidation(_fields, true);
				}
			}
			if (isFieldValueUpdated) {
				field._f.deps && (!Array.isArray(field._f.deps) || field._f.deps.length > 0) && trigger(field._f.deps);
				shouldRenderByError(name, isValid, error, fieldState);
			}
		}
	};
	const _focusInput = (ref, key) => {
		if (get$7(_formState.errors, key) && ref.focus) {
			ref.focus();
			return 1;
		}
	};
	const trigger = async (name, options = {}) => {
		let isValid;
		let validationResult;
		const fieldNames = convertToArrayPayload(name);
		if (_options.resolver) {
			const errors = await executeSchemaAndUpdateState(isUndefined(name) ? name : fieldNames);
			isValid = isEmptyObject(errors);
			validationResult = name ? !fieldNames.some((name$1) => get$7(errors, name$1)) : isValid;
		} else if (name) {
			validationResult = (await Promise.all(fieldNames.map(async (fieldName) => {
				const field = get$7(_fields, fieldName);
				return await executeBuiltInValidation(field && field._f ? { [fieldName]: field } : field);
			}))).every(Boolean);
			!(!validationResult && !_formState.isValid) && _setValid();
		} else validationResult = isValid = await executeBuiltInValidation(_fields);
		_subjects.state.next({
			...!isString$4(name) || (_proxyFormState.isValid || _proxySubscribeFormState.isValid) && isValid !== _formState.isValid ? {} : { name },
			..._options.resolver || !name ? { isValid } : {},
			errors: _formState.errors
		});
		options.shouldFocus && !validationResult && iterateFieldsByAction(_fields, _focusInput, name ? fieldNames : _names.mount);
		return validationResult;
	};
	const getValues = (fieldNames, config$1) => {
		let values = { ..._state.mount ? _formValues : _defaultValues };
		if (config$1) values = extractFormValues(config$1.dirtyFields ? _formState.dirtyFields : _formState.touchedFields, values);
		return isUndefined(fieldNames) ? values : isString$4(fieldNames) ? get$7(values, fieldNames) : fieldNames.map((name) => get$7(values, name));
	};
	const getFieldState = (name, formState) => ({
		invalid: !!get$7((formState || _formState).errors, name),
		isDirty: !!get$7((formState || _formState).dirtyFields, name),
		error: get$7((formState || _formState).errors, name),
		isValidating: !!get$7(_formState.validatingFields, name),
		isTouched: !!get$7((formState || _formState).touchedFields, name)
	});
	const clearErrors = (name) => {
		name && convertToArrayPayload(name).forEach((inputName) => unset(_formState.errors, inputName));
		_subjects.state.next({ errors: name ? _formState.errors : {} });
	};
	const setError = (name, error, options) => {
		const ref = (get$7(_fields, name, { _f: {} })._f || {}).ref;
		const { ref: currentRef, message, type, ...restOfErrorTree } = get$7(_formState.errors, name) || {};
		set(_formState.errors, name, {
			...restOfErrorTree,
			...error,
			ref
		});
		_subjects.state.next({
			name,
			errors: _formState.errors,
			isValid: false
		});
		options && options.shouldFocus && ref && ref.focus && ref.focus();
	};
	const watch = (name, defaultValue) => isFunction$22(name) ? _subjects.state.subscribe({ next: (payload) => "values" in payload && name(_getWatch(void 0, defaultValue), payload) }) : _getWatch(name, defaultValue, true);
	const _subscribe = (props$1) => _subjects.state.subscribe({ next: (formState) => {
		if (shouldSubscribeByName(props$1.name, formState.name, props$1.exact) && shouldRenderFormState(formState, props$1.formState || _proxyFormState, _setFormState, props$1.reRenderRoot)) props$1.callback({
			values: { ..._formValues },
			..._formState,
			...formState,
			defaultValues: _defaultValues
		});
	} }).unsubscribe;
	const subscribe = (props$1) => {
		_state.mount = true;
		_proxySubscribeFormState = {
			..._proxySubscribeFormState,
			...props$1.formState
		};
		return _subscribe({
			...props$1,
			formState: {
				...defaultProxyFormState,
				...props$1.formState
			}
		});
	};
	const unregister = (name, options = {}) => {
		for (const fieldName of name ? convertToArrayPayload(name) : _names.mount) {
			_names.mount.delete(fieldName);
			_names.array.delete(fieldName);
			if (!options.keepValue) {
				unset(_fields, fieldName);
				unset(_formValues, fieldName);
			}
			!options.keepError && unset(_formState.errors, fieldName);
			!options.keepDirty && unset(_formState.dirtyFields, fieldName);
			!options.keepTouched && unset(_formState.touchedFields, fieldName);
			!options.keepIsValidating && unset(_formState.validatingFields, fieldName);
			!_options.shouldUnregister && !options.keepDefaultValue && unset(_defaultValues, fieldName);
		}
		_subjects.state.next({ values: cloneObject(_formValues) });
		_subjects.state.next({
			..._formState,
			...!options.keepDirty ? {} : { isDirty: _getDirty() }
		});
		!options.keepIsValid && _setValid();
	};
	const _setDisabledField = ({ disabled, name }) => {
		if (isBoolean$2(disabled) && _state.mount || !!disabled || _names.disabled.has(name)) disabled ? _names.disabled.add(name) : _names.disabled.delete(name);
	};
	const register = (name, options = {}) => {
		let field = get$7(_fields, name);
		const disabledIsDefined = isBoolean$2(options.disabled) || isBoolean$2(_options.disabled);
		set(_fields, name, {
			...field || {},
			_f: {
				...field && field._f ? field._f : { ref: { name } },
				name,
				mount: true,
				...options
			}
		});
		_names.mount.add(name);
		if (field) _setDisabledField({
			disabled: isBoolean$2(options.disabled) ? options.disabled : _options.disabled,
			name
		});
		else updateValidAndValue(name, true, options.value);
		return {
			...disabledIsDefined ? { disabled: options.disabled || _options.disabled } : {},
			..._options.progressive ? {
				required: !!options.required,
				min: getRuleValue(options.min),
				max: getRuleValue(options.max),
				minLength: getRuleValue(options.minLength),
				maxLength: getRuleValue(options.maxLength),
				pattern: getRuleValue(options.pattern)
			} : {},
			name,
			onChange,
			onBlur: onChange,
			ref: (ref) => {
				if (ref) {
					register(name, options);
					field = get$7(_fields, name);
					const fieldRef = isUndefined(ref.value) ? ref.querySelectorAll ? ref.querySelectorAll("input,select,textarea")[0] || ref : ref : ref;
					const radioOrCheckbox = isRadioOrCheckbox(fieldRef);
					const refs = field._f.refs || [];
					if (radioOrCheckbox ? refs.find((option) => option === fieldRef) : fieldRef === field._f.ref) return;
					set(_fields, name, { _f: {
						...field._f,
						...radioOrCheckbox ? {
							refs: [
								...refs.filter(live),
								fieldRef,
								...Array.isArray(get$7(_defaultValues, name)) ? [{}] : []
							],
							ref: {
								type: fieldRef.type,
								name
							}
						} : { ref: fieldRef }
					} });
					updateValidAndValue(name, false, void 0, fieldRef);
				} else {
					field = get$7(_fields, name, {});
					if (field._f) field._f.mount = false;
					(_options.shouldUnregister || options.shouldUnregister) && !(isNameInFieldArray(_names.array, name) && _state.action) && _names.unMount.add(name);
				}
			}
		};
	};
	const _focusError = () => _options.shouldFocusError && iterateFieldsByAction(_fields, _focusInput, _names.mount);
	const _disableForm = (disabled) => {
		if (isBoolean$2(disabled)) {
			_subjects.state.next({ disabled });
			iterateFieldsByAction(_fields, (ref, name) => {
				const currentField = get$7(_fields, name);
				if (currentField) {
					ref.disabled = currentField._f.disabled || disabled;
					if (Array.isArray(currentField._f.refs)) currentField._f.refs.forEach((inputRef) => {
						inputRef.disabled = currentField._f.disabled || disabled;
					});
				}
			}, 0, false);
		}
	};
	const handleSubmit = (onValid, onInvalid) => async (e) => {
		let onValidError = void 0;
		if (e) {
			e.preventDefault && e.preventDefault();
			e.persist && e.persist();
		}
		let fieldValues = cloneObject(_formValues);
		_subjects.state.next({ isSubmitting: true });
		if (_options.resolver) {
			const { errors, values } = await _runSchema();
			_updateIsValidating();
			_formState.errors = errors;
			fieldValues = cloneObject(values);
		} else await executeBuiltInValidation(_fields);
		if (_names.disabled.size) for (const name of _names.disabled) unset(fieldValues, name);
		unset(_formState.errors, "root");
		if (isEmptyObject(_formState.errors)) {
			_subjects.state.next({ errors: {} });
			try {
				await onValid(fieldValues, e);
			} catch (error) {
				onValidError = error;
			}
		} else {
			if (onInvalid) await onInvalid({ ..._formState.errors }, e);
			_focusError();
			setTimeout(_focusError);
		}
		_subjects.state.next({
			isSubmitted: true,
			isSubmitting: false,
			isSubmitSuccessful: isEmptyObject(_formState.errors) && !onValidError,
			submitCount: _formState.submitCount + 1,
			errors: _formState.errors
		});
		if (onValidError) throw onValidError;
	};
	const resetField = (name, options = {}) => {
		if (get$7(_fields, name)) {
			if (isUndefined(options.defaultValue)) setValue(name, cloneObject(get$7(_defaultValues, name)));
			else {
				setValue(name, options.defaultValue);
				set(_defaultValues, name, cloneObject(options.defaultValue));
			}
			if (!options.keepTouched) unset(_formState.touchedFields, name);
			if (!options.keepDirty) {
				unset(_formState.dirtyFields, name);
				_formState.isDirty = options.defaultValue ? _getDirty(name, cloneObject(get$7(_defaultValues, name))) : _getDirty();
			}
			if (!options.keepError) {
				unset(_formState.errors, name);
				_proxyFormState.isValid && _setValid();
			}
			_subjects.state.next({ ..._formState });
		}
	};
	const _reset = (formValues, keepStateOptions = {}) => {
		const updatedValues = formValues ? cloneObject(formValues) : _defaultValues;
		const cloneUpdatedValues = cloneObject(updatedValues);
		const isEmptyResetValues = isEmptyObject(formValues);
		const values = isEmptyResetValues ? _defaultValues : cloneUpdatedValues;
		if (!keepStateOptions.keepDefaultValues) _defaultValues = updatedValues;
		if (!keepStateOptions.keepValues) {
			if (keepStateOptions.keepDirtyValues) {
				const fieldsToCheck = new Set([..._names.mount, ...Object.keys(getDirtyFields(_defaultValues, _formValues))]);
				for (const fieldName of Array.from(fieldsToCheck)) get$7(_formState.dirtyFields, fieldName) ? set(values, fieldName, get$7(_formValues, fieldName)) : setValue(fieldName, get$7(values, fieldName));
			} else {
				if (isWeb && isUndefined(formValues)) for (const name of _names.mount) {
					const field = get$7(_fields, name);
					if (field && field._f) {
						const fieldReference = Array.isArray(field._f.refs) ? field._f.refs[0] : field._f.ref;
						if (isHTMLElement(fieldReference)) {
							const form = fieldReference.closest("form");
							if (form) {
								form.reset();
								break;
							}
						}
					}
				}
				if (keepStateOptions.keepFieldsRef) for (const fieldName of _names.mount) setValue(fieldName, get$7(values, fieldName));
				else _fields = {};
			}
			_formValues = _options.shouldUnregister ? keepStateOptions.keepDefaultValues ? cloneObject(_defaultValues) : {} : cloneObject(values);
			_subjects.array.next({ values: { ...values } });
			_subjects.state.next({ values: { ...values } });
		}
		_names = {
			mount: keepStateOptions.keepDirtyValues ? _names.mount : /* @__PURE__ */ new Set(),
			unMount: /* @__PURE__ */ new Set(),
			array: /* @__PURE__ */ new Set(),
			disabled: /* @__PURE__ */ new Set(),
			watch: /* @__PURE__ */ new Set(),
			watchAll: false,
			focus: ""
		};
		_state.mount = !_proxyFormState.isValid || !!keepStateOptions.keepIsValid || !!keepStateOptions.keepDirtyValues || !_options.shouldUnregister && !isEmptyObject(values);
		_state.watch = !!_options.shouldUnregister;
		_state.keepIsValid = !!keepStateOptions.keepIsValid;
		_state.action = false;
		if (!keepStateOptions.keepErrors) _formState.errors = {};
		_subjects.state.next({
			submitCount: keepStateOptions.keepSubmitCount ? _formState.submitCount : 0,
			isDirty: isEmptyResetValues ? false : keepStateOptions.keepDirty ? _formState.isDirty : !!(keepStateOptions.keepDefaultValues && !deepEqual$1(formValues, _defaultValues)),
			isSubmitted: keepStateOptions.keepIsSubmitted ? _formState.isSubmitted : false,
			dirtyFields: isEmptyResetValues ? {} : keepStateOptions.keepDirtyValues ? keepStateOptions.keepDefaultValues && _formValues ? getDirtyFields(_defaultValues, _formValues) : _formState.dirtyFields : keepStateOptions.keepDefaultValues && formValues ? getDirtyFields(_defaultValues, formValues) : keepStateOptions.keepDirty ? _formState.dirtyFields : {},
			touchedFields: keepStateOptions.keepTouched ? _formState.touchedFields : {},
			errors: keepStateOptions.keepErrors ? _formState.errors : {},
			isSubmitSuccessful: keepStateOptions.keepIsSubmitSuccessful ? _formState.isSubmitSuccessful : false,
			isSubmitting: false,
			defaultValues: _defaultValues
		});
	};
	const reset = (formValues, keepStateOptions) => _reset(isFunction$22(formValues) ? formValues(_formValues) : formValues, {
		..._options.resetOptions,
		...keepStateOptions
	});
	const setFocus = (name, options = {}) => {
		const field = get$7(_fields, name);
		const fieldReference = field && field._f;
		if (fieldReference) {
			const fieldRef = fieldReference.refs ? fieldReference.refs[0] : fieldReference.ref;
			if (fieldRef.focus) setTimeout(() => {
				fieldRef.focus();
				options.shouldSelect && isFunction$22(fieldRef.select) && fieldRef.select();
			});
		}
	};
	const _setFormState = (updatedFormState) => {
		_formState = {
			..._formState,
			...updatedFormState
		};
	};
	const _resetDefaultValues = () => isFunction$22(_options.defaultValues) && _options.defaultValues().then((values) => {
		reset(values, _options.resetOptions);
		_subjects.state.next({ isLoading: false });
	});
	const methods = {
		control: {
			register,
			unregister,
			getFieldState,
			handleSubmit,
			setError,
			_subscribe,
			_runSchema,
			_updateIsValidating,
			_focusError,
			_getWatch,
			_getDirty,
			_setValid,
			_setFieldArray,
			_setDisabledField,
			_setErrors,
			_getFieldArray,
			_reset,
			_resetDefaultValues,
			_removeUnmounted,
			_disableForm,
			_subjects,
			_proxyFormState,
			get _fields() {
				return _fields;
			},
			get _formValues() {
				return _formValues;
			},
			get _state() {
				return _state;
			},
			set _state(value) {
				_state = value;
			},
			get _defaultValues() {
				return _defaultValues;
			},
			get _names() {
				return _names;
			},
			set _names(value) {
				_names = value;
			},
			get _formState() {
				return _formState;
			},
			get _options() {
				return _options;
			},
			set _options(value) {
				_options = {
					..._options,
					...value
				};
			}
		},
		subscribe,
		trigger,
		register,
		handleSubmit,
		watch,
		setValue,
		getValues,
		reset,
		resetField,
		clearErrors,
		unregister,
		setError,
		setFocus,
		getFieldState
	};
	return {
		...methods,
		formControl: methods
	};
}
function useForm(props = {}) {
	const _formControl = import_react.useRef(void 0);
	const _values = import_react.useRef(void 0);
	const [formState, updateFormState] = import_react.useState({
		isDirty: false,
		isValidating: false,
		isLoading: isFunction$22(props.defaultValues),
		isSubmitted: false,
		isSubmitting: false,
		isSubmitSuccessful: false,
		isValid: false,
		submitCount: 0,
		dirtyFields: {},
		touchedFields: {},
		validatingFields: {},
		errors: props.errors || {},
		disabled: props.disabled || false,
		isReady: false,
		defaultValues: isFunction$22(props.defaultValues) ? void 0 : props.defaultValues
	});
	if (!_formControl.current) if (props.formControl) {
		_formControl.current = {
			...props.formControl,
			formState
		};
		if (props.defaultValues && !isFunction$22(props.defaultValues)) props.formControl.reset(props.defaultValues, props.resetOptions);
	} else {
		const { formControl, ...rest } = createFormControl(props);
		_formControl.current = {
			...rest,
			formState
		};
	}
	const control = _formControl.current.control;
	control._options = props;
	useIsomorphicLayoutEffect(() => {
		const sub = control._subscribe({
			formState: control._proxyFormState,
			callback: () => updateFormState({ ...control._formState }),
			reRenderRoot: true
		});
		updateFormState((data) => ({
			...data,
			isReady: true
		}));
		control._formState.isReady = true;
		return sub;
	}, [control]);
	import_react.useEffect(() => control._disableForm(props.disabled), [control, props.disabled]);
	import_react.useEffect(() => {
		if (props.mode) control._options.mode = props.mode;
		if (props.reValidateMode) control._options.reValidateMode = props.reValidateMode;
	}, [
		control,
		props.mode,
		props.reValidateMode
	]);
	import_react.useEffect(() => {
		if (props.errors) {
			control._setErrors(props.errors);
			control._focusError();
		}
	}, [control, props.errors]);
	import_react.useEffect(() => {
		props.shouldUnregister && control._subjects.state.next({ values: control._getWatch() });
	}, [control, props.shouldUnregister]);
	import_react.useEffect(() => {
		if (control._proxyFormState.isDirty) {
			const isDirty = control._getDirty();
			if (isDirty !== formState.isDirty) control._subjects.state.next({ isDirty });
		}
	}, [control, formState.isDirty]);
	import_react.useEffect(() => {
		var _a$1;
		if (props.values && !deepEqual$1(props.values, _values.current)) {
			control._reset(props.values, {
				keepFieldsRef: true,
				...control._options.resetOptions
			});
			if (!((_a$1 = control._options.resetOptions) === null || _a$1 === void 0 ? void 0 : _a$1.keepIsValid)) control._setValid();
			_values.current = props.values;
			updateFormState((state) => ({ ...state }));
		} else control._resetDefaultValues();
	}, [control, props.values]);
	import_react.useEffect(() => {
		if (!control._state.mount) {
			control._setValid();
			control._state.mount = true;
		}
		if (control._state.watch) {
			control._state.watch = false;
			control._subjects.state.next({ ...control._formState });
		}
		control._removeUnmounted();
	});
	_formControl.current.formState = getProxyFormState(formState, control);
	return _formControl.current;
}
var r = (t$1, r$1, o$1) => {
	if (t$1 && "reportValidity" in t$1) {
		const s$3 = get$7(o$1, r$1);
		t$1.setCustomValidity(s$3 && s$3.message || ""), t$1.reportValidity();
	}
}, o = (e, t$1) => {
	for (const o$1 in t$1.fields) {
		const s$3 = t$1.fields[o$1];
		s$3 && s$3.ref && "reportValidity" in s$3.ref ? r(s$3.ref, o$1, e) : s$3 && s$3.refs && s$3.refs.forEach((t$2) => r(t$2, o$1, e));
	}
}, s$1 = (r$1, s$3) => {
	s$3.shouldUseNativeValidation && o(r$1, s$3);
	const n$1 = {};
	for (const o$1 in r$1) {
		const f = get$7(s$3.fields, o$1), c$1 = Object.assign(r$1[o$1] || {}, { ref: f && f.ref });
		if (i$1(s$3.names || Object.keys(r$1), o$1)) {
			const r$2 = Object.assign({}, get$7(n$1, o$1));
			set(r$2, "root", c$1), set(n$1, o$1, r$2);
		} else set(n$1, o$1, c$1);
	}
	return n$1;
}, i$1 = (e, t$1) => {
	const r$1 = n(t$1);
	return e.some((e$1) => n(e$1).match(`^${r$1}\\.\\d+`));
};
function n(e) {
	return e.replace(/\]|\[/g, "");
}
Object.freeze({ status: "aborted" });
function $constructor(name, initializer$2, params) {
	function init(inst, def) {
		if (!inst._zod) Object.defineProperty(inst, "_zod", {
			value: {
				def,
				constr: _,
				traits: /* @__PURE__ */ new Set()
			},
			enumerable: false
		});
		if (inst._zod.traits.has(name)) return;
		inst._zod.traits.add(name);
		initializer$2(inst, def);
		const proto = _.prototype;
		const keys$6 = Object.keys(proto);
		for (let i$2 = 0; i$2 < keys$6.length; i$2++) {
			const k$1 = keys$6[i$2];
			if (!(k$1 in inst)) inst[k$1] = proto[k$1].bind(inst);
		}
	}
	const Parent = params?.Parent ?? Object;
	class Definition extends Parent {}
	Object.defineProperty(Definition, "name", { value: name });
	function _(def) {
		var _a$1;
		const inst = params?.Parent ? new Definition() : this;
		init(inst, def);
		(_a$1 = inst._zod).deferred ?? (_a$1.deferred = []);
		for (const fn of inst._zod.deferred) fn();
		return inst;
	}
	Object.defineProperty(_, "init", { value: init });
	Object.defineProperty(_, Symbol.hasInstance, { value: (inst) => {
		if (params?.Parent && inst instanceof params.Parent) return true;
		return inst?._zod?.traits?.has(name);
	} });
	Object.defineProperty(_, "name", { value: name });
	return _;
}
var $ZodAsyncError = class extends Error {
	constructor() {
		super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
	}
};
var $ZodEncodeError = class extends Error {
	constructor(name) {
		super(`Encountered unidirectional transform during encode: ${name}`);
		this.name = "ZodEncodeError";
	}
};
const globalConfig = {};
function config(newConfig) {
	if (newConfig) Object.assign(globalConfig, newConfig);
	return globalConfig;
}
function getEnumValues(entries) {
	const numericValues = Object.values(entries).filter((v) => typeof v === "number");
	return Object.entries(entries).filter(([k$1, _]) => numericValues.indexOf(+k$1) === -1).map(([_, v]) => v);
}
function jsonStringifyReplacer(_, value) {
	if (typeof value === "bigint") return value.toString();
	return value;
}
function cached(getter) {
	return { get value() {
		{
			const value = getter();
			Object.defineProperty(this, "value", { value });
			return value;
		}
		throw new Error("cached value already set");
	} };
}
function nullish(input) {
	return input === null || input === void 0;
}
function cleanRegex(source) {
	const start = source.startsWith("^") ? 1 : 0;
	const end = source.endsWith("$") ? source.length - 1 : source.length;
	return source.slice(start, end);
}
function floatSafeRemainder(val, step) {
	const valDecCount = (val.toString().split(".")[1] || "").length;
	const stepString = step.toString();
	let stepDecCount = (stepString.split(".")[1] || "").length;
	if (stepDecCount === 0 && /\d?e-\d?/.test(stepString)) {
		const match = stepString.match(/\d?e-(\d?)/);
		if (match?.[1]) stepDecCount = Number.parseInt(match[1]);
	}
	const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
	return Number.parseInt(val.toFixed(decCount).replace(".", "")) % Number.parseInt(step.toFixed(decCount).replace(".", "")) / 10 ** decCount;
}
var EVALUATING = Symbol("evaluating");
function defineLazy(object$1, key, getter) {
	let value = void 0;
	Object.defineProperty(object$1, key, {
		get() {
			if (value === EVALUATING) return;
			if (value === void 0) {
				value = EVALUATING;
				value = getter();
			}
			return value;
		},
		set(v) {
			Object.defineProperty(object$1, key, { value: v });
		},
		configurable: true
	});
}
function assignProp(target, prop, value) {
	Object.defineProperty(target, prop, {
		value,
		writable: true,
		enumerable: true,
		configurable: true
	});
}
function mergeDefs(...defs) {
	const mergedDescriptors = {};
	for (const def of defs) {
		const descriptors = Object.getOwnPropertyDescriptors(def);
		Object.assign(mergedDescriptors, descriptors);
	}
	return Object.defineProperties({}, mergedDescriptors);
}
function esc(str) {
	return JSON.stringify(str);
}
function slugify(input) {
	return input.toLowerCase().trim().replace(/[^\w\s-]/g, "").replace(/[\s_-]+/g, "-").replace(/^-+|-+$/g, "");
}
const captureStackTrace = "captureStackTrace" in Error ? Error.captureStackTrace : (..._args) => {};
function isObject$12(data) {
	return typeof data === "object" && data !== null && !Array.isArray(data);
}
const allowsEval = cached(() => {
	if (typeof navigator !== "undefined" && navigator?.userAgent?.includes("Cloudflare")) return false;
	try {
		new Function("");
		return true;
	} catch (_) {
		return false;
	}
});
function isPlainObject$2(o$1) {
	if (isObject$12(o$1) === false) return false;
	const ctor = o$1.constructor;
	if (ctor === void 0) return true;
	if (typeof ctor !== "function") return true;
	const prot = ctor.prototype;
	if (isObject$12(prot) === false) return false;
	if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) return false;
	return true;
}
function shallowClone(o$1) {
	if (isPlainObject$2(o$1)) return { ...o$1 };
	if (Array.isArray(o$1)) return [...o$1];
	return o$1;
}
const propertyKeyTypes = new Set([
	"string",
	"number",
	"symbol"
]);
function escapeRegex(str) {
	return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function clone(inst, def, params) {
	const cl = new inst._zod.constr(def ?? inst._zod.def);
	if (!def || params?.parent) cl._zod.parent = inst;
	return cl;
}
function normalizeParams(_params) {
	const params = _params;
	if (!params) return {};
	if (typeof params === "string") return { error: () => params };
	if (params?.message !== void 0) {
		if (params?.error !== void 0) throw new Error("Cannot specify both `message` and `error` params");
		params.error = params.message;
	}
	delete params.message;
	if (typeof params.error === "string") return {
		...params,
		error: () => params.error
	};
	return params;
}
function optionalKeys(shape) {
	return Object.keys(shape).filter((k$1) => {
		return shape[k$1]._zod.optin === "optional" && shape[k$1]._zod.optout === "optional";
	});
}
const NUMBER_FORMAT_RANGES = {
	safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
	int32: [-2147483648, 2147483647],
	uint32: [0, 4294967295],
	float32: [-34028234663852886e22, 34028234663852886e22],
	float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
};
function pick(schema, mask) {
	const currDef = schema._zod.def;
	return clone(schema, mergeDefs(schema._zod.def, {
		get shape() {
			const newShape = {};
			for (const key in mask) {
				if (!(key in currDef.shape)) throw new Error(`Unrecognized key: "${key}"`);
				if (!mask[key]) continue;
				newShape[key] = currDef.shape[key];
			}
			assignProp(this, "shape", newShape);
			return newShape;
		},
		checks: []
	}));
}
function omit(schema, mask) {
	const currDef = schema._zod.def;
	return clone(schema, mergeDefs(schema._zod.def, {
		get shape() {
			const newShape = { ...schema._zod.def.shape };
			for (const key in mask) {
				if (!(key in currDef.shape)) throw new Error(`Unrecognized key: "${key}"`);
				if (!mask[key]) continue;
				delete newShape[key];
			}
			assignProp(this, "shape", newShape);
			return newShape;
		},
		checks: []
	}));
}
function extend$1(schema, shape) {
	if (!isPlainObject$2(shape)) throw new Error("Invalid input to extend: expected a plain object");
	const checks = schema._zod.def.checks;
	if (checks && checks.length > 0) throw new Error("Object schemas containing refinements cannot be extended. Use `.safeExtend()` instead.");
	return clone(schema, mergeDefs(schema._zod.def, {
		get shape() {
			const _shape = {
				...schema._zod.def.shape,
				...shape
			};
			assignProp(this, "shape", _shape);
			return _shape;
		},
		checks: []
	}));
}
function safeExtend(schema, shape) {
	if (!isPlainObject$2(shape)) throw new Error("Invalid input to safeExtend: expected a plain object");
	return clone(schema, {
		...schema._zod.def,
		get shape() {
			const _shape = {
				...schema._zod.def.shape,
				...shape
			};
			assignProp(this, "shape", _shape);
			return _shape;
		},
		checks: schema._zod.def.checks
	});
}
function merge(a$2, b) {
	return clone(a$2, mergeDefs(a$2._zod.def, {
		get shape() {
			const _shape = {
				...a$2._zod.def.shape,
				...b._zod.def.shape
			};
			assignProp(this, "shape", _shape);
			return _shape;
		},
		get catchall() {
			return b._zod.def.catchall;
		},
		checks: []
	}));
}
function partial(Class, schema, mask) {
	return clone(schema, mergeDefs(schema._zod.def, {
		get shape() {
			const oldShape = schema._zod.def.shape;
			const shape = { ...oldShape };
			if (mask) for (const key in mask) {
				if (!(key in oldShape)) throw new Error(`Unrecognized key: "${key}"`);
				if (!mask[key]) continue;
				shape[key] = Class ? new Class({
					type: "optional",
					innerType: oldShape[key]
				}) : oldShape[key];
			}
			else for (const key in oldShape) shape[key] = Class ? new Class({
				type: "optional",
				innerType: oldShape[key]
			}) : oldShape[key];
			assignProp(this, "shape", shape);
			return shape;
		},
		checks: []
	}));
}
function required(Class, schema, mask) {
	return clone(schema, mergeDefs(schema._zod.def, {
		get shape() {
			const oldShape = schema._zod.def.shape;
			const shape = { ...oldShape };
			if (mask) for (const key in mask) {
				if (!(key in shape)) throw new Error(`Unrecognized key: "${key}"`);
				if (!mask[key]) continue;
				shape[key] = new Class({
					type: "nonoptional",
					innerType: oldShape[key]
				});
			}
			else for (const key in oldShape) shape[key] = new Class({
				type: "nonoptional",
				innerType: oldShape[key]
			});
			assignProp(this, "shape", shape);
			return shape;
		},
		checks: []
	}));
}
function aborted(x$1, startIndex = 0) {
	if (x$1.aborted === true) return true;
	for (let i$2 = startIndex; i$2 < x$1.issues.length; i$2++) if (x$1.issues[i$2]?.continue !== true) return true;
	return false;
}
function prefixIssues(path$1, issues) {
	return issues.map((iss) => {
		var _a$1;
		(_a$1 = iss).path ?? (_a$1.path = []);
		iss.path.unshift(path$1);
		return iss;
	});
}
function unwrapMessage(message) {
	return typeof message === "string" ? message : message?.message;
}
function finalizeIssue(iss, ctx, config$1) {
	const full = {
		...iss,
		path: iss.path ?? []
	};
	if (!iss.message) full.message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage(ctx?.error?.(iss)) ?? unwrapMessage(config$1.customError?.(iss)) ?? unwrapMessage(config$1.localeError?.(iss)) ?? "Invalid input";
	delete full.inst;
	delete full.continue;
	if (!ctx?.reportInput) delete full.input;
	return full;
}
function getLengthableOrigin(input) {
	if (Array.isArray(input)) return "array";
	if (typeof input === "string") return "string";
	return "unknown";
}
function issue(...args) {
	const [iss, input, inst] = args;
	if (typeof iss === "string") return {
		message: iss,
		code: "custom",
		input,
		inst
	};
	return { ...iss };
}
var initializer$1 = (inst, def) => {
	inst.name = "$ZodError";
	Object.defineProperty(inst, "_zod", {
		value: inst._zod,
		enumerable: false
	});
	Object.defineProperty(inst, "issues", {
		value: def,
		enumerable: false
	});
	inst.message = JSON.stringify(def, jsonStringifyReplacer, 2);
	Object.defineProperty(inst, "toString", {
		value: () => inst.message,
		enumerable: false
	});
};
const $ZodError = $constructor("$ZodError", initializer$1);
const $ZodRealError = $constructor("$ZodError", initializer$1, { Parent: Error });
function flattenError(error, mapper = (issue$1) => issue$1.message) {
	const fieldErrors = {};
	const formErrors = [];
	for (const sub of error.issues) if (sub.path.length > 0) {
		fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
		fieldErrors[sub.path[0]].push(mapper(sub));
	} else formErrors.push(mapper(sub));
	return {
		formErrors,
		fieldErrors
	};
}
function formatError(error, mapper = (issue$1) => issue$1.message) {
	const fieldErrors = { _errors: [] };
	const processError = (error$1) => {
		for (const issue$1 of error$1.issues) if (issue$1.code === "invalid_union" && issue$1.errors.length) issue$1.errors.map((issues) => processError({ issues }));
		else if (issue$1.code === "invalid_key") processError({ issues: issue$1.issues });
		else if (issue$1.code === "invalid_element") processError({ issues: issue$1.issues });
		else if (issue$1.path.length === 0) fieldErrors._errors.push(mapper(issue$1));
		else {
			let curr = fieldErrors;
			let i$2 = 0;
			while (i$2 < issue$1.path.length) {
				const el = issue$1.path[i$2];
				if (!(i$2 === issue$1.path.length - 1)) curr[el] = curr[el] || { _errors: [] };
				else {
					curr[el] = curr[el] || { _errors: [] };
					curr[el]._errors.push(mapper(issue$1));
				}
				curr = curr[el];
				i$2++;
			}
		}
	};
	processError(error);
	return fieldErrors;
}
const _parse = (_Err) => (schema, value, _ctx, _params) => {
	const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
	const result = schema._zod.run({
		value,
		issues: []
	}, ctx);
	if (result instanceof Promise) throw new $ZodAsyncError();
	if (result.issues.length) {
		const e = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
		captureStackTrace(e, _params?.callee);
		throw e;
	}
	return result.value;
};
const parse$1 = /* @__PURE__ */ _parse($ZodRealError);
const _parseAsync = (_Err) => async (schema, value, _ctx, params) => {
	const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
	let result = schema._zod.run({
		value,
		issues: []
	}, ctx);
	if (result instanceof Promise) result = await result;
	if (result.issues.length) {
		const e = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
		captureStackTrace(e, params?.callee);
		throw e;
	}
	return result.value;
};
const parseAsync$1 = /* @__PURE__ */ _parseAsync($ZodRealError);
const _safeParse = (_Err) => (schema, value, _ctx) => {
	const ctx = _ctx ? {
		..._ctx,
		async: false
	} : { async: false };
	const result = schema._zod.run({
		value,
		issues: []
	}, ctx);
	if (result instanceof Promise) throw new $ZodAsyncError();
	return result.issues.length ? {
		success: false,
		error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
	} : {
		success: true,
		data: result.value
	};
};
const safeParse$1 = /* @__PURE__ */ _safeParse($ZodRealError);
const _safeParseAsync = (_Err) => async (schema, value, _ctx) => {
	const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
	let result = schema._zod.run({
		value,
		issues: []
	}, ctx);
	if (result instanceof Promise) result = await result;
	return result.issues.length ? {
		success: false,
		error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
	} : {
		success: true,
		data: result.value
	};
};
const safeParseAsync$1 = /* @__PURE__ */ _safeParseAsync($ZodRealError);
const _encode = (_Err) => (schema, value, _ctx) => {
	const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
	return _parse(_Err)(schema, value, ctx);
};
const _decode = (_Err) => (schema, value, _ctx) => {
	return _parse(_Err)(schema, value, _ctx);
};
const _encodeAsync = (_Err) => async (schema, value, _ctx) => {
	const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
	return _parseAsync(_Err)(schema, value, ctx);
};
const _decodeAsync = (_Err) => async (schema, value, _ctx) => {
	return _parseAsync(_Err)(schema, value, _ctx);
};
const _safeEncode = (_Err) => (schema, value, _ctx) => {
	const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
	return _safeParse(_Err)(schema, value, ctx);
};
const _safeDecode = (_Err) => (schema, value, _ctx) => {
	return _safeParse(_Err)(schema, value, _ctx);
};
const _safeEncodeAsync = (_Err) => async (schema, value, _ctx) => {
	const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
	return _safeParseAsync(_Err)(schema, value, ctx);
};
const _safeDecodeAsync = (_Err) => async (schema, value, _ctx) => {
	return _safeParseAsync(_Err)(schema, value, _ctx);
};
const cuid = /^[cC][^\s-]{8,}$/;
const cuid2 = /^[0-9a-z]+$/;
const ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
const xid = /^[0-9a-vA-V]{20}$/;
const ksuid = /^[A-Za-z0-9]{27}$/;
const nanoid = /^[a-zA-Z0-9_-]{21}$/;
const duration$1 = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
const guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
const uuid = (version$1) => {
	if (!version$1) return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/;
	return /* @__PURE__ */ new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version$1}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
};
const email = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
var _emoji$1 = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
function emoji() {
	return new RegExp(_emoji$1, "u");
}
const ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/;
const cidrv4 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
const cidrv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
const base64 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
const base64url = /^[A-Za-z0-9_-]*$/;
const e164 = /^\+(?:[0-9]){6,14}[0-9]$/;
var dateSource = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`;
const date$3 = /* @__PURE__ */ new RegExp(`^${dateSource}$`);
function timeSource(args) {
	const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
	return typeof args.precision === "number" ? args.precision === -1 ? `${hhmm}` : args.precision === 0 ? `${hhmm}:[0-5]\\d` : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
}
function time$2(args) {
	return /* @__PURE__ */ new RegExp(`^${timeSource(args)}$`);
}
function datetime$1(args) {
	const time$3 = timeSource({ precision: args.precision });
	const opts = ["Z"];
	if (args.local) opts.push("");
	if (args.offset) opts.push(`([+-](?:[01]\\d|2[0-3]):[0-5]\\d)`);
	const timeRegex = `${time$3}(?:${opts.join("|")})`;
	return /* @__PURE__ */ new RegExp(`^${dateSource}T(?:${timeRegex})$`);
}
const string$1 = (params) => {
	const regex = params ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : `[\\s\\S]*`;
	return /* @__PURE__ */ new RegExp(`^${regex}$`);
};
const integer = /^-?\d+$/;
const number$4 = /^-?\d+(?:\.\d+)?/;
const lowercase = /^[^A-Z]*$/;
const uppercase = /^[^a-z]*$/;
const $ZodCheck = /* @__PURE__ */ $constructor("$ZodCheck", (inst, def) => {
	var _a$1;
	inst._zod ?? (inst._zod = {});
	inst._zod.def = def;
	(_a$1 = inst._zod).onattach ?? (_a$1.onattach = []);
});
var numericOriginMap = {
	number: "number",
	bigint: "bigint",
	object: "date"
};
const $ZodCheckLessThan = /* @__PURE__ */ $constructor("$ZodCheckLessThan", (inst, def) => {
	$ZodCheck.init(inst, def);
	const origin = numericOriginMap[typeof def.value];
	inst._zod.onattach.push((inst$1) => {
		const bag = inst$1._zod.bag;
		const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
		if (def.value < curr) if (def.inclusive) bag.maximum = def.value;
		else bag.exclusiveMaximum = def.value;
	});
	inst._zod.check = (payload) => {
		if (def.inclusive ? payload.value <= def.value : payload.value < def.value) return;
		payload.issues.push({
			origin,
			code: "too_big",
			maximum: def.value,
			input: payload.value,
			inclusive: def.inclusive,
			inst,
			continue: !def.abort
		});
	};
});
const $ZodCheckGreaterThan = /* @__PURE__ */ $constructor("$ZodCheckGreaterThan", (inst, def) => {
	$ZodCheck.init(inst, def);
	const origin = numericOriginMap[typeof def.value];
	inst._zod.onattach.push((inst$1) => {
		const bag = inst$1._zod.bag;
		const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
		if (def.value > curr) if (def.inclusive) bag.minimum = def.value;
		else bag.exclusiveMinimum = def.value;
	});
	inst._zod.check = (payload) => {
		if (def.inclusive ? payload.value >= def.value : payload.value > def.value) return;
		payload.issues.push({
			origin,
			code: "too_small",
			minimum: def.value,
			input: payload.value,
			inclusive: def.inclusive,
			inst,
			continue: !def.abort
		});
	};
});
const $ZodCheckMultipleOf = /* @__PURE__ */ $constructor("$ZodCheckMultipleOf", (inst, def) => {
	$ZodCheck.init(inst, def);
	inst._zod.onattach.push((inst$1) => {
		var _a$1;
		(_a$1 = inst$1._zod.bag).multipleOf ?? (_a$1.multipleOf = def.value);
	});
	inst._zod.check = (payload) => {
		if (typeof payload.value !== typeof def.value) throw new Error("Cannot mix number and bigint in multiple_of check.");
		if (typeof payload.value === "bigint" ? payload.value % def.value === BigInt(0) : floatSafeRemainder(payload.value, def.value) === 0) return;
		payload.issues.push({
			origin: typeof payload.value,
			code: "not_multiple_of",
			divisor: def.value,
			input: payload.value,
			inst,
			continue: !def.abort
		});
	};
});
const $ZodCheckNumberFormat = /* @__PURE__ */ $constructor("$ZodCheckNumberFormat", (inst, def) => {
	$ZodCheck.init(inst, def);
	def.format = def.format || "float64";
	const isInt = def.format?.includes("int");
	const origin = isInt ? "int" : "number";
	const [minimum, maximum] = NUMBER_FORMAT_RANGES[def.format];
	inst._zod.onattach.push((inst$1) => {
		const bag = inst$1._zod.bag;
		bag.format = def.format;
		bag.minimum = minimum;
		bag.maximum = maximum;
		if (isInt) bag.pattern = integer;
	});
	inst._zod.check = (payload) => {
		const input = payload.value;
		if (isInt) {
			if (!Number.isInteger(input)) {
				payload.issues.push({
					expected: origin,
					format: def.format,
					code: "invalid_type",
					continue: false,
					input,
					inst
				});
				return;
			}
			if (!Number.isSafeInteger(input)) {
				if (input > 0) payload.issues.push({
					input,
					code: "too_big",
					maximum: Number.MAX_SAFE_INTEGER,
					note: "Integers must be within the safe integer range.",
					inst,
					origin,
					continue: !def.abort
				});
				else payload.issues.push({
					input,
					code: "too_small",
					minimum: Number.MIN_SAFE_INTEGER,
					note: "Integers must be within the safe integer range.",
					inst,
					origin,
					continue: !def.abort
				});
				return;
			}
		}
		if (input < minimum) payload.issues.push({
			origin: "number",
			input,
			code: "too_small",
			minimum,
			inclusive: true,
			inst,
			continue: !def.abort
		});
		if (input > maximum) payload.issues.push({
			origin: "number",
			input,
			code: "too_big",
			maximum,
			inst
		});
	};
});
const $ZodCheckMaxLength = /* @__PURE__ */ $constructor("$ZodCheckMaxLength", (inst, def) => {
	var _a$1;
	$ZodCheck.init(inst, def);
	(_a$1 = inst._zod.def).when ?? (_a$1.when = (payload) => {
		const val = payload.value;
		return !nullish(val) && val.length !== void 0;
	});
	inst._zod.onattach.push((inst$1) => {
		const curr = inst$1._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
		if (def.maximum < curr) inst$1._zod.bag.maximum = def.maximum;
	});
	inst._zod.check = (payload) => {
		const input = payload.value;
		if (input.length <= def.maximum) return;
		const origin = getLengthableOrigin(input);
		payload.issues.push({
			origin,
			code: "too_big",
			maximum: def.maximum,
			inclusive: true,
			input,
			inst,
			continue: !def.abort
		});
	};
});
const $ZodCheckMinLength = /* @__PURE__ */ $constructor("$ZodCheckMinLength", (inst, def) => {
	var _a$1;
	$ZodCheck.init(inst, def);
	(_a$1 = inst._zod.def).when ?? (_a$1.when = (payload) => {
		const val = payload.value;
		return !nullish(val) && val.length !== void 0;
	});
	inst._zod.onattach.push((inst$1) => {
		const curr = inst$1._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
		if (def.minimum > curr) inst$1._zod.bag.minimum = def.minimum;
	});
	inst._zod.check = (payload) => {
		const input = payload.value;
		if (input.length >= def.minimum) return;
		const origin = getLengthableOrigin(input);
		payload.issues.push({
			origin,
			code: "too_small",
			minimum: def.minimum,
			inclusive: true,
			input,
			inst,
			continue: !def.abort
		});
	};
});
const $ZodCheckLengthEquals = /* @__PURE__ */ $constructor("$ZodCheckLengthEquals", (inst, def) => {
	var _a$1;
	$ZodCheck.init(inst, def);
	(_a$1 = inst._zod.def).when ?? (_a$1.when = (payload) => {
		const val = payload.value;
		return !nullish(val) && val.length !== void 0;
	});
	inst._zod.onattach.push((inst$1) => {
		const bag = inst$1._zod.bag;
		bag.minimum = def.length;
		bag.maximum = def.length;
		bag.length = def.length;
	});
	inst._zod.check = (payload) => {
		const input = payload.value;
		const length = input.length;
		if (length === def.length) return;
		const origin = getLengthableOrigin(input);
		const tooBig = length > def.length;
		payload.issues.push({
			origin,
			...tooBig ? {
				code: "too_big",
				maximum: def.length
			} : {
				code: "too_small",
				minimum: def.length
			},
			inclusive: true,
			exact: true,
			input: payload.value,
			inst,
			continue: !def.abort
		});
	};
});
const $ZodCheckStringFormat = /* @__PURE__ */ $constructor("$ZodCheckStringFormat", (inst, def) => {
	var _a$1, _b;
	$ZodCheck.init(inst, def);
	inst._zod.onattach.push((inst$1) => {
		const bag = inst$1._zod.bag;
		bag.format = def.format;
		if (def.pattern) {
			bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
			bag.patterns.add(def.pattern);
		}
	});
	if (def.pattern) (_a$1 = inst._zod).check ?? (_a$1.check = (payload) => {
		def.pattern.lastIndex = 0;
		if (def.pattern.test(payload.value)) return;
		payload.issues.push({
			origin: "string",
			code: "invalid_format",
			format: def.format,
			input: payload.value,
			...def.pattern ? { pattern: def.pattern.toString() } : {},
			inst,
			continue: !def.abort
		});
	});
	else (_b = inst._zod).check ?? (_b.check = () => {});
});
const $ZodCheckRegex = /* @__PURE__ */ $constructor("$ZodCheckRegex", (inst, def) => {
	$ZodCheckStringFormat.init(inst, def);
	inst._zod.check = (payload) => {
		def.pattern.lastIndex = 0;
		if (def.pattern.test(payload.value)) return;
		payload.issues.push({
			origin: "string",
			code: "invalid_format",
			format: "regex",
			input: payload.value,
			pattern: def.pattern.toString(),
			inst,
			continue: !def.abort
		});
	};
});
const $ZodCheckLowerCase = /* @__PURE__ */ $constructor("$ZodCheckLowerCase", (inst, def) => {
	def.pattern ?? (def.pattern = lowercase);
	$ZodCheckStringFormat.init(inst, def);
});
const $ZodCheckUpperCase = /* @__PURE__ */ $constructor("$ZodCheckUpperCase", (inst, def) => {
	def.pattern ?? (def.pattern = uppercase);
	$ZodCheckStringFormat.init(inst, def);
});
const $ZodCheckIncludes = /* @__PURE__ */ $constructor("$ZodCheckIncludes", (inst, def) => {
	$ZodCheck.init(inst, def);
	const escapedRegex = escapeRegex(def.includes);
	const pattern = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
	def.pattern = pattern;
	inst._zod.onattach.push((inst$1) => {
		const bag = inst$1._zod.bag;
		bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
		bag.patterns.add(pattern);
	});
	inst._zod.check = (payload) => {
		if (payload.value.includes(def.includes, def.position)) return;
		payload.issues.push({
			origin: "string",
			code: "invalid_format",
			format: "includes",
			includes: def.includes,
			input: payload.value,
			inst,
			continue: !def.abort
		});
	};
});
const $ZodCheckStartsWith = /* @__PURE__ */ $constructor("$ZodCheckStartsWith", (inst, def) => {
	$ZodCheck.init(inst, def);
	const pattern = /* @__PURE__ */ new RegExp(`^${escapeRegex(def.prefix)}.*`);
	def.pattern ?? (def.pattern = pattern);
	inst._zod.onattach.push((inst$1) => {
		const bag = inst$1._zod.bag;
		bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
		bag.patterns.add(pattern);
	});
	inst._zod.check = (payload) => {
		if (payload.value.startsWith(def.prefix)) return;
		payload.issues.push({
			origin: "string",
			code: "invalid_format",
			format: "starts_with",
			prefix: def.prefix,
			input: payload.value,
			inst,
			continue: !def.abort
		});
	};
});
const $ZodCheckEndsWith = /* @__PURE__ */ $constructor("$ZodCheckEndsWith", (inst, def) => {
	$ZodCheck.init(inst, def);
	const pattern = /* @__PURE__ */ new RegExp(`.*${escapeRegex(def.suffix)}$`);
	def.pattern ?? (def.pattern = pattern);
	inst._zod.onattach.push((inst$1) => {
		const bag = inst$1._zod.bag;
		bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
		bag.patterns.add(pattern);
	});
	inst._zod.check = (payload) => {
		if (payload.value.endsWith(def.suffix)) return;
		payload.issues.push({
			origin: "string",
			code: "invalid_format",
			format: "ends_with",
			suffix: def.suffix,
			input: payload.value,
			inst,
			continue: !def.abort
		});
	};
});
const $ZodCheckOverwrite = /* @__PURE__ */ $constructor("$ZodCheckOverwrite", (inst, def) => {
	$ZodCheck.init(inst, def);
	inst._zod.check = (payload) => {
		payload.value = def.tx(payload.value);
	};
});
var Doc = class {
	constructor(args = []) {
		this.content = [];
		this.indent = 0;
		if (this) this.args = args;
	}
	indented(fn) {
		this.indent += 1;
		fn(this);
		this.indent -= 1;
	}
	write(arg) {
		if (typeof arg === "function") {
			arg(this, { execution: "sync" });
			arg(this, { execution: "async" });
			return;
		}
		const lines = arg.split("\n").filter((x$1) => x$1);
		const minIndent = Math.min(...lines.map((x$1) => x$1.length - x$1.trimStart().length));
		const dedented = lines.map((x$1) => x$1.slice(minIndent)).map((x$1) => " ".repeat(this.indent * 2) + x$1);
		for (const line of dedented) this.content.push(line);
	}
	compile() {
		const F = Function;
		const args = this?.args;
		const lines = [...(this?.content ?? [``]).map((x$1) => `  ${x$1}`)];
		return new F(...args, lines.join("\n"));
	}
};
const version = {
	major: 4,
	minor: 2,
	patch: 1
};
const $ZodType = /* @__PURE__ */ $constructor("$ZodType", (inst, def) => {
	var _a$1;
	inst ?? (inst = {});
	inst._zod.def = def;
	inst._zod.bag = inst._zod.bag || {};
	inst._zod.version = version;
	const checks = [...inst._zod.def.checks ?? []];
	if (inst._zod.traits.has("$ZodCheck")) checks.unshift(inst);
	for (const ch of checks) for (const fn of ch._zod.onattach) fn(inst);
	if (checks.length === 0) {
		(_a$1 = inst._zod).deferred ?? (_a$1.deferred = []);
		inst._zod.deferred?.push(() => {
			inst._zod.run = inst._zod.parse;
		});
	} else {
		const runChecks = (payload, checks$1, ctx) => {
			let isAborted = aborted(payload);
			let asyncResult;
			for (const ch of checks$1) {
				if (ch._zod.def.when) {
					if (!ch._zod.def.when(payload)) continue;
				} else if (isAborted) continue;
				const currLen = payload.issues.length;
				const _ = ch._zod.check(payload);
				if (_ instanceof Promise && ctx?.async === false) throw new $ZodAsyncError();
				if (asyncResult || _ instanceof Promise) asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
					await _;
					if (payload.issues.length === currLen) return;
					if (!isAborted) isAborted = aborted(payload, currLen);
				});
				else {
					if (payload.issues.length === currLen) continue;
					if (!isAborted) isAborted = aborted(payload, currLen);
				}
			}
			if (asyncResult) return asyncResult.then(() => {
				return payload;
			});
			return payload;
		};
		const handleCanaryResult = (canary, payload, ctx) => {
			if (aborted(canary)) {
				canary.aborted = true;
				return canary;
			}
			const checkResult = runChecks(payload, checks, ctx);
			if (checkResult instanceof Promise) {
				if (ctx.async === false) throw new $ZodAsyncError();
				return checkResult.then((checkResult$1) => inst._zod.parse(checkResult$1, ctx));
			}
			return inst._zod.parse(checkResult, ctx);
		};
		inst._zod.run = (payload, ctx) => {
			if (ctx.skipChecks) return inst._zod.parse(payload, ctx);
			if (ctx.direction === "backward") {
				const canary = inst._zod.parse({
					value: payload.value,
					issues: []
				}, {
					...ctx,
					skipChecks: true
				});
				if (canary instanceof Promise) return canary.then((canary$1) => {
					return handleCanaryResult(canary$1, payload, ctx);
				});
				return handleCanaryResult(canary, payload, ctx);
			}
			const result = inst._zod.parse(payload, ctx);
			if (result instanceof Promise) {
				if (ctx.async === false) throw new $ZodAsyncError();
				return result.then((result$1) => runChecks(result$1, checks, ctx));
			}
			return runChecks(result, checks, ctx);
		};
	}
	inst["~standard"] = {
		validate: (value) => {
			try {
				const r$1 = safeParse$1(inst, value);
				return r$1.success ? { value: r$1.data } : { issues: r$1.error?.issues };
			} catch (_) {
				return safeParseAsync$1(inst, value).then((r$1) => r$1.success ? { value: r$1.data } : { issues: r$1.error?.issues });
			}
		},
		vendor: "zod",
		version: 1
	};
});
const $ZodString = /* @__PURE__ */ $constructor("$ZodString", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.pattern = [...inst?._zod.bag?.patterns ?? []].pop() ?? string$1(inst._zod.bag);
	inst._zod.parse = (payload, _) => {
		if (def.coerce) try {
			payload.value = String(payload.value);
		} catch (_$1) {}
		if (typeof payload.value === "string") return payload;
		payload.issues.push({
			expected: "string",
			code: "invalid_type",
			input: payload.value,
			inst
		});
		return payload;
	};
});
const $ZodStringFormat = /* @__PURE__ */ $constructor("$ZodStringFormat", (inst, def) => {
	$ZodCheckStringFormat.init(inst, def);
	$ZodString.init(inst, def);
});
const $ZodGUID = /* @__PURE__ */ $constructor("$ZodGUID", (inst, def) => {
	def.pattern ?? (def.pattern = guid);
	$ZodStringFormat.init(inst, def);
});
const $ZodUUID = /* @__PURE__ */ $constructor("$ZodUUID", (inst, def) => {
	if (def.version) {
		const v = {
			v1: 1,
			v2: 2,
			v3: 3,
			v4: 4,
			v5: 5,
			v6: 6,
			v7: 7,
			v8: 8
		}[def.version];
		if (v === void 0) throw new Error(`Invalid UUID version: "${def.version}"`);
		def.pattern ?? (def.pattern = uuid(v));
	} else def.pattern ?? (def.pattern = uuid());
	$ZodStringFormat.init(inst, def);
});
const $ZodEmail = /* @__PURE__ */ $constructor("$ZodEmail", (inst, def) => {
	def.pattern ?? (def.pattern = email);
	$ZodStringFormat.init(inst, def);
});
const $ZodURL = /* @__PURE__ */ $constructor("$ZodURL", (inst, def) => {
	$ZodStringFormat.init(inst, def);
	inst._zod.check = (payload) => {
		try {
			const trimmed = payload.value.trim();
			const url = new URL(trimmed);
			if (def.hostname) {
				def.hostname.lastIndex = 0;
				if (!def.hostname.test(url.hostname)) payload.issues.push({
					code: "invalid_format",
					format: "url",
					note: "Invalid hostname",
					pattern: def.hostname.source,
					input: payload.value,
					inst,
					continue: !def.abort
				});
			}
			if (def.protocol) {
				def.protocol.lastIndex = 0;
				if (!def.protocol.test(url.protocol.endsWith(":") ? url.protocol.slice(0, -1) : url.protocol)) payload.issues.push({
					code: "invalid_format",
					format: "url",
					note: "Invalid protocol",
					pattern: def.protocol.source,
					input: payload.value,
					inst,
					continue: !def.abort
				});
			}
			if (def.normalize) payload.value = url.href;
			else payload.value = trimmed;
			return;
		} catch (_) {
			payload.issues.push({
				code: "invalid_format",
				format: "url",
				input: payload.value,
				inst,
				continue: !def.abort
			});
		}
	};
});
const $ZodEmoji = /* @__PURE__ */ $constructor("$ZodEmoji", (inst, def) => {
	def.pattern ?? (def.pattern = emoji());
	$ZodStringFormat.init(inst, def);
});
const $ZodNanoID = /* @__PURE__ */ $constructor("$ZodNanoID", (inst, def) => {
	def.pattern ?? (def.pattern = nanoid);
	$ZodStringFormat.init(inst, def);
});
const $ZodCUID = /* @__PURE__ */ $constructor("$ZodCUID", (inst, def) => {
	def.pattern ?? (def.pattern = cuid);
	$ZodStringFormat.init(inst, def);
});
const $ZodCUID2 = /* @__PURE__ */ $constructor("$ZodCUID2", (inst, def) => {
	def.pattern ?? (def.pattern = cuid2);
	$ZodStringFormat.init(inst, def);
});
const $ZodULID = /* @__PURE__ */ $constructor("$ZodULID", (inst, def) => {
	def.pattern ?? (def.pattern = ulid);
	$ZodStringFormat.init(inst, def);
});
const $ZodXID = /* @__PURE__ */ $constructor("$ZodXID", (inst, def) => {
	def.pattern ?? (def.pattern = xid);
	$ZodStringFormat.init(inst, def);
});
const $ZodKSUID = /* @__PURE__ */ $constructor("$ZodKSUID", (inst, def) => {
	def.pattern ?? (def.pattern = ksuid);
	$ZodStringFormat.init(inst, def);
});
const $ZodISODateTime = /* @__PURE__ */ $constructor("$ZodISODateTime", (inst, def) => {
	def.pattern ?? (def.pattern = datetime$1(def));
	$ZodStringFormat.init(inst, def);
});
const $ZodISODate = /* @__PURE__ */ $constructor("$ZodISODate", (inst, def) => {
	def.pattern ?? (def.pattern = date$3);
	$ZodStringFormat.init(inst, def);
});
const $ZodISOTime = /* @__PURE__ */ $constructor("$ZodISOTime", (inst, def) => {
	def.pattern ?? (def.pattern = time$2(def));
	$ZodStringFormat.init(inst, def);
});
const $ZodISODuration = /* @__PURE__ */ $constructor("$ZodISODuration", (inst, def) => {
	def.pattern ?? (def.pattern = duration$1);
	$ZodStringFormat.init(inst, def);
});
const $ZodIPv4 = /* @__PURE__ */ $constructor("$ZodIPv4", (inst, def) => {
	def.pattern ?? (def.pattern = ipv4);
	$ZodStringFormat.init(inst, def);
	inst._zod.bag.format = `ipv4`;
});
const $ZodIPv6 = /* @__PURE__ */ $constructor("$ZodIPv6", (inst, def) => {
	def.pattern ?? (def.pattern = ipv6);
	$ZodStringFormat.init(inst, def);
	inst._zod.bag.format = `ipv6`;
	inst._zod.check = (payload) => {
		try {
			new URL(`http://[${payload.value}]`);
		} catch {
			payload.issues.push({
				code: "invalid_format",
				format: "ipv6",
				input: payload.value,
				inst,
				continue: !def.abort
			});
		}
	};
});
const $ZodCIDRv4 = /* @__PURE__ */ $constructor("$ZodCIDRv4", (inst, def) => {
	def.pattern ?? (def.pattern = cidrv4);
	$ZodStringFormat.init(inst, def);
});
const $ZodCIDRv6 = /* @__PURE__ */ $constructor("$ZodCIDRv6", (inst, def) => {
	def.pattern ?? (def.pattern = cidrv6);
	$ZodStringFormat.init(inst, def);
	inst._zod.check = (payload) => {
		const parts = payload.value.split("/");
		try {
			if (parts.length !== 2) throw new Error();
			const [address, prefix$2] = parts;
			if (!prefix$2) throw new Error();
			const prefixNum = Number(prefix$2);
			if (`${prefixNum}` !== prefix$2) throw new Error();
			if (prefixNum < 0 || prefixNum > 128) throw new Error();
			new URL(`http://[${address}]`);
		} catch {
			payload.issues.push({
				code: "invalid_format",
				format: "cidrv6",
				input: payload.value,
				inst,
				continue: !def.abort
			});
		}
	};
});
function isValidBase64(data) {
	if (data === "") return true;
	if (data.length % 4 !== 0) return false;
	try {
		atob(data);
		return true;
	} catch {
		return false;
	}
}
const $ZodBase64 = /* @__PURE__ */ $constructor("$ZodBase64", (inst, def) => {
	def.pattern ?? (def.pattern = base64);
	$ZodStringFormat.init(inst, def);
	inst._zod.bag.contentEncoding = "base64";
	inst._zod.check = (payload) => {
		if (isValidBase64(payload.value)) return;
		payload.issues.push({
			code: "invalid_format",
			format: "base64",
			input: payload.value,
			inst,
			continue: !def.abort
		});
	};
});
function isValidBase64URL(data) {
	if (!base64url.test(data)) return false;
	const base64$1 = data.replace(/[-_]/g, (c$1) => c$1 === "-" ? "+" : "/");
	return isValidBase64(base64$1.padEnd(Math.ceil(base64$1.length / 4) * 4, "="));
}
const $ZodBase64URL = /* @__PURE__ */ $constructor("$ZodBase64URL", (inst, def) => {
	def.pattern ?? (def.pattern = base64url);
	$ZodStringFormat.init(inst, def);
	inst._zod.bag.contentEncoding = "base64url";
	inst._zod.check = (payload) => {
		if (isValidBase64URL(payload.value)) return;
		payload.issues.push({
			code: "invalid_format",
			format: "base64url",
			input: payload.value,
			inst,
			continue: !def.abort
		});
	};
});
const $ZodE164 = /* @__PURE__ */ $constructor("$ZodE164", (inst, def) => {
	def.pattern ?? (def.pattern = e164);
	$ZodStringFormat.init(inst, def);
});
function isValidJWT(token, algorithm = null) {
	try {
		const tokensParts = token.split(".");
		if (tokensParts.length !== 3) return false;
		const [header] = tokensParts;
		if (!header) return false;
		const parsedHeader = JSON.parse(atob(header));
		if ("typ" in parsedHeader && parsedHeader?.typ !== "JWT") return false;
		if (!parsedHeader.alg) return false;
		if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm)) return false;
		return true;
	} catch {
		return false;
	}
}
const $ZodJWT = /* @__PURE__ */ $constructor("$ZodJWT", (inst, def) => {
	$ZodStringFormat.init(inst, def);
	inst._zod.check = (payload) => {
		if (isValidJWT(payload.value, def.alg)) return;
		payload.issues.push({
			code: "invalid_format",
			format: "jwt",
			input: payload.value,
			inst,
			continue: !def.abort
		});
	};
});
const $ZodNumber = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.pattern = inst._zod.bag.pattern ?? number$4;
	inst._zod.parse = (payload, _ctx) => {
		if (def.coerce) try {
			payload.value = Number(payload.value);
		} catch (_) {}
		const input = payload.value;
		if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) return payload;
		const received = typeof input === "number" ? Number.isNaN(input) ? "NaN" : !Number.isFinite(input) ? "Infinity" : void 0 : void 0;
		payload.issues.push({
			expected: "number",
			code: "invalid_type",
			input,
			inst,
			...received ? { received } : {}
		});
		return payload;
	};
});
const $ZodNumberFormat = /* @__PURE__ */ $constructor("$ZodNumberFormat", (inst, def) => {
	$ZodCheckNumberFormat.init(inst, def);
	$ZodNumber.init(inst, def);
});
const $ZodUnknown = /* @__PURE__ */ $constructor("$ZodUnknown", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.parse = (payload) => payload;
});
const $ZodNever = /* @__PURE__ */ $constructor("$ZodNever", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.parse = (payload, _ctx) => {
		payload.issues.push({
			expected: "never",
			code: "invalid_type",
			input: payload.value,
			inst
		});
		return payload;
	};
});
const $ZodDate = /* @__PURE__ */ $constructor("$ZodDate", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.parse = (payload, _ctx) => {
		if (def.coerce) try {
			payload.value = new Date(payload.value);
		} catch (_err) {}
		const input = payload.value;
		const isDate = input instanceof Date;
		if (isDate && !Number.isNaN(input.getTime())) return payload;
		payload.issues.push({
			expected: "date",
			code: "invalid_type",
			input,
			...isDate ? { received: "Invalid Date" } : {},
			inst
		});
		return payload;
	};
});
function handleArrayResult(result, final, index) {
	if (result.issues.length) final.issues.push(...prefixIssues(index, result.issues));
	final.value[index] = result.value;
}
const $ZodArray = /* @__PURE__ */ $constructor("$ZodArray", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.parse = (payload, ctx) => {
		const input = payload.value;
		if (!Array.isArray(input)) {
			payload.issues.push({
				expected: "array",
				code: "invalid_type",
				input,
				inst
			});
			return payload;
		}
		payload.value = Array(input.length);
		const proms = [];
		for (let i$2 = 0; i$2 < input.length; i$2++) {
			const item = input[i$2];
			const result = def.element._zod.run({
				value: item,
				issues: []
			}, ctx);
			if (result instanceof Promise) proms.push(result.then((result$1) => handleArrayResult(result$1, payload, i$2)));
			else handleArrayResult(result, payload, i$2);
		}
		if (proms.length) return Promise.all(proms).then(() => payload);
		return payload;
	};
});
function handlePropertyResult(result, final, key, input) {
	if (result.issues.length) final.issues.push(...prefixIssues(key, result.issues));
	if (result.value === void 0) {
		if (key in input) final.value[key] = void 0;
	} else final.value[key] = result.value;
}
function normalizeDef(def) {
	const keys$6 = Object.keys(def.shape);
	for (const k$1 of keys$6) if (!def.shape?.[k$1]?._zod?.traits?.has("$ZodType")) throw new Error(`Invalid element at key "${k$1}": expected a Zod schema`);
	const okeys = optionalKeys(def.shape);
	return {
		...def,
		keys: keys$6,
		keySet: new Set(keys$6),
		numKeys: keys$6.length,
		optionalKeys: new Set(okeys)
	};
}
function handleCatchall(proms, input, payload, ctx, def, inst) {
	const unrecognized = [];
	const keySet = def.keySet;
	const _catchall = def.catchall._zod;
	const t$1 = _catchall.def.type;
	for (const key in input) {
		if (keySet.has(key)) continue;
		if (t$1 === "never") {
			unrecognized.push(key);
			continue;
		}
		const r$1 = _catchall.run({
			value: input[key],
			issues: []
		}, ctx);
		if (r$1 instanceof Promise) proms.push(r$1.then((r$2) => handlePropertyResult(r$2, payload, key, input)));
		else handlePropertyResult(r$1, payload, key, input);
	}
	if (unrecognized.length) payload.issues.push({
		code: "unrecognized_keys",
		keys: unrecognized,
		input,
		inst
	});
	if (!proms.length) return payload;
	return Promise.all(proms).then(() => {
		return payload;
	});
}
const $ZodObject = /* @__PURE__ */ $constructor("$ZodObject", (inst, def) => {
	$ZodType.init(inst, def);
	if (!Object.getOwnPropertyDescriptor(def, "shape")?.get) {
		const sh = def.shape;
		Object.defineProperty(def, "shape", { get: () => {
			const newSh = { ...sh };
			Object.defineProperty(def, "shape", { value: newSh });
			return newSh;
		} });
	}
	const _normalized = cached(() => normalizeDef(def));
	defineLazy(inst._zod, "propValues", () => {
		const shape = def.shape;
		const propValues = {};
		for (const key in shape) {
			const field = shape[key]._zod;
			if (field.values) {
				propValues[key] ?? (propValues[key] = /* @__PURE__ */ new Set());
				for (const v of field.values) propValues[key].add(v);
			}
		}
		return propValues;
	});
	const isObject$14 = isObject$12;
	const catchall = def.catchall;
	let value;
	inst._zod.parse = (payload, ctx) => {
		value ?? (value = _normalized.value);
		const input = payload.value;
		if (!isObject$14(input)) {
			payload.issues.push({
				expected: "object",
				code: "invalid_type",
				input,
				inst
			});
			return payload;
		}
		payload.value = {};
		const proms = [];
		const shape = value.shape;
		for (const key of value.keys) {
			const r$1 = shape[key]._zod.run({
				value: input[key],
				issues: []
			}, ctx);
			if (r$1 instanceof Promise) proms.push(r$1.then((r$2) => handlePropertyResult(r$2, payload, key, input)));
			else handlePropertyResult(r$1, payload, key, input);
		}
		if (!catchall) return proms.length ? Promise.all(proms).then(() => payload) : payload;
		return handleCatchall(proms, input, payload, ctx, _normalized.value, inst);
	};
});
const $ZodObjectJIT = /* @__PURE__ */ $constructor("$ZodObjectJIT", (inst, def) => {
	$ZodObject.init(inst, def);
	const superParse = inst._zod.parse;
	const _normalized = cached(() => normalizeDef(def));
	const generateFastpass = (shape) => {
		const doc = new Doc([
			"shape",
			"payload",
			"ctx"
		]);
		const normalized = _normalized.value;
		const parseStr = (key) => {
			const k$1 = esc(key);
			return `shape[${k$1}]._zod.run({ value: input[${k$1}], issues: [] }, ctx)`;
		};
		doc.write(`const input = payload.value;`);
		const ids = Object.create(null);
		let counter = 0;
		for (const key of normalized.keys) ids[key] = `key_${counter++}`;
		doc.write(`const newResult = {};`);
		for (const key of normalized.keys) {
			const id = ids[key];
			const k$1 = esc(key);
			doc.write(`const ${id} = ${parseStr(key)};`);
			doc.write(`
        if (${id}.issues.length) {
          payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${k$1}, ...iss.path] : [${k$1}]
          })));
        }
        
        
        if (${id}.value === undefined) {
          if (${k$1} in input) {
            newResult[${k$1}] = undefined;
          }
        } else {
          newResult[${k$1}] = ${id}.value;
        }
        
      `);
		}
		doc.write(`payload.value = newResult;`);
		doc.write(`return payload;`);
		const fn = doc.compile();
		return (payload, ctx) => fn(shape, payload, ctx);
	};
	let fastpass;
	const isObject$14 = isObject$12;
	const jit = !globalConfig.jitless;
	const fastEnabled = jit && allowsEval.value;
	const catchall = def.catchall;
	let value;
	inst._zod.parse = (payload, ctx) => {
		value ?? (value = _normalized.value);
		const input = payload.value;
		if (!isObject$14(input)) {
			payload.issues.push({
				expected: "object",
				code: "invalid_type",
				input,
				inst
			});
			return payload;
		}
		if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {
			if (!fastpass) fastpass = generateFastpass(def.shape);
			payload = fastpass(payload, ctx);
			if (!catchall) return payload;
			return handleCatchall([], input, payload, ctx, value, inst);
		}
		return superParse(payload, ctx);
	};
});
function handleUnionResults(results, final, inst, ctx) {
	for (const result of results) if (result.issues.length === 0) {
		final.value = result.value;
		return final;
	}
	const nonaborted = results.filter((r$1) => !aborted(r$1));
	if (nonaborted.length === 1) {
		final.value = nonaborted[0].value;
		return nonaborted[0];
	}
	final.issues.push({
		code: "invalid_union",
		input: final.value,
		inst,
		errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
	});
	return final;
}
const $ZodUnion = /* @__PURE__ */ $constructor("$ZodUnion", (inst, def) => {
	$ZodType.init(inst, def);
	defineLazy(inst._zod, "optin", () => def.options.some((o$1) => o$1._zod.optin === "optional") ? "optional" : void 0);
	defineLazy(inst._zod, "optout", () => def.options.some((o$1) => o$1._zod.optout === "optional") ? "optional" : void 0);
	defineLazy(inst._zod, "values", () => {
		if (def.options.every((o$1) => o$1._zod.values)) return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
	});
	defineLazy(inst._zod, "pattern", () => {
		if (def.options.every((o$1) => o$1._zod.pattern)) {
			const patterns = def.options.map((o$1) => o$1._zod.pattern);
			return /* @__PURE__ */ new RegExp(`^(${patterns.map((p) => cleanRegex(p.source)).join("|")})$`);
		}
	});
	const single = def.options.length === 1;
	const first = def.options[0]._zod.run;
	inst._zod.parse = (payload, ctx) => {
		if (single) return first(payload, ctx);
		let async = false;
		const results = [];
		for (const option of def.options) {
			const result = option._zod.run({
				value: payload.value,
				issues: []
			}, ctx);
			if (result instanceof Promise) {
				results.push(result);
				async = true;
			} else {
				if (result.issues.length === 0) return result;
				results.push(result);
			}
		}
		if (!async) return handleUnionResults(results, payload, inst, ctx);
		return Promise.all(results).then((results$1) => {
			return handleUnionResults(results$1, payload, inst, ctx);
		});
	};
});
const $ZodIntersection = /* @__PURE__ */ $constructor("$ZodIntersection", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.parse = (payload, ctx) => {
		const input = payload.value;
		const left = def.left._zod.run({
			value: input,
			issues: []
		}, ctx);
		const right = def.right._zod.run({
			value: input,
			issues: []
		}, ctx);
		if (left instanceof Promise || right instanceof Promise) return Promise.all([left, right]).then(([left$1, right$1]) => {
			return handleIntersectionResults(payload, left$1, right$1);
		});
		return handleIntersectionResults(payload, left, right);
	};
});
function mergeValues(a$2, b) {
	if (a$2 === b) return {
		valid: true,
		data: a$2
	};
	if (a$2 instanceof Date && b instanceof Date && +a$2 === +b) return {
		valid: true,
		data: a$2
	};
	if (isPlainObject$2(a$2) && isPlainObject$2(b)) {
		const bKeys = Object.keys(b);
		const sharedKeys = Object.keys(a$2).filter((key) => bKeys.indexOf(key) !== -1);
		const newObj = {
			...a$2,
			...b
		};
		for (const key of sharedKeys) {
			const sharedValue = mergeValues(a$2[key], b[key]);
			if (!sharedValue.valid) return {
				valid: false,
				mergeErrorPath: [key, ...sharedValue.mergeErrorPath]
			};
			newObj[key] = sharedValue.data;
		}
		return {
			valid: true,
			data: newObj
		};
	}
	if (Array.isArray(a$2) && Array.isArray(b)) {
		if (a$2.length !== b.length) return {
			valid: false,
			mergeErrorPath: []
		};
		const newArray = [];
		for (let index = 0; index < a$2.length; index++) {
			const itemA = a$2[index];
			const itemB = b[index];
			const sharedValue = mergeValues(itemA, itemB);
			if (!sharedValue.valid) return {
				valid: false,
				mergeErrorPath: [index, ...sharedValue.mergeErrorPath]
			};
			newArray.push(sharedValue.data);
		}
		return {
			valid: true,
			data: newArray
		};
	}
	return {
		valid: false,
		mergeErrorPath: []
	};
}
function handleIntersectionResults(result, left, right) {
	if (left.issues.length) result.issues.push(...left.issues);
	if (right.issues.length) result.issues.push(...right.issues);
	if (aborted(result)) return result;
	const merged = mergeValues(left.value, right.value);
	if (!merged.valid) throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(merged.mergeErrorPath)}`);
	result.value = merged.data;
	return result;
}
const $ZodEnum = /* @__PURE__ */ $constructor("$ZodEnum", (inst, def) => {
	$ZodType.init(inst, def);
	const values = getEnumValues(def.entries);
	const valuesSet = new Set(values);
	inst._zod.values = valuesSet;
	inst._zod.pattern = /* @__PURE__ */ new RegExp(`^(${values.filter((k$1) => propertyKeyTypes.has(typeof k$1)).map((o$1) => typeof o$1 === "string" ? escapeRegex(o$1) : o$1.toString()).join("|")})$`);
	inst._zod.parse = (payload, _ctx) => {
		const input = payload.value;
		if (valuesSet.has(input)) return payload;
		payload.issues.push({
			code: "invalid_value",
			values,
			input,
			inst
		});
		return payload;
	};
});
const $ZodTransform = /* @__PURE__ */ $constructor("$ZodTransform", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.parse = (payload, ctx) => {
		if (ctx.direction === "backward") throw new $ZodEncodeError(inst.constructor.name);
		const _out = def.transform(payload.value, payload);
		if (ctx.async) return (_out instanceof Promise ? _out : Promise.resolve(_out)).then((output) => {
			payload.value = output;
			return payload;
		});
		if (_out instanceof Promise) throw new $ZodAsyncError();
		payload.value = _out;
		return payload;
	};
});
function handleOptionalResult(result, input) {
	if (result.issues.length && input === void 0) return {
		issues: [],
		value: void 0
	};
	return result;
}
const $ZodOptional = /* @__PURE__ */ $constructor("$ZodOptional", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.optin = "optional";
	inst._zod.optout = "optional";
	defineLazy(inst._zod, "values", () => {
		return def.innerType._zod.values ? new Set([...def.innerType._zod.values, void 0]) : void 0;
	});
	defineLazy(inst._zod, "pattern", () => {
		const pattern = def.innerType._zod.pattern;
		return pattern ? /* @__PURE__ */ new RegExp(`^(${cleanRegex(pattern.source)})?$`) : void 0;
	});
	inst._zod.parse = (payload, ctx) => {
		if (def.innerType._zod.optin === "optional") {
			const result = def.innerType._zod.run(payload, ctx);
			if (result instanceof Promise) return result.then((r$1) => handleOptionalResult(r$1, payload.value));
			return handleOptionalResult(result, payload.value);
		}
		if (payload.value === void 0) return payload;
		return def.innerType._zod.run(payload, ctx);
	};
});
const $ZodNullable = /* @__PURE__ */ $constructor("$ZodNullable", (inst, def) => {
	$ZodType.init(inst, def);
	defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
	defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
	defineLazy(inst._zod, "pattern", () => {
		const pattern = def.innerType._zod.pattern;
		return pattern ? /* @__PURE__ */ new RegExp(`^(${cleanRegex(pattern.source)}|null)$`) : void 0;
	});
	defineLazy(inst._zod, "values", () => {
		return def.innerType._zod.values ? new Set([...def.innerType._zod.values, null]) : void 0;
	});
	inst._zod.parse = (payload, ctx) => {
		if (payload.value === null) return payload;
		return def.innerType._zod.run(payload, ctx);
	};
});
const $ZodDefault = /* @__PURE__ */ $constructor("$ZodDefault", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.optin = "optional";
	defineLazy(inst._zod, "values", () => def.innerType._zod.values);
	inst._zod.parse = (payload, ctx) => {
		if (ctx.direction === "backward") return def.innerType._zod.run(payload, ctx);
		if (payload.value === void 0) {
			payload.value = def.defaultValue;
			return payload;
		}
		const result = def.innerType._zod.run(payload, ctx);
		if (result instanceof Promise) return result.then((result$1) => handleDefaultResult(result$1, def));
		return handleDefaultResult(result, def);
	};
});
function handleDefaultResult(payload, def) {
	if (payload.value === void 0) payload.value = def.defaultValue;
	return payload;
}
const $ZodPrefault = /* @__PURE__ */ $constructor("$ZodPrefault", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.optin = "optional";
	defineLazy(inst._zod, "values", () => def.innerType._zod.values);
	inst._zod.parse = (payload, ctx) => {
		if (ctx.direction === "backward") return def.innerType._zod.run(payload, ctx);
		if (payload.value === void 0) payload.value = def.defaultValue;
		return def.innerType._zod.run(payload, ctx);
	};
});
const $ZodNonOptional = /* @__PURE__ */ $constructor("$ZodNonOptional", (inst, def) => {
	$ZodType.init(inst, def);
	defineLazy(inst._zod, "values", () => {
		const v = def.innerType._zod.values;
		return v ? new Set([...v].filter((x$1) => x$1 !== void 0)) : void 0;
	});
	inst._zod.parse = (payload, ctx) => {
		const result = def.innerType._zod.run(payload, ctx);
		if (result instanceof Promise) return result.then((result$1) => handleNonOptionalResult(result$1, inst));
		return handleNonOptionalResult(result, inst);
	};
});
function handleNonOptionalResult(payload, inst) {
	if (!payload.issues.length && payload.value === void 0) payload.issues.push({
		code: "invalid_type",
		expected: "nonoptional",
		input: payload.value,
		inst
	});
	return payload;
}
const $ZodCatch = /* @__PURE__ */ $constructor("$ZodCatch", (inst, def) => {
	$ZodType.init(inst, def);
	defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
	defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
	defineLazy(inst._zod, "values", () => def.innerType._zod.values);
	inst._zod.parse = (payload, ctx) => {
		if (ctx.direction === "backward") return def.innerType._zod.run(payload, ctx);
		const result = def.innerType._zod.run(payload, ctx);
		if (result instanceof Promise) return result.then((result$1) => {
			payload.value = result$1.value;
			if (result$1.issues.length) {
				payload.value = def.catchValue({
					...payload,
					error: { issues: result$1.issues.map((iss) => finalizeIssue(iss, ctx, config())) },
					input: payload.value
				});
				payload.issues = [];
			}
			return payload;
		});
		payload.value = result.value;
		if (result.issues.length) {
			payload.value = def.catchValue({
				...payload,
				error: { issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config())) },
				input: payload.value
			});
			payload.issues = [];
		}
		return payload;
	};
});
const $ZodPipe = /* @__PURE__ */ $constructor("$ZodPipe", (inst, def) => {
	$ZodType.init(inst, def);
	defineLazy(inst._zod, "values", () => def.in._zod.values);
	defineLazy(inst._zod, "optin", () => def.in._zod.optin);
	defineLazy(inst._zod, "optout", () => def.out._zod.optout);
	defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
	inst._zod.parse = (payload, ctx) => {
		if (ctx.direction === "backward") {
			const right = def.out._zod.run(payload, ctx);
			if (right instanceof Promise) return right.then((right$1) => handlePipeResult(right$1, def.in, ctx));
			return handlePipeResult(right, def.in, ctx);
		}
		const left = def.in._zod.run(payload, ctx);
		if (left instanceof Promise) return left.then((left$1) => handlePipeResult(left$1, def.out, ctx));
		return handlePipeResult(left, def.out, ctx);
	};
});
function handlePipeResult(left, next, ctx) {
	if (left.issues.length) {
		left.aborted = true;
		return left;
	}
	return next._zod.run({
		value: left.value,
		issues: left.issues
	}, ctx);
}
const $ZodReadonly = /* @__PURE__ */ $constructor("$ZodReadonly", (inst, def) => {
	$ZodType.init(inst, def);
	defineLazy(inst._zod, "propValues", () => def.innerType._zod.propValues);
	defineLazy(inst._zod, "values", () => def.innerType._zod.values);
	defineLazy(inst._zod, "optin", () => def.innerType?._zod?.optin);
	defineLazy(inst._zod, "optout", () => def.innerType?._zod?.optout);
	inst._zod.parse = (payload, ctx) => {
		if (ctx.direction === "backward") return def.innerType._zod.run(payload, ctx);
		const result = def.innerType._zod.run(payload, ctx);
		if (result instanceof Promise) return result.then(handleReadonlyResult);
		return handleReadonlyResult(result);
	};
});
function handleReadonlyResult(payload) {
	payload.value = Object.freeze(payload.value);
	return payload;
}
const $ZodCustom = /* @__PURE__ */ $constructor("$ZodCustom", (inst, def) => {
	$ZodCheck.init(inst, def);
	$ZodType.init(inst, def);
	inst._zod.parse = (payload, _) => {
		return payload;
	};
	inst._zod.check = (payload) => {
		const input = payload.value;
		const r$1 = def.fn(input);
		if (r$1 instanceof Promise) return r$1.then((r$2) => handleRefineResult(r$2, payload, input, inst));
		handleRefineResult(r$1, payload, input, inst);
	};
});
function handleRefineResult(result, payload, input, inst) {
	if (!result) {
		const _iss = {
			code: "custom",
			input,
			inst,
			path: [...inst._zod.def.path ?? []],
			continue: !inst._zod.def.abort
		};
		if (inst._zod.def.params) _iss.params = inst._zod.def.params;
		payload.issues.push(issue(_iss));
	}
}
var _a;
var $ZodRegistry = class {
	constructor() {
		this._map = /* @__PURE__ */ new WeakMap();
		this._idmap = /* @__PURE__ */ new Map();
	}
	add(schema, ..._meta) {
		const meta$2 = _meta[0];
		this._map.set(schema, meta$2);
		if (meta$2 && typeof meta$2 === "object" && "id" in meta$2) {
			if (this._idmap.has(meta$2.id)) throw new Error(`ID ${meta$2.id} already exists in the registry`);
			this._idmap.set(meta$2.id, schema);
		}
		return this;
	}
	clear() {
		this._map = /* @__PURE__ */ new WeakMap();
		this._idmap = /* @__PURE__ */ new Map();
		return this;
	}
	remove(schema) {
		const meta$2 = this._map.get(schema);
		if (meta$2 && typeof meta$2 === "object" && "id" in meta$2) this._idmap.delete(meta$2.id);
		this._map.delete(schema);
		return this;
	}
	get(schema) {
		const p = schema._zod.parent;
		if (p) {
			const pm = { ...this.get(p) ?? {} };
			delete pm.id;
			const f = {
				...pm,
				...this._map.get(schema)
			};
			return Object.keys(f).length ? f : void 0;
		}
		return this._map.get(schema);
	}
	has(schema) {
		return this._map.has(schema);
	}
};
function registry() {
	return new $ZodRegistry();
}
(_a = globalThis).__zod_globalRegistry ?? (_a.__zod_globalRegistry = registry());
const globalRegistry = globalThis.__zod_globalRegistry;
function _string(Class, params) {
	return new Class({
		type: "string",
		...normalizeParams(params)
	});
}
function _email(Class, params) {
	return new Class({
		type: "string",
		format: "email",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
function _guid(Class, params) {
	return new Class({
		type: "string",
		format: "guid",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
function _uuid(Class, params) {
	return new Class({
		type: "string",
		format: "uuid",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
function _uuidv4(Class, params) {
	return new Class({
		type: "string",
		format: "uuid",
		check: "string_format",
		abort: false,
		version: "v4",
		...normalizeParams(params)
	});
}
function _uuidv6(Class, params) {
	return new Class({
		type: "string",
		format: "uuid",
		check: "string_format",
		abort: false,
		version: "v6",
		...normalizeParams(params)
	});
}
function _uuidv7(Class, params) {
	return new Class({
		type: "string",
		format: "uuid",
		check: "string_format",
		abort: false,
		version: "v7",
		...normalizeParams(params)
	});
}
function _url(Class, params) {
	return new Class({
		type: "string",
		format: "url",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
function _emoji(Class, params) {
	return new Class({
		type: "string",
		format: "emoji",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
function _nanoid(Class, params) {
	return new Class({
		type: "string",
		format: "nanoid",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
function _cuid(Class, params) {
	return new Class({
		type: "string",
		format: "cuid",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
function _cuid2(Class, params) {
	return new Class({
		type: "string",
		format: "cuid2",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
function _ulid(Class, params) {
	return new Class({
		type: "string",
		format: "ulid",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
function _xid(Class, params) {
	return new Class({
		type: "string",
		format: "xid",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
function _ksuid(Class, params) {
	return new Class({
		type: "string",
		format: "ksuid",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
function _ipv4(Class, params) {
	return new Class({
		type: "string",
		format: "ipv4",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
function _ipv6(Class, params) {
	return new Class({
		type: "string",
		format: "ipv6",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
function _cidrv4(Class, params) {
	return new Class({
		type: "string",
		format: "cidrv4",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
function _cidrv6(Class, params) {
	return new Class({
		type: "string",
		format: "cidrv6",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
function _base64(Class, params) {
	return new Class({
		type: "string",
		format: "base64",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
function _base64url(Class, params) {
	return new Class({
		type: "string",
		format: "base64url",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
function _e164(Class, params) {
	return new Class({
		type: "string",
		format: "e164",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
function _jwt(Class, params) {
	return new Class({
		type: "string",
		format: "jwt",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
function _isoDateTime(Class, params) {
	return new Class({
		type: "string",
		format: "datetime",
		check: "string_format",
		offset: false,
		local: false,
		precision: null,
		...normalizeParams(params)
	});
}
function _isoDate(Class, params) {
	return new Class({
		type: "string",
		format: "date",
		check: "string_format",
		...normalizeParams(params)
	});
}
function _isoTime(Class, params) {
	return new Class({
		type: "string",
		format: "time",
		check: "string_format",
		precision: null,
		...normalizeParams(params)
	});
}
function _isoDuration(Class, params) {
	return new Class({
		type: "string",
		format: "duration",
		check: "string_format",
		...normalizeParams(params)
	});
}
function _coercedNumber(Class, params) {
	return new Class({
		type: "number",
		coerce: true,
		checks: [],
		...normalizeParams(params)
	});
}
function _int(Class, params) {
	return new Class({
		type: "number",
		check: "number_format",
		abort: false,
		format: "safeint",
		...normalizeParams(params)
	});
}
function _unknown(Class) {
	return new Class({ type: "unknown" });
}
function _never(Class, params) {
	return new Class({
		type: "never",
		...normalizeParams(params)
	});
}
function _date(Class, params) {
	return new Class({
		type: "date",
		...normalizeParams(params)
	});
}
function _lt(value, params) {
	return new $ZodCheckLessThan({
		check: "less_than",
		...normalizeParams(params),
		value,
		inclusive: false
	});
}
function _lte(value, params) {
	return new $ZodCheckLessThan({
		check: "less_than",
		...normalizeParams(params),
		value,
		inclusive: true
	});
}
function _gt(value, params) {
	return new $ZodCheckGreaterThan({
		check: "greater_than",
		...normalizeParams(params),
		value,
		inclusive: false
	});
}
function _gte(value, params) {
	return new $ZodCheckGreaterThan({
		check: "greater_than",
		...normalizeParams(params),
		value,
		inclusive: true
	});
}
function _multipleOf(value, params) {
	return new $ZodCheckMultipleOf({
		check: "multiple_of",
		...normalizeParams(params),
		value
	});
}
function _maxLength(maximum, params) {
	return new $ZodCheckMaxLength({
		check: "max_length",
		...normalizeParams(params),
		maximum
	});
}
function _minLength(minimum, params) {
	return new $ZodCheckMinLength({
		check: "min_length",
		...normalizeParams(params),
		minimum
	});
}
function _length(length, params) {
	return new $ZodCheckLengthEquals({
		check: "length_equals",
		...normalizeParams(params),
		length
	});
}
function _regex(pattern, params) {
	return new $ZodCheckRegex({
		check: "string_format",
		format: "regex",
		...normalizeParams(params),
		pattern
	});
}
function _lowercase(params) {
	return new $ZodCheckLowerCase({
		check: "string_format",
		format: "lowercase",
		...normalizeParams(params)
	});
}
function _uppercase(params) {
	return new $ZodCheckUpperCase({
		check: "string_format",
		format: "uppercase",
		...normalizeParams(params)
	});
}
function _includes(includes, params) {
	return new $ZodCheckIncludes({
		check: "string_format",
		format: "includes",
		...normalizeParams(params),
		includes
	});
}
function _startsWith(prefix$2, params) {
	return new $ZodCheckStartsWith({
		check: "string_format",
		format: "starts_with",
		...normalizeParams(params),
		prefix: prefix$2
	});
}
function _endsWith(suffix, params) {
	return new $ZodCheckEndsWith({
		check: "string_format",
		format: "ends_with",
		...normalizeParams(params),
		suffix
	});
}
function _overwrite(tx) {
	return new $ZodCheckOverwrite({
		check: "overwrite",
		tx
	});
}
function _normalize(form) {
	return _overwrite((input) => input.normalize(form));
}
function _trim() {
	return _overwrite((input) => input.trim());
}
function _toLowerCase() {
	return _overwrite((input) => input.toLowerCase());
}
function _toUpperCase() {
	return _overwrite((input) => input.toUpperCase());
}
function _slugify() {
	return _overwrite((input) => slugify(input));
}
function _array(Class, element, params) {
	return new Class({
		type: "array",
		element,
		...normalizeParams(params)
	});
}
function _refine(Class, fn, _params) {
	return new Class({
		type: "custom",
		check: "custom",
		fn,
		...normalizeParams(_params)
	});
}
function _superRefine(fn) {
	const ch = _check((payload) => {
		payload.addIssue = (issue$1) => {
			if (typeof issue$1 === "string") payload.issues.push(issue(issue$1, payload.value, ch._zod.def));
			else {
				const _issue = issue$1;
				if (_issue.fatal) _issue.continue = false;
				_issue.code ?? (_issue.code = "custom");
				_issue.input ?? (_issue.input = payload.value);
				_issue.inst ?? (_issue.inst = ch);
				_issue.continue ?? (_issue.continue = !ch._zod.def.abort);
				payload.issues.push(issue(_issue));
			}
		};
		return fn(payload.value, payload);
	});
	return ch;
}
function _check(fn, params) {
	const ch = new $ZodCheck({
		check: "custom",
		...normalizeParams(params)
	});
	ch._zod.check = fn;
	return ch;
}
function initializeContext(params) {
	let target = params?.target ?? "draft-2020-12";
	if (target === "draft-4") target = "draft-04";
	if (target === "draft-7") target = "draft-07";
	return {
		processors: params.processors ?? {},
		metadataRegistry: params?.metadata ?? globalRegistry,
		target,
		unrepresentable: params?.unrepresentable ?? "throw",
		override: params?.override ?? (() => {}),
		io: params?.io ?? "output",
		counter: 0,
		seen: /* @__PURE__ */ new Map(),
		cycles: params?.cycles ?? "ref",
		reused: params?.reused ?? "inline",
		external: params?.external ?? void 0
	};
}
function process(schema, ctx, _params = {
	path: [],
	schemaPath: []
}) {
	var _a$1;
	const def = schema._zod.def;
	const seen = ctx.seen.get(schema);
	if (seen) {
		seen.count++;
		if (_params.schemaPath.includes(schema)) seen.cycle = _params.path;
		return seen.schema;
	}
	const result = {
		schema: {},
		count: 1,
		cycle: void 0,
		path: _params.path
	};
	ctx.seen.set(schema, result);
	const overrideSchema = schema._zod.toJSONSchema?.();
	if (overrideSchema) result.schema = overrideSchema;
	else {
		const params = {
			..._params,
			schemaPath: [..._params.schemaPath, schema],
			path: _params.path
		};
		const parent = schema._zod.parent;
		if (parent) {
			result.ref = parent;
			process(parent, ctx, params);
			ctx.seen.get(parent).isParent = true;
		} else if (schema._zod.processJSONSchema) schema._zod.processJSONSchema(ctx, result.schema, params);
		else {
			const _json = result.schema;
			const processor = ctx.processors[def.type];
			if (!processor) throw new Error(`[toJSONSchema]: Non-representable type encountered: ${def.type}`);
			processor(schema, ctx, _json, params);
		}
	}
	const meta$2 = ctx.metadataRegistry.get(schema);
	if (meta$2) Object.assign(result.schema, meta$2);
	if (ctx.io === "input" && isTransforming(schema)) {
		delete result.schema.examples;
		delete result.schema.default;
	}
	if (ctx.io === "input" && result.schema._prefault) (_a$1 = result.schema).default ?? (_a$1.default = result.schema._prefault);
	delete result.schema._prefault;
	return ctx.seen.get(schema).schema;
}
function extractDefs(ctx, schema) {
	const root$3 = ctx.seen.get(schema);
	if (!root$3) throw new Error("Unprocessed schema. This is a bug in Zod.");
	const makeURI = (entry) => {
		const defsSegment = ctx.target === "draft-2020-12" ? "$defs" : "definitions";
		if (ctx.external) {
			const externalId = ctx.external.registry.get(entry[0])?.id;
			const uriGenerator = ctx.external.uri ?? ((id$1) => id$1);
			if (externalId) return { ref: uriGenerator(externalId) };
			const id = entry[1].defId ?? entry[1].schema.id ?? `schema${ctx.counter++}`;
			entry[1].defId = id;
			return {
				defId: id,
				ref: `${uriGenerator("__shared")}#/${defsSegment}/${id}`
			};
		}
		if (entry[1] === root$3) return { ref: "#" };
		const defUriPrefix = `#/${defsSegment}/`;
		const defId = entry[1].schema.id ?? `__schema${ctx.counter++}`;
		return {
			defId,
			ref: defUriPrefix + defId
		};
	};
	const extractToDef = (entry) => {
		if (entry[1].schema.$ref) return;
		const seen = entry[1];
		const { ref, defId } = makeURI(entry);
		seen.def = { ...seen.schema };
		if (defId) seen.defId = defId;
		const schema$1 = seen.schema;
		for (const key in schema$1) delete schema$1[key];
		schema$1.$ref = ref;
	};
	if (ctx.cycles === "throw") for (const entry of ctx.seen.entries()) {
		const seen = entry[1];
		if (seen.cycle) throw new Error(`Cycle detected: #/${seen.cycle?.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
	}
	for (const entry of ctx.seen.entries()) {
		const seen = entry[1];
		if (schema === entry[0]) {
			extractToDef(entry);
			continue;
		}
		if (ctx.external) {
			const ext = ctx.external.registry.get(entry[0])?.id;
			if (schema !== entry[0] && ext) {
				extractToDef(entry);
				continue;
			}
		}
		if (ctx.metadataRegistry.get(entry[0])?.id) {
			extractToDef(entry);
			continue;
		}
		if (seen.cycle) {
			extractToDef(entry);
			continue;
		}
		if (seen.count > 1) {
			if (ctx.reused === "ref") {
				extractToDef(entry);
				continue;
			}
		}
	}
}
function finalize(ctx, schema) {
	const root$3 = ctx.seen.get(schema);
	if (!root$3) throw new Error("Unprocessed schema. This is a bug in Zod.");
	const flattenRef = (zodSchema) => {
		const seen = ctx.seen.get(zodSchema);
		const schema$1 = seen.def ?? seen.schema;
		const _cached = { ...schema$1 };
		if (seen.ref === null) return;
		const ref = seen.ref;
		seen.ref = null;
		if (ref) {
			flattenRef(ref);
			const refSchema = ctx.seen.get(ref).schema;
			if (refSchema.$ref && (ctx.target === "draft-07" || ctx.target === "draft-04" || ctx.target === "openapi-3.0")) {
				schema$1.allOf = schema$1.allOf ?? [];
				schema$1.allOf.push(refSchema);
			} else {
				Object.assign(schema$1, refSchema);
				Object.assign(schema$1, _cached);
			}
		}
		if (!seen.isParent) ctx.override({
			zodSchema,
			jsonSchema: schema$1,
			path: seen.path ?? []
		});
	};
	for (const entry of [...ctx.seen.entries()].reverse()) flattenRef(entry[0]);
	const result = {};
	if (ctx.target === "draft-2020-12") result.$schema = "https://json-schema.org/draft/2020-12/schema";
	else if (ctx.target === "draft-07") result.$schema = "http://json-schema.org/draft-07/schema#";
	else if (ctx.target === "draft-04") result.$schema = "http://json-schema.org/draft-04/schema#";
	else if (ctx.target === "openapi-3.0") {}
	if (ctx.external?.uri) {
		const id = ctx.external.registry.get(schema)?.id;
		if (!id) throw new Error("Schema is missing an `id` property");
		result.$id = ctx.external.uri(id);
	}
	Object.assign(result, root$3.def ?? root$3.schema);
	const defs = ctx.external?.defs ?? {};
	for (const entry of ctx.seen.entries()) {
		const seen = entry[1];
		if (seen.def && seen.defId) defs[seen.defId] = seen.def;
	}
	if (ctx.external) {} else if (Object.keys(defs).length > 0) if (ctx.target === "draft-2020-12") result.$defs = defs;
	else result.definitions = defs;
	try {
		const finalized = JSON.parse(JSON.stringify(result));
		Object.defineProperty(finalized, "~standard", {
			value: {
				...schema["~standard"],
				jsonSchema: {
					input: createStandardJSONSchemaMethod(schema, "input"),
					output: createStandardJSONSchemaMethod(schema, "output")
				}
			},
			enumerable: false,
			writable: false
		});
		return finalized;
	} catch (_err) {
		throw new Error("Error converting schema to JSON.");
	}
}
function isTransforming(_schema, _ctx) {
	const ctx = _ctx ?? { seen: /* @__PURE__ */ new Set() };
	if (ctx.seen.has(_schema)) return false;
	ctx.seen.add(_schema);
	const def = _schema._zod.def;
	if (def.type === "transform") return true;
	if (def.type === "array") return isTransforming(def.element, ctx);
	if (def.type === "set") return isTransforming(def.valueType, ctx);
	if (def.type === "lazy") return isTransforming(def.getter(), ctx);
	if (def.type === "promise" || def.type === "optional" || def.type === "nonoptional" || def.type === "nullable" || def.type === "readonly" || def.type === "default" || def.type === "prefault") return isTransforming(def.innerType, ctx);
	if (def.type === "intersection") return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);
	if (def.type === "record" || def.type === "map") return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
	if (def.type === "pipe") return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);
	if (def.type === "object") {
		for (const key in def.shape) if (isTransforming(def.shape[key], ctx)) return true;
		return false;
	}
	if (def.type === "union") {
		for (const option of def.options) if (isTransforming(option, ctx)) return true;
		return false;
	}
	if (def.type === "tuple") {
		for (const item of def.items) if (isTransforming(item, ctx)) return true;
		if (def.rest && isTransforming(def.rest, ctx)) return true;
		return false;
	}
	return false;
}
const createToJSONSchemaMethod = (schema, processors = {}) => (params) => {
	const ctx = initializeContext({
		...params,
		processors
	});
	process(schema, ctx);
	extractDefs(ctx, schema);
	return finalize(ctx, schema);
};
const createStandardJSONSchemaMethod = (schema, io) => (params) => {
	const { libraryOptions, target } = params ?? {};
	const ctx = initializeContext({
		...libraryOptions ?? {},
		target,
		io,
		processors: {}
	});
	process(schema, ctx);
	extractDefs(ctx, schema);
	return finalize(ctx, schema);
};
var formatMap = {
	guid: "uuid",
	url: "uri",
	datetime: "date-time",
	json_string: "json-string",
	regex: ""
};
const stringProcessor = (schema, ctx, _json, _params) => {
	const json = _json;
	json.type = "string";
	const { minimum, maximum, format: format$2, patterns, contentEncoding } = schema._zod.bag;
	if (typeof minimum === "number") json.minLength = minimum;
	if (typeof maximum === "number") json.maxLength = maximum;
	if (format$2) {
		json.format = formatMap[format$2] ?? format$2;
		if (json.format === "") delete json.format;
	}
	if (contentEncoding) json.contentEncoding = contentEncoding;
	if (patterns && patterns.size > 0) {
		const regexes = [...patterns];
		if (regexes.length === 1) json.pattern = regexes[0].source;
		else if (regexes.length > 1) json.allOf = [...regexes.map((regex) => ({
			...ctx.target === "draft-07" || ctx.target === "draft-04" || ctx.target === "openapi-3.0" ? { type: "string" } : {},
			pattern: regex.source
		}))];
	}
};
const numberProcessor = (schema, ctx, _json, _params) => {
	const json = _json;
	const { minimum, maximum, format: format$2, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema._zod.bag;
	if (typeof format$2 === "string" && format$2.includes("int")) json.type = "integer";
	else json.type = "number";
	if (typeof exclusiveMinimum === "number") if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") {
		json.minimum = exclusiveMinimum;
		json.exclusiveMinimum = true;
	} else json.exclusiveMinimum = exclusiveMinimum;
	if (typeof minimum === "number") {
		json.minimum = minimum;
		if (typeof exclusiveMinimum === "number" && ctx.target !== "draft-04") if (exclusiveMinimum >= minimum) delete json.minimum;
		else delete json.exclusiveMinimum;
	}
	if (typeof exclusiveMaximum === "number") if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") {
		json.maximum = exclusiveMaximum;
		json.exclusiveMaximum = true;
	} else json.exclusiveMaximum = exclusiveMaximum;
	if (typeof maximum === "number") {
		json.maximum = maximum;
		if (typeof exclusiveMaximum === "number" && ctx.target !== "draft-04") if (exclusiveMaximum <= maximum) delete json.maximum;
		else delete json.exclusiveMaximum;
	}
	if (typeof multipleOf === "number") json.multipleOf = multipleOf;
};
const neverProcessor = (_schema, _ctx, json, _params) => {
	json.not = {};
};
const unknownProcessor = (_schema, _ctx, _json, _params) => {};
const dateProcessor = (_schema, ctx, _json, _params) => {
	if (ctx.unrepresentable === "throw") throw new Error("Date cannot be represented in JSON Schema");
};
const enumProcessor = (schema, _ctx, json, _params) => {
	const def = schema._zod.def;
	const values = getEnumValues(def.entries);
	if (values.every((v) => typeof v === "number")) json.type = "number";
	if (values.every((v) => typeof v === "string")) json.type = "string";
	json.enum = values;
};
const customProcessor = (_schema, ctx, _json, _params) => {
	if (ctx.unrepresentable === "throw") throw new Error("Custom types cannot be represented in JSON Schema");
};
const transformProcessor = (_schema, ctx, _json, _params) => {
	if (ctx.unrepresentable === "throw") throw new Error("Transforms cannot be represented in JSON Schema");
};
const arrayProcessor = (schema, ctx, _json, params) => {
	const json = _json;
	const def = schema._zod.def;
	const { minimum, maximum } = schema._zod.bag;
	if (typeof minimum === "number") json.minItems = minimum;
	if (typeof maximum === "number") json.maxItems = maximum;
	json.type = "array";
	json.items = process(def.element, ctx, {
		...params,
		path: [...params.path, "items"]
	});
};
const objectProcessor = (schema, ctx, _json, params) => {
	const json = _json;
	const def = schema._zod.def;
	json.type = "object";
	json.properties = {};
	const shape = def.shape;
	for (const key in shape) json.properties[key] = process(shape[key], ctx, {
		...params,
		path: [
			...params.path,
			"properties",
			key
		]
	});
	const allKeys = new Set(Object.keys(shape));
	const requiredKeys = new Set([...allKeys].filter((key) => {
		const v = def.shape[key]._zod;
		if (ctx.io === "input") return v.optin === void 0;
		else return v.optout === void 0;
	}));
	if (requiredKeys.size > 0) json.required = Array.from(requiredKeys);
	if (def.catchall?._zod.def.type === "never") json.additionalProperties = false;
	else if (!def.catchall) {
		if (ctx.io === "output") json.additionalProperties = false;
	} else if (def.catchall) json.additionalProperties = process(def.catchall, ctx, {
		...params,
		path: [...params.path, "additionalProperties"]
	});
};
const unionProcessor = (schema, ctx, json, params) => {
	const def = schema._zod.def;
	const isExclusive = def.inclusive === false;
	const options = def.options.map((x$1, i$2) => process(x$1, ctx, {
		...params,
		path: [
			...params.path,
			isExclusive ? "oneOf" : "anyOf",
			i$2
		]
	}));
	if (isExclusive) json.oneOf = options;
	else json.anyOf = options;
};
const intersectionProcessor = (schema, ctx, json, params) => {
	const def = schema._zod.def;
	const a$2 = process(def.left, ctx, {
		...params,
		path: [
			...params.path,
			"allOf",
			0
		]
	});
	const b = process(def.right, ctx, {
		...params,
		path: [
			...params.path,
			"allOf",
			1
		]
	});
	const isSimpleIntersection = (val) => "allOf" in val && Object.keys(val).length === 1;
	json.allOf = [...isSimpleIntersection(a$2) ? a$2.allOf : [a$2], ...isSimpleIntersection(b) ? b.allOf : [b]];
};
const nullableProcessor = (schema, ctx, json, params) => {
	const def = schema._zod.def;
	const inner = process(def.innerType, ctx, params);
	const seen = ctx.seen.get(schema);
	if (ctx.target === "openapi-3.0") {
		seen.ref = def.innerType;
		json.nullable = true;
	} else json.anyOf = [inner, { type: "null" }];
};
const nonoptionalProcessor = (schema, ctx, _json, params) => {
	const def = schema._zod.def;
	process(def.innerType, ctx, params);
	const seen = ctx.seen.get(schema);
	seen.ref = def.innerType;
};
const defaultProcessor = (schema, ctx, json, params) => {
	const def = schema._zod.def;
	process(def.innerType, ctx, params);
	const seen = ctx.seen.get(schema);
	seen.ref = def.innerType;
	json.default = JSON.parse(JSON.stringify(def.defaultValue));
};
const prefaultProcessor = (schema, ctx, json, params) => {
	const def = schema._zod.def;
	process(def.innerType, ctx, params);
	const seen = ctx.seen.get(schema);
	seen.ref = def.innerType;
	if (ctx.io === "input") json._prefault = JSON.parse(JSON.stringify(def.defaultValue));
};
const catchProcessor = (schema, ctx, json, params) => {
	const def = schema._zod.def;
	process(def.innerType, ctx, params);
	const seen = ctx.seen.get(schema);
	seen.ref = def.innerType;
	let catchValue;
	try {
		catchValue = def.catchValue(void 0);
	} catch {
		throw new Error("Dynamic catch values are not supported in JSON Schema");
	}
	json.default = catchValue;
};
const pipeProcessor = (schema, ctx, _json, params) => {
	const def = schema._zod.def;
	const innerType = ctx.io === "input" ? def.in._zod.def.type === "transform" ? def.out : def.in : def.out;
	process(innerType, ctx, params);
	const seen = ctx.seen.get(schema);
	seen.ref = innerType;
};
const readonlyProcessor = (schema, ctx, json, params) => {
	const def = schema._zod.def;
	process(def.innerType, ctx, params);
	const seen = ctx.seen.get(schema);
	seen.ref = def.innerType;
	json.readOnly = true;
};
const optionalProcessor = (schema, ctx, _json, params) => {
	const def = schema._zod.def;
	process(def.innerType, ctx, params);
	const seen = ctx.seen.get(schema);
	seen.ref = def.innerType;
};
function t(r$1, e) {
	try {
		var o$1 = r$1();
	} catch (r$2) {
		return e(r$2);
	}
	return o$1 && o$1.then ? o$1.then(void 0, e) : o$1;
}
function s$2(r$1, e) {
	for (var n$1 = {}; r$1.length;) {
		var t$1 = r$1[0], s$3 = t$1.code, i$2 = t$1.message, a$2 = t$1.path.join(".");
		if (!n$1[a$2]) if ("unionErrors" in t$1) {
			var u = t$1.unionErrors[0].errors[0];
			n$1[a$2] = {
				message: u.message,
				type: u.code
			};
		} else n$1[a$2] = {
			message: i$2,
			type: s$3
		};
		if ("unionErrors" in t$1 && t$1.unionErrors.forEach(function(e$1) {
			return e$1.errors.forEach(function(e$2) {
				return r$1.push(e$2);
			});
		}), e) {
			var c$1 = n$1[a$2].types, f = c$1 && c$1[t$1.code];
			n$1[a$2] = appendErrors(a$2, e, n$1, s$3, f ? [].concat(f, t$1.message) : t$1.message);
		}
		r$1.shift();
	}
	return n$1;
}
function i(r$1, e) {
	for (var n$1 = {}; r$1.length;) {
		var t$1 = r$1[0], s$3 = t$1.code, i$2 = t$1.message, a$2 = t$1.path.join(".");
		if (!n$1[a$2]) if ("invalid_union" === t$1.code && t$1.errors.length > 0) {
			var u = t$1.errors[0][0];
			n$1[a$2] = {
				message: u.message,
				type: u.code
			};
		} else n$1[a$2] = {
			message: i$2,
			type: s$3
		};
		if ("invalid_union" === t$1.code && t$1.errors.forEach(function(e$1) {
			return e$1.forEach(function(e$2) {
				return r$1.push(e$2);
			});
		}), e) {
			var c$1 = n$1[a$2].types, f = c$1 && c$1[t$1.code];
			n$1[a$2] = appendErrors(a$2, e, n$1, s$3, f ? [].concat(f, t$1.message) : t$1.message);
		}
		r$1.shift();
	}
	return n$1;
}
function a$1(o$1, a$2, u) {
	if (void 0 === u && (u = {}), function(r$1) {
		return "_def" in r$1 && "object" == typeof r$1._def && "typeName" in r$1._def;
	}(o$1)) return function(n$1, i$2, c$1) {
		try {
			return Promise.resolve(t(function() {
				return Promise.resolve(o$1["sync" === u.mode ? "parse" : "parseAsync"](n$1, a$2)).then(function(e) {
					return c$1.shouldUseNativeValidation && o({}, c$1), {
						errors: {},
						values: u.raw ? Object.assign({}, n$1) : e
					};
				});
			}, function(r$1) {
				if (function(r$2) {
					return Array.isArray(null == r$2 ? void 0 : r$2.issues);
				}(r$1)) return {
					values: {},
					errors: s$1(s$2(r$1.errors, !c$1.shouldUseNativeValidation && "all" === c$1.criteriaMode), c$1)
				};
				throw r$1;
			}));
		} catch (r$1) {
			return Promise.reject(r$1);
		}
	};
	if (function(r$1) {
		return "_zod" in r$1 && "object" == typeof r$1._zod;
	}(o$1)) return function(s$3, c$1, f) {
		try {
			return Promise.resolve(t(function() {
				return Promise.resolve(("sync" === u.mode ? parse$1 : parseAsync$1)(o$1, s$3, a$2)).then(function(e) {
					return f.shouldUseNativeValidation && o({}, f), {
						errors: {},
						values: u.raw ? Object.assign({}, s$3) : e
					};
				});
			}, function(r$1) {
				if (function(r$2) {
					return r$2 instanceof $ZodError;
				}(r$1)) return {
					values: {},
					errors: s$1(i(r$1.issues, !f.shouldUseNativeValidation && "all" === f.criteriaMode), f)
				};
				throw r$1;
			}));
		} catch (r$1) {
			return Promise.reject(r$1);
		}
	};
	throw new Error("Invalid input: not a Zod schema");
}
const ZodISODateTime = /* @__PURE__ */ $constructor("ZodISODateTime", (inst, def) => {
	$ZodISODateTime.init(inst, def);
	ZodStringFormat.init(inst, def);
});
function datetime(params) {
	return _isoDateTime(ZodISODateTime, params);
}
const ZodISODate = /* @__PURE__ */ $constructor("ZodISODate", (inst, def) => {
	$ZodISODate.init(inst, def);
	ZodStringFormat.init(inst, def);
});
function date$2(params) {
	return _isoDate(ZodISODate, params);
}
const ZodISOTime = /* @__PURE__ */ $constructor("ZodISOTime", (inst, def) => {
	$ZodISOTime.init(inst, def);
	ZodStringFormat.init(inst, def);
});
function time$1(params) {
	return _isoTime(ZodISOTime, params);
}
const ZodISODuration = /* @__PURE__ */ $constructor("ZodISODuration", (inst, def) => {
	$ZodISODuration.init(inst, def);
	ZodStringFormat.init(inst, def);
});
function duration(params) {
	return _isoDuration(ZodISODuration, params);
}
var initializer = (inst, issues) => {
	$ZodError.init(inst, issues);
	inst.name = "ZodError";
	Object.defineProperties(inst, {
		format: { value: (mapper) => formatError(inst, mapper) },
		flatten: { value: (mapper) => flattenError(inst, mapper) },
		addIssue: { value: (issue$1) => {
			inst.issues.push(issue$1);
			inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
		} },
		addIssues: { value: (issues$1) => {
			inst.issues.push(...issues$1);
			inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
		} },
		isEmpty: { get() {
			return inst.issues.length === 0;
		} }
	});
};
$constructor("ZodError", initializer);
const ZodRealError = $constructor("ZodError", initializer, { Parent: Error });
const parse = /* @__PURE__ */ _parse(ZodRealError);
const parseAsync = /* @__PURE__ */ _parseAsync(ZodRealError);
const safeParse = /* @__PURE__ */ _safeParse(ZodRealError);
const safeParseAsync = /* @__PURE__ */ _safeParseAsync(ZodRealError);
const encode = /* @__PURE__ */ _encode(ZodRealError);
const decode = /* @__PURE__ */ _decode(ZodRealError);
const encodeAsync = /* @__PURE__ */ _encodeAsync(ZodRealError);
const decodeAsync = /* @__PURE__ */ _decodeAsync(ZodRealError);
const safeEncode = /* @__PURE__ */ _safeEncode(ZodRealError);
const safeDecode = /* @__PURE__ */ _safeDecode(ZodRealError);
const safeEncodeAsync = /* @__PURE__ */ _safeEncodeAsync(ZodRealError);
const safeDecodeAsync = /* @__PURE__ */ _safeDecodeAsync(ZodRealError);
const ZodType = /* @__PURE__ */ $constructor("ZodType", (inst, def) => {
	$ZodType.init(inst, def);
	Object.assign(inst["~standard"], { jsonSchema: {
		input: createStandardJSONSchemaMethod(inst, "input"),
		output: createStandardJSONSchemaMethod(inst, "output")
	} });
	inst.toJSONSchema = createToJSONSchemaMethod(inst, {});
	inst.def = def;
	inst.type = def.type;
	Object.defineProperty(inst, "_def", { value: def });
	inst.check = (...checks) => {
		return inst.clone(mergeDefs(def, { checks: [...def.checks ?? [], ...checks.map((ch) => typeof ch === "function" ? { _zod: {
			check: ch,
			def: { check: "custom" },
			onattach: []
		} } : ch)] }));
	};
	inst.clone = (def$1, params) => clone(inst, def$1, params);
	inst.brand = () => inst;
	inst.register = ((reg, meta$2) => {
		reg.add(inst, meta$2);
		return inst;
	});
	inst.parse = (data, params) => parse(inst, data, params, { callee: inst.parse });
	inst.safeParse = (data, params) => safeParse(inst, data, params);
	inst.parseAsync = async (data, params) => parseAsync(inst, data, params, { callee: inst.parseAsync });
	inst.safeParseAsync = async (data, params) => safeParseAsync(inst, data, params);
	inst.spa = inst.safeParseAsync;
	inst.encode = (data, params) => encode(inst, data, params);
	inst.decode = (data, params) => decode(inst, data, params);
	inst.encodeAsync = async (data, params) => encodeAsync(inst, data, params);
	inst.decodeAsync = async (data, params) => decodeAsync(inst, data, params);
	inst.safeEncode = (data, params) => safeEncode(inst, data, params);
	inst.safeDecode = (data, params) => safeDecode(inst, data, params);
	inst.safeEncodeAsync = async (data, params) => safeEncodeAsync(inst, data, params);
	inst.safeDecodeAsync = async (data, params) => safeDecodeAsync(inst, data, params);
	inst.refine = (check, params) => inst.check(refine(check, params));
	inst.superRefine = (refinement) => inst.check(superRefine(refinement));
	inst.overwrite = (fn) => inst.check(_overwrite(fn));
	inst.optional = () => optional(inst);
	inst.nullable = () => nullable(inst);
	inst.nullish = () => optional(nullable(inst));
	inst.nonoptional = (params) => nonoptional(inst, params);
	inst.array = () => array(inst);
	inst.or = (arg) => union([inst, arg]);
	inst.and = (arg) => intersection(inst, arg);
	inst.transform = (tx) => pipe(inst, transform(tx));
	inst.default = (def$1) => _default(inst, def$1);
	inst.prefault = (def$1) => prefault(inst, def$1);
	inst.catch = (params) => _catch(inst, params);
	inst.pipe = (target) => pipe(inst, target);
	inst.readonly = () => readonly(inst);
	inst.describe = (description) => {
		const cl = inst.clone();
		globalRegistry.add(cl, { description });
		return cl;
	};
	Object.defineProperty(inst, "description", {
		get() {
			return globalRegistry.get(inst)?.description;
		},
		configurable: true
	});
	inst.meta = (...args) => {
		if (args.length === 0) return globalRegistry.get(inst);
		const cl = inst.clone();
		globalRegistry.add(cl, args[0]);
		return cl;
	};
	inst.isOptional = () => inst.safeParse(void 0).success;
	inst.isNullable = () => inst.safeParse(null).success;
	return inst;
});
const _ZodString = /* @__PURE__ */ $constructor("_ZodString", (inst, def) => {
	$ZodString.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json, params) => stringProcessor(inst, ctx, json, params);
	const bag = inst._zod.bag;
	inst.format = bag.format ?? null;
	inst.minLength = bag.minimum ?? null;
	inst.maxLength = bag.maximum ?? null;
	inst.regex = (...args) => inst.check(_regex(...args));
	inst.includes = (...args) => inst.check(_includes(...args));
	inst.startsWith = (...args) => inst.check(_startsWith(...args));
	inst.endsWith = (...args) => inst.check(_endsWith(...args));
	inst.min = (...args) => inst.check(_minLength(...args));
	inst.max = (...args) => inst.check(_maxLength(...args));
	inst.length = (...args) => inst.check(_length(...args));
	inst.nonempty = (...args) => inst.check(_minLength(1, ...args));
	inst.lowercase = (params) => inst.check(_lowercase(params));
	inst.uppercase = (params) => inst.check(_uppercase(params));
	inst.trim = () => inst.check(_trim());
	inst.normalize = (...args) => inst.check(_normalize(...args));
	inst.toLowerCase = () => inst.check(_toLowerCase());
	inst.toUpperCase = () => inst.check(_toUpperCase());
	inst.slugify = () => inst.check(_slugify());
});
const ZodString = /* @__PURE__ */ $constructor("ZodString", (inst, def) => {
	$ZodString.init(inst, def);
	_ZodString.init(inst, def);
	inst.email = (params) => inst.check(_email(ZodEmail, params));
	inst.url = (params) => inst.check(_url(ZodURL, params));
	inst.jwt = (params) => inst.check(_jwt(ZodJWT, params));
	inst.emoji = (params) => inst.check(_emoji(ZodEmoji, params));
	inst.guid = (params) => inst.check(_guid(ZodGUID, params));
	inst.uuid = (params) => inst.check(_uuid(ZodUUID, params));
	inst.uuidv4 = (params) => inst.check(_uuidv4(ZodUUID, params));
	inst.uuidv6 = (params) => inst.check(_uuidv6(ZodUUID, params));
	inst.uuidv7 = (params) => inst.check(_uuidv7(ZodUUID, params));
	inst.nanoid = (params) => inst.check(_nanoid(ZodNanoID, params));
	inst.guid = (params) => inst.check(_guid(ZodGUID, params));
	inst.cuid = (params) => inst.check(_cuid(ZodCUID, params));
	inst.cuid2 = (params) => inst.check(_cuid2(ZodCUID2, params));
	inst.ulid = (params) => inst.check(_ulid(ZodULID, params));
	inst.base64 = (params) => inst.check(_base64(ZodBase64, params));
	inst.base64url = (params) => inst.check(_base64url(ZodBase64URL, params));
	inst.xid = (params) => inst.check(_xid(ZodXID, params));
	inst.ksuid = (params) => inst.check(_ksuid(ZodKSUID, params));
	inst.ipv4 = (params) => inst.check(_ipv4(ZodIPv4, params));
	inst.ipv6 = (params) => inst.check(_ipv6(ZodIPv6, params));
	inst.cidrv4 = (params) => inst.check(_cidrv4(ZodCIDRv4, params));
	inst.cidrv6 = (params) => inst.check(_cidrv6(ZodCIDRv6, params));
	inst.e164 = (params) => inst.check(_e164(ZodE164, params));
	inst.datetime = (params) => inst.check(datetime(params));
	inst.date = (params) => inst.check(date$2(params));
	inst.time = (params) => inst.check(time$1(params));
	inst.duration = (params) => inst.check(duration(params));
});
function string(params) {
	return _string(ZodString, params);
}
const ZodStringFormat = /* @__PURE__ */ $constructor("ZodStringFormat", (inst, def) => {
	$ZodStringFormat.init(inst, def);
	_ZodString.init(inst, def);
});
const ZodEmail = /* @__PURE__ */ $constructor("ZodEmail", (inst, def) => {
	$ZodEmail.init(inst, def);
	ZodStringFormat.init(inst, def);
});
const ZodGUID = /* @__PURE__ */ $constructor("ZodGUID", (inst, def) => {
	$ZodGUID.init(inst, def);
	ZodStringFormat.init(inst, def);
});
const ZodUUID = /* @__PURE__ */ $constructor("ZodUUID", (inst, def) => {
	$ZodUUID.init(inst, def);
	ZodStringFormat.init(inst, def);
});
const ZodURL = /* @__PURE__ */ $constructor("ZodURL", (inst, def) => {
	$ZodURL.init(inst, def);
	ZodStringFormat.init(inst, def);
});
const ZodEmoji = /* @__PURE__ */ $constructor("ZodEmoji", (inst, def) => {
	$ZodEmoji.init(inst, def);
	ZodStringFormat.init(inst, def);
});
const ZodNanoID = /* @__PURE__ */ $constructor("ZodNanoID", (inst, def) => {
	$ZodNanoID.init(inst, def);
	ZodStringFormat.init(inst, def);
});
const ZodCUID = /* @__PURE__ */ $constructor("ZodCUID", (inst, def) => {
	$ZodCUID.init(inst, def);
	ZodStringFormat.init(inst, def);
});
const ZodCUID2 = /* @__PURE__ */ $constructor("ZodCUID2", (inst, def) => {
	$ZodCUID2.init(inst, def);
	ZodStringFormat.init(inst, def);
});
const ZodULID = /* @__PURE__ */ $constructor("ZodULID", (inst, def) => {
	$ZodULID.init(inst, def);
	ZodStringFormat.init(inst, def);
});
const ZodXID = /* @__PURE__ */ $constructor("ZodXID", (inst, def) => {
	$ZodXID.init(inst, def);
	ZodStringFormat.init(inst, def);
});
const ZodKSUID = /* @__PURE__ */ $constructor("ZodKSUID", (inst, def) => {
	$ZodKSUID.init(inst, def);
	ZodStringFormat.init(inst, def);
});
const ZodIPv4 = /* @__PURE__ */ $constructor("ZodIPv4", (inst, def) => {
	$ZodIPv4.init(inst, def);
	ZodStringFormat.init(inst, def);
});
const ZodIPv6 = /* @__PURE__ */ $constructor("ZodIPv6", (inst, def) => {
	$ZodIPv6.init(inst, def);
	ZodStringFormat.init(inst, def);
});
const ZodCIDRv4 = /* @__PURE__ */ $constructor("ZodCIDRv4", (inst, def) => {
	$ZodCIDRv4.init(inst, def);
	ZodStringFormat.init(inst, def);
});
const ZodCIDRv6 = /* @__PURE__ */ $constructor("ZodCIDRv6", (inst, def) => {
	$ZodCIDRv6.init(inst, def);
	ZodStringFormat.init(inst, def);
});
const ZodBase64 = /* @__PURE__ */ $constructor("ZodBase64", (inst, def) => {
	$ZodBase64.init(inst, def);
	ZodStringFormat.init(inst, def);
});
const ZodBase64URL = /* @__PURE__ */ $constructor("ZodBase64URL", (inst, def) => {
	$ZodBase64URL.init(inst, def);
	ZodStringFormat.init(inst, def);
});
const ZodE164 = /* @__PURE__ */ $constructor("ZodE164", (inst, def) => {
	$ZodE164.init(inst, def);
	ZodStringFormat.init(inst, def);
});
const ZodJWT = /* @__PURE__ */ $constructor("ZodJWT", (inst, def) => {
	$ZodJWT.init(inst, def);
	ZodStringFormat.init(inst, def);
});
const ZodNumber = /* @__PURE__ */ $constructor("ZodNumber", (inst, def) => {
	$ZodNumber.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json, params) => numberProcessor(inst, ctx, json, params);
	inst.gt = (value, params) => inst.check(_gt(value, params));
	inst.gte = (value, params) => inst.check(_gte(value, params));
	inst.min = (value, params) => inst.check(_gte(value, params));
	inst.lt = (value, params) => inst.check(_lt(value, params));
	inst.lte = (value, params) => inst.check(_lte(value, params));
	inst.max = (value, params) => inst.check(_lte(value, params));
	inst.int = (params) => inst.check(int(params));
	inst.safe = (params) => inst.check(int(params));
	inst.positive = (params) => inst.check(_gt(0, params));
	inst.nonnegative = (params) => inst.check(_gte(0, params));
	inst.negative = (params) => inst.check(_lt(0, params));
	inst.nonpositive = (params) => inst.check(_lte(0, params));
	inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
	inst.step = (value, params) => inst.check(_multipleOf(value, params));
	inst.finite = () => inst;
	const bag = inst._zod.bag;
	inst.minValue = Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;
	inst.maxValue = Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;
	inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? .5);
	inst.isFinite = true;
	inst.format = bag.format ?? null;
});
const ZodNumberFormat = /* @__PURE__ */ $constructor("ZodNumberFormat", (inst, def) => {
	$ZodNumberFormat.init(inst, def);
	ZodNumber.init(inst, def);
});
function int(params) {
	return _int(ZodNumberFormat, params);
}
const ZodUnknown = /* @__PURE__ */ $constructor("ZodUnknown", (inst, def) => {
	$ZodUnknown.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json, params) => unknownProcessor(inst, ctx, json, params);
});
function unknown() {
	return _unknown(ZodUnknown);
}
const ZodNever = /* @__PURE__ */ $constructor("ZodNever", (inst, def) => {
	$ZodNever.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json, params) => neverProcessor(inst, ctx, json, params);
});
function never(params) {
	return _never(ZodNever, params);
}
const ZodDate = /* @__PURE__ */ $constructor("ZodDate", (inst, def) => {
	$ZodDate.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json, params) => dateProcessor(inst, ctx, json, params);
	inst.min = (value, params) => inst.check(_gte(value, params));
	inst.max = (value, params) => inst.check(_lte(value, params));
	const c$1 = inst._zod.bag;
	inst.minDate = c$1.minimum ? new Date(c$1.minimum) : null;
	inst.maxDate = c$1.maximum ? new Date(c$1.maximum) : null;
});
function date$1(params) {
	return _date(ZodDate, params);
}
const ZodArray = /* @__PURE__ */ $constructor("ZodArray", (inst, def) => {
	$ZodArray.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json, params) => arrayProcessor(inst, ctx, json, params);
	inst.element = def.element;
	inst.min = (minLength, params) => inst.check(_minLength(minLength, params));
	inst.nonempty = (params) => inst.check(_minLength(1, params));
	inst.max = (maxLength, params) => inst.check(_maxLength(maxLength, params));
	inst.length = (len, params) => inst.check(_length(len, params));
	inst.unwrap = () => inst.element;
});
function array(element, params) {
	return _array(ZodArray, element, params);
}
const ZodObject = /* @__PURE__ */ $constructor("ZodObject", (inst, def) => {
	$ZodObjectJIT.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json, params) => objectProcessor(inst, ctx, json, params);
	defineLazy(inst, "shape", () => {
		return def.shape;
	});
	inst.keyof = () => _enum(Object.keys(inst._zod.def.shape));
	inst.catchall = (catchall) => inst.clone({
		...inst._zod.def,
		catchall
	});
	inst.passthrough = () => inst.clone({
		...inst._zod.def,
		catchall: unknown()
	});
	inst.loose = () => inst.clone({
		...inst._zod.def,
		catchall: unknown()
	});
	inst.strict = () => inst.clone({
		...inst._zod.def,
		catchall: never()
	});
	inst.strip = () => inst.clone({
		...inst._zod.def,
		catchall: void 0
	});
	inst.extend = (incoming) => {
		return extend$1(inst, incoming);
	};
	inst.safeExtend = (incoming) => {
		return safeExtend(inst, incoming);
	};
	inst.merge = (other) => merge(inst, other);
	inst.pick = (mask) => pick(inst, mask);
	inst.omit = (mask) => omit(inst, mask);
	inst.partial = (...args) => partial(ZodOptional, inst, args[0]);
	inst.required = (...args) => required(ZodNonOptional, inst, args[0]);
});
function object(shape, params) {
	return new ZodObject({
		type: "object",
		shape: shape ?? {},
		...normalizeParams(params)
	});
}
const ZodUnion = /* @__PURE__ */ $constructor("ZodUnion", (inst, def) => {
	$ZodUnion.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json, params) => unionProcessor(inst, ctx, json, params);
	inst.options = def.options;
});
function union(options, params) {
	return new ZodUnion({
		type: "union",
		options,
		...normalizeParams(params)
	});
}
const ZodIntersection = /* @__PURE__ */ $constructor("ZodIntersection", (inst, def) => {
	$ZodIntersection.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json, params) => intersectionProcessor(inst, ctx, json, params);
});
function intersection(left, right) {
	return new ZodIntersection({
		type: "intersection",
		left,
		right
	});
}
const ZodEnum = /* @__PURE__ */ $constructor("ZodEnum", (inst, def) => {
	$ZodEnum.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json, params) => enumProcessor(inst, ctx, json, params);
	inst.enum = def.entries;
	inst.options = Object.values(def.entries);
	const keys$6 = new Set(Object.keys(def.entries));
	inst.extract = (values, params) => {
		const newEntries = {};
		for (const value of values) if (keys$6.has(value)) newEntries[value] = def.entries[value];
		else throw new Error(`Key ${value} not found in enum`);
		return new ZodEnum({
			...def,
			checks: [],
			...normalizeParams(params),
			entries: newEntries
		});
	};
	inst.exclude = (values, params) => {
		const newEntries = { ...def.entries };
		for (const value of values) if (keys$6.has(value)) delete newEntries[value];
		else throw new Error(`Key ${value} not found in enum`);
		return new ZodEnum({
			...def,
			checks: [],
			...normalizeParams(params),
			entries: newEntries
		});
	};
});
function _enum(values, params) {
	return new ZodEnum({
		type: "enum",
		entries: Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values,
		...normalizeParams(params)
	});
}
const ZodTransform = /* @__PURE__ */ $constructor("ZodTransform", (inst, def) => {
	$ZodTransform.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json, params) => transformProcessor(inst, ctx, json, params);
	inst._zod.parse = (payload, _ctx) => {
		if (_ctx.direction === "backward") throw new $ZodEncodeError(inst.constructor.name);
		payload.addIssue = (issue$1) => {
			if (typeof issue$1 === "string") payload.issues.push(issue(issue$1, payload.value, def));
			else {
				const _issue = issue$1;
				if (_issue.fatal) _issue.continue = false;
				_issue.code ?? (_issue.code = "custom");
				_issue.input ?? (_issue.input = payload.value);
				_issue.inst ?? (_issue.inst = inst);
				payload.issues.push(issue(_issue));
			}
		};
		const output = def.transform(payload.value, payload);
		if (output instanceof Promise) return output.then((output$1) => {
			payload.value = output$1;
			return payload;
		});
		payload.value = output;
		return payload;
	};
});
function transform(fn) {
	return new ZodTransform({
		type: "transform",
		transform: fn
	});
}
const ZodOptional = /* @__PURE__ */ $constructor("ZodOptional", (inst, def) => {
	$ZodOptional.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json, params) => optionalProcessor(inst, ctx, json, params);
	inst.unwrap = () => inst._zod.def.innerType;
});
function optional(innerType) {
	return new ZodOptional({
		type: "optional",
		innerType
	});
}
const ZodNullable = /* @__PURE__ */ $constructor("ZodNullable", (inst, def) => {
	$ZodNullable.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json, params) => nullableProcessor(inst, ctx, json, params);
	inst.unwrap = () => inst._zod.def.innerType;
});
function nullable(innerType) {
	return new ZodNullable({
		type: "nullable",
		innerType
	});
}
const ZodDefault = /* @__PURE__ */ $constructor("ZodDefault", (inst, def) => {
	$ZodDefault.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json, params) => defaultProcessor(inst, ctx, json, params);
	inst.unwrap = () => inst._zod.def.innerType;
	inst.removeDefault = inst.unwrap;
});
function _default(innerType, defaultValue) {
	return new ZodDefault({
		type: "default",
		innerType,
		get defaultValue() {
			return typeof defaultValue === "function" ? defaultValue() : shallowClone(defaultValue);
		}
	});
}
const ZodPrefault = /* @__PURE__ */ $constructor("ZodPrefault", (inst, def) => {
	$ZodPrefault.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json, params) => prefaultProcessor(inst, ctx, json, params);
	inst.unwrap = () => inst._zod.def.innerType;
});
function prefault(innerType, defaultValue) {
	return new ZodPrefault({
		type: "prefault",
		innerType,
		get defaultValue() {
			return typeof defaultValue === "function" ? defaultValue() : shallowClone(defaultValue);
		}
	});
}
const ZodNonOptional = /* @__PURE__ */ $constructor("ZodNonOptional", (inst, def) => {
	$ZodNonOptional.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json, params) => nonoptionalProcessor(inst, ctx, json, params);
	inst.unwrap = () => inst._zod.def.innerType;
});
function nonoptional(innerType, params) {
	return new ZodNonOptional({
		type: "nonoptional",
		innerType,
		...normalizeParams(params)
	});
}
const ZodCatch = /* @__PURE__ */ $constructor("ZodCatch", (inst, def) => {
	$ZodCatch.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json, params) => catchProcessor(inst, ctx, json, params);
	inst.unwrap = () => inst._zod.def.innerType;
	inst.removeCatch = inst.unwrap;
});
function _catch(innerType, catchValue) {
	return new ZodCatch({
		type: "catch",
		innerType,
		catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
	});
}
const ZodPipe = /* @__PURE__ */ $constructor("ZodPipe", (inst, def) => {
	$ZodPipe.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json, params) => pipeProcessor(inst, ctx, json, params);
	inst.in = def.in;
	inst.out = def.out;
});
function pipe(in_, out) {
	return new ZodPipe({
		type: "pipe",
		in: in_,
		out
	});
}
const ZodReadonly = /* @__PURE__ */ $constructor("ZodReadonly", (inst, def) => {
	$ZodReadonly.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json, params) => readonlyProcessor(inst, ctx, json, params);
	inst.unwrap = () => inst._zod.def.innerType;
});
function readonly(innerType) {
	return new ZodReadonly({
		type: "readonly",
		innerType
	});
}
const ZodCustom = /* @__PURE__ */ $constructor("ZodCustom", (inst, def) => {
	$ZodCustom.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json, params) => customProcessor(inst, ctx, json, params);
});
function refine(fn, _params = {}) {
	return _refine(ZodCustom, fn, _params);
}
function superRefine(fn) {
	return _superRefine(fn);
}
function number$3(params) {
	return _coercedNumber(ZodNumber, params);
}
var import_jsx_runtime = /* @__PURE__ */ __toESM(require_jsx_runtime(), 1);
var Form = FormProvider;
var FormFieldContext = import_react.createContext({});
var FormField = ({ ...props }) => {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(FormFieldContext.Provider, {
		value: { name: props.name },
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Controller, { ...props })
	});
};
var useFormField = () => {
	const fieldContext = import_react.useContext(FormFieldContext);
	const itemContext = import_react.useContext(FormItemContext);
	const { getFieldState, formState } = useFormContext();
	const fieldState = getFieldState(fieldContext.name, formState);
	if (!fieldContext) throw new Error("useFormField should be used within <FormField>");
	const { id } = itemContext;
	return {
		id,
		name: fieldContext.name,
		formItemId: `${id}-form-item`,
		formDescriptionId: `${id}-form-item-description`,
		formMessageId: `${id}-form-item-message`,
		...fieldState
	};
};
var FormItemContext = import_react.createContext({});
var FormItem = import_react.forwardRef(({ className, ...props }, ref) => {
	const id = import_react.useId();
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(FormItemContext.Provider, {
		value: { id },
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
			ref,
			className: cn("space-y-2", className),
			...props
		})
	});
});
FormItem.displayName = "FormItem";
var FormLabel = import_react.forwardRef(({ className, ...props }, ref) => {
	const { error, formItemId } = useFormField();
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Label$1, {
		ref,
		className: cn(error && "text-destructive", className),
		htmlFor: formItemId,
		...props
	});
});
FormLabel.displayName = "FormLabel";
var FormControl = import_react.forwardRef(({ ...props }, ref) => {
	const { error, formItemId, formDescriptionId, formMessageId } = useFormField();
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Slot, {
		ref,
		id: formItemId,
		"aria-describedby": !error ? `${formDescriptionId}` : `${formDescriptionId} ${formMessageId}`,
		"aria-invalid": !!error,
		...props
	});
});
FormControl.displayName = "FormControl";
var FormDescription = import_react.forwardRef(({ className, ...props }, ref) => {
	const { formDescriptionId } = useFormField();
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("p", {
		ref,
		id: formDescriptionId,
		className: cn("text-sm text-muted-foreground", className),
		...props
	});
});
FormDescription.displayName = "FormDescription";
var FormMessage = import_react.forwardRef(({ className, children, ...props }, ref) => {
	const { error, formMessageId } = useFormField();
	const body = error ? String(error?.message ?? "") : children;
	if (!body) return null;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("p", {
		ref,
		id: formMessageId,
		className: cn("text-sm font-medium text-destructive", className),
		...props,
		children: body
	});
});
FormMessage.displayName = "FormMessage";
var formSchema = object({
	date: date$1({ required_error: "Data  obrigatria" }),
	presenter: string().min(1, "Apresentador  obrigatrio"),
	customPresenter: string().optional(),
	peakViewers: number$3().min(1, "Mnimo 1 espectador"),
	retainedViewers: number$3().min(0),
	sales: number$3().min(0),
	revenue: string().min(1, "Faturamento  obrigatrio"),
	additionalSeats: number$3().min(0)
}).refine((data) => data.retainedViewers <= data.peakViewers, {
	message: "Retidos no pode ser maior que o pico",
	path: ["retainedViewers"]
});
function AddLiveModal({ presenters, onSuccess, customTrigger }) {
	const { toast } = useToast();
	const [open, setOpen] = (0, import_react.useState)(false);
	const [isSubmitting, setIsSubmitting] = (0, import_react.useState)(false);
	const [calculatedMetrics, setCalculatedMetrics] = (0, import_react.useState)({
		conversion: 0,
		retention: 0
	});
	const form = useForm({
		resolver: a$1(formSchema),
		defaultValues: {
			peakViewers: 0,
			retainedViewers: 0,
			sales: 0,
			revenue: "",
			additionalSeats: 0
		}
	});
	const values = form.watch();
	(0, import_react.useEffect)(() => {
		const peak = Number(values.peakViewers) || 0;
		const retained = Number(values.retainedViewers) || 0;
		const sales = Number(values.sales) || 0;
		const conversion = peak > 0 ? sales / peak * 100 : 0;
		const retention = peak > 0 ? retained / peak * 100 : 0;
		setCalculatedMetrics({
			conversion: parseFloat(conversion.toFixed(2)),
			retention: parseFloat(retention.toFixed(2))
		});
	}, [
		values.peakViewers,
		values.retainedViewers,
		values.sales
	]);
	const handleRevenueChange = (e) => {
		let value = e.target.value.replace(/\D/g, "");
		const numberValue = Number(value) / 100;
		const formatted = new Intl.NumberFormat("pt-BR", { minimumFractionDigits: 2 }).format(numberValue);
		form.setValue("revenue", formatted);
	};
	const onSubmit = async (data) => {
		setIsSubmitting(true);
		try {
			const presenterName = data.presenter === "other" ? data.customPresenter : data.presenter;
			if (!presenterName) {
				form.setError("customPresenter", { message: "Nome do apresentador  obrigatrio" });
				setIsSubmitting(false);
				return;
			}
			const revenueValue = Number(data.revenue.replace(/\./g, "").replace(",", ".")) || 0;
			await googleSheetsService.addLiveToSheet({
				date: data.date.toISOString().split("T")[0],
				weekday: format(data.date, "EEEE", { locale: ptBR }),
				presenter: presenterName,
				peakViewers: data.peakViewers,
				retainedViewers: data.retainedViewers,
				sales: data.sales,
				revenue: revenueValue,
				additionalSeats: data.additionalSeats,
				conversionRate: calculatedMetrics.conversion,
				retentionRate: calculatedMetrics.retention
			});
			toast({
				title: "Sucesso",
				description: "Live adicionada com sucesso!",
				className: "bg-[#10B981] text-white border-none"
			});
			setOpen(false);
			form.reset();
			onSuccess();
		} catch (error) {
			console.error(error);
			toast({
				title: "Erro",
				description: "Erro ao salvar live. Tente novamente.",
				variant: "destructive",
				className: "bg-[#EF4444] text-white border-none"
			});
		} finally {
			setIsSubmitting(false);
		}
	};
	const selectedDate = form.watch("date");
	const weekday = selectedDate ? format(selectedDate, "EEEE", { locale: ptBR }) : "";
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Dialog, {
		open,
		onOpenChange: setOpen,
		children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(DialogTrigger, {
			asChild: true,
			children: customTrigger || /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Button, {
				className: "h-12 w-12 rounded-full bg-[#10B981] p-0 hover:bg-[#059669] md:h-10 md:w-auto md:rounded-md md:px-4",
				children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Plus, { className: "h-6 w-6 md:mr-2 md:h-4 md:w-4" }), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
					className: "hidden md:inline",
					children: "Adicionar Live Exponencial"
				})]
			})
		}), /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(DialogContent, {
			className: "sm:max-w-[600px] max-h-[90vh] overflow-y-auto",
			children: [/* @__PURE__ */ (0, import_jsx_runtime.jsxs)(DialogHeader, { children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(DialogTitle, { children: "Adicionar Nova Live" }), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(DialogDescription, { children: "Insira os dados da live manualmente para atualizar o dashboard." })] }), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Form, {
				...form,
				children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("form", {
					onSubmit: form.handleSubmit(onSubmit),
					className: "space-y-4",
					children: [
						/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
							className: "grid grid-cols-1 md:grid-cols-2 gap-4",
							children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(FormField, {
								control: form.control,
								name: "date",
								render: ({ field }) => /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(FormItem, {
									className: "flex flex-col",
									children: [
										/* @__PURE__ */ (0, import_jsx_runtime.jsx)(FormLabel, { children: "Data *" }),
										/* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Popover, { children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(PopoverTrigger, {
											asChild: true,
											children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(FormControl, { children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Button, {
												variant: "outline",
												className: cn("w-full pl-3 text-left font-normal", !field.value && "text-muted-foreground"),
												children: [field.value ? format(field.value, "dd/MM/yyyy") : /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", { children: "Selecione a data" }), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Calendar, { className: "ml-auto h-4 w-4 opacity-50" })]
											}) })
										}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(PopoverContent, {
											className: "w-auto p-0",
											align: "start",
											children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Calendar$1, {
												mode: "single",
												selected: field.value,
												onSelect: field.onChange,
												disabled: (date$4) => date$4 > /* @__PURE__ */ new Date() || date$4 < /* @__PURE__ */ new Date("1900-01-01"),
												initialFocus: true
											})
										})] }),
										/* @__PURE__ */ (0, import_jsx_runtime.jsx)(FormMessage, {})
									]
								})
							}), /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
								className: "flex flex-col space-y-2",
								children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
									className: "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70 mt-3",
									children: "Dia da Semana"
								}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Input, {
									value: weekday ? weekday.charAt(0).toUpperCase() + weekday.slice(1) : "-",
									disabled: true,
									className: "bg-gray-50"
								})]
							})]
						}),
						/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
							className: "grid grid-cols-1 md:grid-cols-2 gap-4",
							children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(FormField, {
								control: form.control,
								name: "presenter",
								render: ({ field }) => /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(FormItem, { children: [
									/* @__PURE__ */ (0, import_jsx_runtime.jsx)(FormLabel, { children: "Apresentador *" }),
									/* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Select, {
										onValueChange: field.onChange,
										defaultValue: field.value,
										children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(FormControl, { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(SelectTrigger, { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(SelectValue, { placeholder: "Selecione..." }) }) }), /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(SelectContent, { children: [presenters.map((p) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(SelectItem, {
											value: p,
											children: p
										}, p)), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(SelectItem, {
											value: "other",
											children: "Outro (Novo)"
										})] })]
									}),
									/* @__PURE__ */ (0, import_jsx_runtime.jsx)(FormMessage, {})
								] })
							}), form.watch("presenter") === "other" && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(FormField, {
								control: form.control,
								name: "customPresenter",
								render: ({ field }) => /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(FormItem, { children: [
									/* @__PURE__ */ (0, import_jsx_runtime.jsx)(FormLabel, { children: "Nome do Apresentador *" }),
									/* @__PURE__ */ (0, import_jsx_runtime.jsx)(FormControl, { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Input, {
										placeholder: "Digite o nome...",
										...field
									}) }),
									/* @__PURE__ */ (0, import_jsx_runtime.jsx)(FormMessage, {})
								] })
							})]
						}),
						/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
							className: "grid grid-cols-2 gap-4",
							children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(FormField, {
								control: form.control,
								name: "peakViewers",
								render: ({ field }) => /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(FormItem, { children: [
									/* @__PURE__ */ (0, import_jsx_runtime.jsx)(FormLabel, { children: "Pico de Espectadores *" }),
									/* @__PURE__ */ (0, import_jsx_runtime.jsx)(FormControl, { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Input, {
										type: "number",
										...field
									}) }),
									/* @__PURE__ */ (0, import_jsx_runtime.jsx)(FormMessage, {})
								] })
							}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(FormField, {
								control: form.control,
								name: "retainedViewers",
								render: ({ field }) => /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(FormItem, { children: [
									/* @__PURE__ */ (0, import_jsx_runtime.jsx)(FormLabel, { children: "Espectadores Retidos *" }),
									/* @__PURE__ */ (0, import_jsx_runtime.jsx)(FormControl, { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Input, {
										type: "number",
										...field
									}) }),
									/* @__PURE__ */ (0, import_jsx_runtime.jsx)(FormMessage, {})
								] })
							})]
						}),
						/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
							className: "grid grid-cols-2 gap-4",
							children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(FormField, {
								control: form.control,
								name: "sales",
								render: ({ field }) => /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(FormItem, { children: [
									/* @__PURE__ */ (0, import_jsx_runtime.jsx)(FormLabel, { children: "N de Vendas *" }),
									/* @__PURE__ */ (0, import_jsx_runtime.jsx)(FormControl, { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Input, {
										type: "number",
										...field
									}) }),
									/* @__PURE__ */ (0, import_jsx_runtime.jsx)(FormMessage, {})
								] })
							}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(FormField, {
								control: form.control,
								name: "additionalSeats",
								render: ({ field }) => /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(FormItem, { children: [
									/* @__PURE__ */ (0, import_jsx_runtime.jsx)(FormLabel, { children: "Assentos Adicionais" }),
									/* @__PURE__ */ (0, import_jsx_runtime.jsx)(FormControl, { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Input, {
										type: "number",
										...field
									}) }),
									/* @__PURE__ */ (0, import_jsx_runtime.jsx)(FormMessage, {})
								] })
							})]
						}),
						/* @__PURE__ */ (0, import_jsx_runtime.jsx)(FormField, {
							control: form.control,
							name: "revenue",
							render: ({ field }) => /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(FormItem, { children: [
								/* @__PURE__ */ (0, import_jsx_runtime.jsx)(FormLabel, { children: "Faturamento (R$) *" }),
								/* @__PURE__ */ (0, import_jsx_runtime.jsx)(FormControl, { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Input, {
									...field,
									onChange: (e) => {
										handleRevenueChange(e);
										field.onChange(e);
									},
									placeholder: "0,00"
								}) }),
								/* @__PURE__ */ (0, import_jsx_runtime.jsx)(FormMessage, {})
							] })
						}),
						/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
							className: "rounded-lg border border-blue-100 bg-blue-50 p-4",
							children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("h4", {
								className: "mb-2 text-sm font-semibold text-blue-900",
								children: "Clculos em Tempo Real"
							}), /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
								className: "grid grid-cols-2 gap-4",
								children: [/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", { children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
									className: "text-xs text-blue-700",
									children: "Converso"
								}), /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("p", {
									className: "text-lg font-bold text-blue-900",
									children: [calculatedMetrics.conversion, "%"]
								})] }), /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", { children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
									className: "text-xs text-blue-700",
									children: "Reteno"
								}), /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("p", {
									className: "text-lg font-bold text-blue-900",
									children: [calculatedMetrics.retention, "%"]
								})] })]
							})]
						}),
						/* @__PURE__ */ (0, import_jsx_runtime.jsxs)(DialogFooter, { children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Button, {
							type: "button",
							variant: "outline",
							onClick: () => setOpen(false),
							disabled: isSubmitting,
							children: "Cancelar"
						}), /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Button, {
							type: "submit",
							disabled: isSubmitting,
							children: [isSubmitting && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(LoaderCircle, { className: "mr-2 h-4 w-4 animate-spin" }), isSubmitting ? "Salvando..." : "Salvar Live"]
						})] })
					]
				})
			})]
		})]
	});
}
var WEEKDAYS = [
	{
		label: "Seg",
		value: "Segunda-feira"
	},
	{
		label: "Ter",
		value: "Tera-feira"
	},
	{
		label: "Qua",
		value: "Quarta-feira"
	},
	{
		label: "Qui",
		value: "Quinta-feira"
	},
	{
		label: "Sex",
		value: "Sexta-feira"
	},
	{
		label: "Sb",
		value: "Sbado"
	},
	{
		label: "Dom",
		value: "Domingo"
	}
];
var DATE_PRESETS = [
	{
		label: "ltimos 30 Dias",
		value: "30days"
	},
	{
		label: "ltimos 3 Meses",
		value: "3months"
	},
	{
		label: "ltimos 6 Meses",
		value: "6months"
	},
	{
		label: "Ms Atual",
		value: "currentMonth"
	}
];
function LiveFilters({ presenters, onApply, onClear, loading, initialFilters }) {
	const [date$4, setDate] = (0, import_react.useState)(initialFilters?.dateRange);
	const [selectedPresenters, setSelectedPresenters] = (0, import_react.useState)(initialFilters?.presenters || []);
	const [selectedWeekdays, setSelectedWeekdays] = (0, import_react.useState)(initialFilters?.weekdays || []);
	const [comparisonEnabled, setComparisonEnabled] = (0, import_react.useState)(initialFilters?.comparisonEnabled || false);
	const [openPresenters, setOpenPresenters] = (0, import_react.useState)(false);
	const [selectedPreset, setSelectedPreset] = (0, import_react.useState)("30days");
	(0, import_react.useEffect)(() => {
		if (!initialFilters) handlePresetChange("30days");
	}, []);
	const handlePresetChange = (value) => {
		setSelectedPreset(value);
		const today = /* @__PURE__ */ new Date();
		let from;
		let to = today;
		switch (value) {
			case "30days":
				from = subDays(today, 30);
				break;
			case "3months":
				from = subMonths(today, 3);
				break;
			case "6months":
				from = subMonths(today, 6);
				break;
			case "currentMonth":
				from = startOfMonth(today);
				to = endOfMonth(today);
				break;
			default: return;
		}
		if (from && to) setDate({
			from,
			to
		});
	};
	const handleApply = () => {
		onApply({
			dateRange: date$4,
			presenters: selectedPresenters,
			weekdays: selectedWeekdays,
			comparisonEnabled: comparisonEnabled && !!date$4?.from && !!date$4?.to
		});
	};
	const handleClear = () => {
		handlePresetChange("30days");
		setSelectedPresenters([]);
		setSelectedWeekdays([]);
		setComparisonEnabled(false);
		onClear();
	};
	const togglePresenter = (presenter) => {
		setSelectedPresenters((prev) => prev.includes(presenter) ? prev.filter((p) => p !== presenter) : [...prev, presenter]);
	};
	const toggleWeekday = (value) => {
		setSelectedWeekdays((prev) => prev.includes(value) ? prev.filter((d) => d !== value) : [...prev, value]);
	};
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
		className: "mb-6 space-y-4 rounded-xl border bg-card p-5 shadow-sm",
		children: [/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
			className: "flex flex-col gap-6 md:flex-row md:items-start",
			children: [/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
				className: "grid flex-1 gap-4 md:grid-cols-2 lg:grid-cols-4",
				children: [
					/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
						className: "flex flex-col gap-2",
						children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("label", {
							className: "text-xs font-semibold text-muted-foreground uppercase",
							children: "Perodo Rpido"
						}), /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Select, {
							value: selectedPreset,
							onValueChange: handlePresetChange,
							children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(SelectTrigger, { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(SelectValue, { placeholder: "Selecione..." }) }), /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(SelectContent, { children: [DATE_PRESETS.map((preset) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(SelectItem, {
								value: preset.value,
								children: preset.label
							}, preset.value)), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(SelectItem, {
								value: "custom",
								children: "Personalizado"
							})] })]
						})]
					}),
					/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
						className: "flex flex-col gap-2",
						children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("label", {
							className: "text-xs font-semibold text-muted-foreground uppercase",
							children: "Intervalo de Datas"
						}), /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Popover, { children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(PopoverTrigger, {
							asChild: true,
							children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Button, {
								variant: "outline",
								className: cn("w-full justify-start text-left font-normal truncate", !date$4 && "text-muted-foreground"),
								onClick: () => setSelectedPreset("custom"),
								children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Calendar, { className: "mr-2 h-4 w-4 shrink-0" }), date$4?.from ? date$4.to ? /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("span", {
									className: "truncate",
									children: [
										format(date$4.from, "dd/MM/yy"),
										" -",
										" ",
										format(date$4.to, "dd/MM/yy")
									]
								}) : format(date$4.from, "dd/MM/yy") : /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", { children: "Selecione datas" })]
							})
						}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(PopoverContent, {
							className: "w-auto p-0",
							align: "start",
							children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Calendar$1, {
								initialFocus: true,
								mode: "range",
								defaultMonth: date$4?.from,
								selected: date$4,
								onSelect: (range$5) => {
									setDate(range$5);
									setSelectedPreset("custom");
								},
								numberOfMonths: 2,
								locale: ptBR
							})
						})] })]
					}),
					/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
						className: "flex flex-col gap-2",
						children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("label", {
							className: "text-xs font-semibold text-muted-foreground uppercase",
							children: "Apresentadores"
						}), /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Popover, {
							open: openPresenters,
							onOpenChange: setOpenPresenters,
							children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(PopoverTrigger, {
								asChild: true,
								children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Button, {
									variant: "outline",
									role: "combobox",
									"aria-expanded": openPresenters,
									className: "w-full justify-between",
									children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
										className: "truncate",
										children: selectedPresenters.length === 0 ? "Todos" : `${selectedPresenters.length} selecionado(s)`
									}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ChevronsUpDown, { className: "ml-2 h-4 w-4 shrink-0 opacity-50" })]
								})
							}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(PopoverContent, {
								className: "w-[220px] p-0",
								children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Command, { children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(CommandInput, { placeholder: "Buscar apresentador..." }), /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(CommandList, { children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(CommandEmpty, { children: "Nenhum apresentador." }), /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(CommandGroup, { children: [
									/* @__PURE__ */ (0, import_jsx_runtime.jsxs)(CommandItem, {
										onSelect: () => {
											if (selectedPresenters.length === presenters.length) setSelectedPresenters([]);
											else setSelectedPresenters([...presenters]);
										},
										children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
											className: cn("mr-2 flex h-4 w-4 items-center justify-center rounded-sm border border-primary", selectedPresenters.length === presenters.length && presenters.length > 0 ? "bg-primary text-primary-foreground" : "opacity-50 [&_svg]:invisible"),
											children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Check, { className: cn("h-4 w-4") })
										}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", { children: "Selecionar Todos" })]
									}),
									/* @__PURE__ */ (0, import_jsx_runtime.jsx)(CommandSeparator, { className: "my-1" }),
									presenters.map((presenter) => /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(CommandItem, {
										value: presenter,
										onSelect: () => togglePresenter(presenter),
										children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
											className: cn("mr-2 flex h-4 w-4 items-center justify-center rounded-sm border border-primary", selectedPresenters.includes(presenter) ? "bg-primary text-primary-foreground" : "opacity-50 [&_svg]:invisible"),
											children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Check, { className: cn("h-4 w-4") })
										}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", { children: presenter })]
									}, presenter))
								] })] })] })
							})]
						})]
					}),
					/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
						className: "flex flex-col gap-2",
						children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("label", {
							className: "text-xs font-semibold text-muted-foreground uppercase",
							children: "Dias da Semana"
						}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
							className: "flex flex-wrap gap-1",
							children: WEEKDAYS.map((day) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)("button", {
								onClick: () => toggleWeekday(day.value),
								className: cn("px-2 py-1 rounded text-[10px] font-medium transition-all border", selectedWeekdays.includes(day.value) ? "bg-primary text-primary-foreground border-primary" : "bg-background hover:bg-muted text-muted-foreground border-border"),
								children: day.label
							}, day.value))
						})]
					})
				]
			}), /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
				className: "flex flex-col gap-4 border-l pl-6 md:w-[240px]",
				children: [
					/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
						className: "flex items-center justify-between gap-2",
						children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("label", {
							className: "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70",
							children: "Comparar Perodo"
						}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Switch, {
							checked: comparisonEnabled,
							onCheckedChange: setComparisonEnabled,
							disabled: !date$4?.from || !date$4?.to
						})]
					}),
					/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Separator, {}),
					/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
						className: "flex flex-col gap-2",
						children: [/* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Button, {
							onClick: handleApply,
							disabled: loading || date$4?.from && date$4?.to && date$4.from > date$4.to,
							className: "w-full",
							children: [loading ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Search, { className: "mr-2 h-4 w-4 animate-spin" }) : /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Search, { className: "mr-2 h-4 w-4" }), "Aplicar Filtros"]
						}), /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Button, {
							onClick: handleClear,
							variant: "ghost",
							disabled: loading,
							className: "w-full",
							children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(FunnelX, { className: "mr-2 h-4 w-4" }), "Limpar Filtros"]
						})]
					})
				]
			})]
		}), comparisonEnabled && date$4?.from && date$4?.to && /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
			className: "flex items-center gap-2 rounded-lg bg-blue-50 p-2 text-sm text-blue-700",
			children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(ArrowRightLeft, { className: "h-4 w-4" }), /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("span", { children: [
				"Comparando",
				" ",
				/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("strong", { children: [
					format(date$4.from, "dd/MM"),
					" - ",
					format(date$4.to, "dd/MM")
				] }),
				" ",
				"com perodo anterior equivalente"
			] })]
		})]
	});
}
function LiveKPIs({ currentData, previousData, comparisonEnabled, loading }) {
	const sum = (data, key) => data.reduce((acc, curr) => acc + curr[key], 0);
	const avg = (data, key) => data.length ? sum(data, key) / data.length : 0;
	const totalRevenue = sum(currentData, "revenue");
	const totalSales = sum(currentData, "sales");
	const totalLives = currentData.length;
	const avgRevPerLive = totalLives ? totalRevenue / totalLives : 0;
	const avgConversion = avg(currentData, "conversionRate");
	const avgSalesPerLive = totalLives ? totalSales / totalLives : 0;
	const avgRetention = avg(currentData, "retentionRate");
	const daysMap = currentData.reduce((acc, curr) => {
		if (!acc[curr.weekday]) acc[curr.weekday] = {
			sum: 0,
			count: 0
		};
		acc[curr.weekday].sum += curr.conversionRate;
		acc[curr.weekday].count += 1;
		return acc;
	}, {});
	let bestDay = "N/A";
	let bestDayAvg = 0;
	Object.entries(daysMap).forEach(([day, stats]) => {
		const avgVal = stats.sum / stats.count;
		if (avgVal > bestDayAvg) {
			bestDayAvg = avgVal;
			bestDay = day;
		}
	});
	const maxSalesRecord = currentData.reduce((max$4, curr) => curr.sales > max$4.sales ? curr : max$4, { sales: 0 });
	const maxConvRecord = currentData.reduce((max$4, curr) => curr.conversionRate > max$4.conversionRate ? curr : max$4, { conversionRate: 0 });
	const getTrend = (current, previous) => {
		if (!comparisonEnabled || !previous) return void 0;
		return (current - previous) / previous * 100;
	};
	const prevRevenue = sum(previousData, "revenue");
	const prevSales = sum(previousData, "sales");
	const prevLives = previousData.length;
	const prevAvgRev = prevLives ? prevRevenue / prevLives : 0;
	const prevAvgConv = avg(previousData, "conversionRate");
	const prevAvgSales = prevLives ? prevSales / prevLives : 0;
	const prevAvgRet = avg(previousData, "retentionRate");
	const fmtMoney = (v) => `R$ ${v.toLocaleString("pt-BR", { maximumFractionDigits: 0 })}`;
	const fmtNum = (v) => v.toLocaleString("pt-BR");
	const fmtPct = (v) => `${v.toFixed(1)}%`;
	const items = [
		{
			id: "total-revenue",
			title: "Faturamento Total",
			icon: DollarSign,
			value: fmtMoney(totalRevenue),
			trend: getTrend(totalRevenue, prevRevenue),
			variant: "primary"
		},
		{
			id: "total-sales",
			title: "Total de Vendas",
			icon: ShoppingCart,
			value: fmtNum(totalSales),
			trend: getTrend(totalSales, prevSales)
		},
		{
			id: "avg-rev",
			title: "Fat. Mdio por Live",
			icon: TrendingUp,
			value: fmtMoney(avgRevPerLive),
			trend: getTrend(avgRevPerLive, prevAvgRev)
		},
		{
			id: "avg-conv",
			title: "Converso Mdia",
			icon: Percent,
			value: fmtPct(avgConversion),
			trend: getTrend(avgConversion, prevAvgConv)
		},
		{
			id: "best-day",
			title: "Melhor Dia",
			icon: CalendarCheck,
			value: bestDay,
			subValue: `Conv. mdia: ${fmtPct(bestDayAvg)}`
		},
		{
			id: "total-lives",
			title: "Total de Lives",
			icon: Video,
			value: totalLives,
			trend: getTrend(totalLives, prevLives)
		},
		{
			id: "avg-sales",
			title: "Mdia Vendas/Live",
			icon: ChartColumn,
			value: fmtNum(Math.round(avgSalesPerLive)),
			trend: getTrend(avgSalesPerLive, prevAvgSales)
		},
		{
			id: "avg-ret",
			title: "Reteno Mdia",
			icon: Users,
			value: fmtPct(avgRetention),
			trend: getTrend(avgRetention, prevAvgRet)
		},
		{
			id: "rec-sales",
			title: "Recorde Vendas",
			icon: Trophy,
			value: fmtNum(maxSalesRecord.sales || 0),
			subValue: maxSalesRecord.presenter ? `${maxSalesRecord.presenter}  ${format(new Date(maxSalesRecord.date), "dd/MM")}` : "-",
			variant: "accent"
		},
		{
			id: "rec-conv",
			title: "Recorde Converso",
			icon: Award,
			value: fmtPct(maxSalesRecord.sales ? maxConvRecord.conversionRate : 0),
			subValue: maxConvRecord.presenter ? `${maxConvRecord.presenter}  ${format(new Date(maxConvRecord.date), "dd/MM")}` : "-",
			variant: "accent"
		}
	];
	const goalProgress = Math.min(totalRevenue / 2e6 * 100, 100);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
		className: "grid grid-cols-1 gap-4 sm:grid-cols-2 lg:grid-cols-5",
		children: items.map((item) => /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Card, {
			className: cn("overflow-hidden transition-all hover:shadow-md relative", item.variant === "primary" && "border-blue-200 bg-blue-50/50 dark:bg-blue-950/20", item.variant === "accent" && "border-amber-200 bg-amber-50/50 dark:bg-amber-950/20"),
			children: [
				/* @__PURE__ */ (0, import_jsx_runtime.jsxs)(CardHeader, {
					className: "flex flex-row items-center justify-between space-y-0 pb-2 p-4",
					children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(CardTitle, {
						className: "text-xs font-medium text-muted-foreground uppercase tracking-wider",
						children: item.title
					}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(item.icon, { className: cn("h-4 w-4", item.variant === "primary" ? "text-blue-600" : item.variant === "accent" ? "text-amber-600" : "text-gray-500") })]
				}),
				/* @__PURE__ */ (0, import_jsx_runtime.jsx)(CardContent, {
					className: "p-4 pt-0",
					children: loading ? /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
						className: "space-y-2",
						children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Skeleton, { className: "h-7 w-20" }), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Skeleton, { className: "h-3 w-12" })]
					}) : /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
						/* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
							className: "text-2xl font-bold tracking-tight",
							children: item.value
						}),
						item.subValue && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("p", {
							className: "text-xs text-muted-foreground mt-1 truncate",
							title: item.subValue,
							children: item.subValue
						}),
						item.trend !== void 0 && /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
							className: "flex items-center mt-1",
							children: [/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("span", {
								className: cn("flex items-center text-xs font-medium", item.trend > 0 ? "text-emerald-600" : item.trend < 0 ? "text-red-600" : "text-gray-500"),
								children: [
									item.trend > 0 ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ArrowUp, { className: "mr-0.5 h-3 w-3" }) : item.trend < 0 ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ArrowDown, { className: "mr-0.5 h-3 w-3" }) : /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Minus, { className: "mr-0.5 h-3 w-3" }),
									Math.abs(item.trend).toFixed(1),
									"%"
								]
							}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
								className: "text-[10px] text-muted-foreground ml-1.5",
								children: "vs anterior"
							})]
						})
					] })
				}),
				item.id === "total-revenue" && !loading && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
					className: "absolute bottom-0 left-0 w-full h-1 bg-blue-100",
					children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
						className: "h-full bg-blue-500 transition-all duration-1000",
						style: { width: `${goalProgress}%` }
					})
				})
			]
		}, item.id))
	});
}
var require_isArray = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = Array.isArray;
}));
var require__freeGlobal = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = typeof global == "object" && global && global.Object === Object && global;
}));
var require__root = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var freeGlobal$1 = require__freeGlobal();
	var freeSelf = typeof self == "object" && self && self.Object === Object && self;
	module.exports = freeGlobal$1 || freeSelf || Function("return this")();
}));
var require__Symbol = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = require__root().Symbol;
}));
var require__getRawTag = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Symbol$6 = require__Symbol();
	var objectProto$4 = Object.prototype;
	var hasOwnProperty$11 = objectProto$4.hasOwnProperty;
	var nativeObjectToString$1 = objectProto$4.toString;
	var symToStringTag$1 = Symbol$6 ? Symbol$6.toStringTag : void 0;
	function getRawTag$1(value) {
		var isOwn = hasOwnProperty$11.call(value, symToStringTag$1), tag = value[symToStringTag$1];
		try {
			value[symToStringTag$1] = void 0;
			var unmasked = true;
		} catch (e) {}
		var result = nativeObjectToString$1.call(value);
		if (unmasked) if (isOwn) value[symToStringTag$1] = tag;
		else delete value[symToStringTag$1];
		return result;
	}
	module.exports = getRawTag$1;
}));
var require__objectToString = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var nativeObjectToString = Object.prototype.toString;
	function objectToString$1(value) {
		return nativeObjectToString.call(value);
	}
	module.exports = objectToString$1;
}));
var require__baseGetTag = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Symbol$5 = require__Symbol(), getRawTag = require__getRawTag(), objectToString = require__objectToString();
	var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
	var symToStringTag = Symbol$5 ? Symbol$5.toStringTag : void 0;
	function baseGetTag$9(value) {
		if (value == null) return value === void 0 ? undefinedTag : nullTag;
		return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
	}
	module.exports = baseGetTag$9;
}));
var require_isObjectLike = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function isObjectLike$9(value) {
		return value != null && typeof value == "object";
	}
	module.exports = isObjectLike$9;
}));
var require_isSymbol = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseGetTag$8 = require__baseGetTag(), isObjectLike$8 = require_isObjectLike();
	var symbolTag$1 = "[object Symbol]";
	function isSymbol$6(value) {
		return typeof value == "symbol" || isObjectLike$8(value) && baseGetTag$8(value) == symbolTag$1;
	}
	module.exports = isSymbol$6;
}));
var require__isKey = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var isArray$13 = require_isArray(), isSymbol$5 = require_isSymbol();
	var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
	function isKey$3(value, object$1) {
		if (isArray$13(value)) return false;
		var type = typeof value;
		if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol$5(value)) return true;
		return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object$1 != null && value in Object(object$1);
	}
	module.exports = isKey$3;
}));
var require_isObject = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function isObject$11(value) {
		var type = typeof value;
		return value != null && (type == "object" || type == "function");
	}
	module.exports = isObject$11;
}));
var require_isFunction = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseGetTag$7 = require__baseGetTag(), isObject$10 = require_isObject();
	var asyncTag = "[object AsyncFunction]", funcTag$1 = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
	function isFunction$21(value) {
		if (!isObject$10(value)) return false;
		var tag = baseGetTag$7(value);
		return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
	}
	module.exports = isFunction$21;
}));
var require__coreJsData = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = require__root()["__core-js_shared__"];
}));
var require__isMasked = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var coreJsData = require__coreJsData();
	var maskSrcKey = function() {
		var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
		return uid ? "Symbol(src)_1." + uid : "";
	}();
	function isMasked$1(func) {
		return !!maskSrcKey && maskSrcKey in func;
	}
	module.exports = isMasked$1;
}));
var require__toSource = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var funcToString$2 = Function.prototype.toString;
	function toSource$2(func) {
		if (func != null) {
			try {
				return funcToString$2.call(func);
			} catch (e) {}
			try {
				return func + "";
			} catch (e) {}
		}
		return "";
	}
	module.exports = toSource$2;
}));
var require__baseIsNative = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var isFunction$20 = require_isFunction(), isMasked = require__isMasked(), isObject$9 = require_isObject(), toSource$1 = require__toSource();
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
	var reIsHostCtor = /^\[object .+?Constructor\]$/;
	var funcProto$1 = Function.prototype, objectProto$3 = Object.prototype;
	var funcToString$1 = funcProto$1.toString;
	var hasOwnProperty$10 = objectProto$3.hasOwnProperty;
	var reIsNative = RegExp("^" + funcToString$1.call(hasOwnProperty$10).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
	function baseIsNative$1(value) {
		if (!isObject$9(value) || isMasked(value)) return false;
		return (isFunction$20(value) ? reIsNative : reIsHostCtor).test(toSource$1(value));
	}
	module.exports = baseIsNative$1;
}));
var require__getValue = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function getValue$1(object$1, key) {
		return object$1 == null ? void 0 : object$1[key];
	}
	module.exports = getValue$1;
}));
var require__getNative = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseIsNative = require__baseIsNative(), getValue = require__getValue();
	function getNative$1(object$1, key) {
		var value = getValue(object$1, key);
		return baseIsNative(value) ? value : void 0;
	}
	module.exports = getNative$1;
}));
var require__nativeCreate = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = require__getNative()(Object, "create");
}));
var require__hashClear = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var nativeCreate$3 = require__nativeCreate();
	function hashClear$1() {
		this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {};
		this.size = 0;
	}
	module.exports = hashClear$1;
}));
var require__hashDelete = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function hashDelete$1(key) {
		var result = this.has(key) && delete this.__data__[key];
		this.size -= result ? 1 : 0;
		return result;
	}
	module.exports = hashDelete$1;
}));
var require__hashGet = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var nativeCreate$2 = require__nativeCreate();
	var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
	var hasOwnProperty$9 = Object.prototype.hasOwnProperty;
	function hashGet$1(key) {
		var data = this.__data__;
		if (nativeCreate$2) {
			var result = data[key];
			return result === HASH_UNDEFINED$2 ? void 0 : result;
		}
		return hasOwnProperty$9.call(data, key) ? data[key] : void 0;
	}
	module.exports = hashGet$1;
}));
var require__hashHas = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var nativeCreate$1 = require__nativeCreate();
	var hasOwnProperty$8 = Object.prototype.hasOwnProperty;
	function hashHas$1(key) {
		var data = this.__data__;
		return nativeCreate$1 ? data[key] !== void 0 : hasOwnProperty$8.call(data, key);
	}
	module.exports = hashHas$1;
}));
var require__hashSet = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var nativeCreate = require__nativeCreate();
	var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
	function hashSet$1(key, value) {
		var data = this.__data__;
		this.size += this.has(key) ? 0 : 1;
		data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED$1 : value;
		return this;
	}
	module.exports = hashSet$1;
}));
var require__Hash = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var hashClear = require__hashClear(), hashDelete = require__hashDelete(), hashGet = require__hashGet(), hashHas = require__hashHas(), hashSet = require__hashSet();
	function Hash$1(entries) {
		var index = -1, length = entries == null ? 0 : entries.length;
		this.clear();
		while (++index < length) {
			var entry = entries[index];
			this.set(entry[0], entry[1]);
		}
	}
	Hash$1.prototype.clear = hashClear;
	Hash$1.prototype["delete"] = hashDelete;
	Hash$1.prototype.get = hashGet;
	Hash$1.prototype.has = hashHas;
	Hash$1.prototype.set = hashSet;
	module.exports = Hash$1;
}));
var require__listCacheClear = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function listCacheClear$1() {
		this.__data__ = [];
		this.size = 0;
	}
	module.exports = listCacheClear$1;
}));
var require_eq = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function eq$3(value, other) {
		return value === other || value !== value && other !== other;
	}
	module.exports = eq$3;
}));
var require__assocIndexOf = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var eq$2 = require_eq();
	function assocIndexOf$4(array$1, key) {
		var length = array$1.length;
		while (length--) if (eq$2(array$1[length][0], key)) return length;
		return -1;
	}
	module.exports = assocIndexOf$4;
}));
var require__listCacheDelete = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var assocIndexOf$3 = require__assocIndexOf();
	var splice = Array.prototype.splice;
	function listCacheDelete$1(key) {
		var data = this.__data__, index = assocIndexOf$3(data, key);
		if (index < 0) return false;
		if (index == data.length - 1) data.pop();
		else splice.call(data, index, 1);
		--this.size;
		return true;
	}
	module.exports = listCacheDelete$1;
}));
var require__listCacheGet = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var assocIndexOf$2 = require__assocIndexOf();
	function listCacheGet$1(key) {
		var data = this.__data__, index = assocIndexOf$2(data, key);
		return index < 0 ? void 0 : data[index][1];
	}
	module.exports = listCacheGet$1;
}));
var require__listCacheHas = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var assocIndexOf$1 = require__assocIndexOf();
	function listCacheHas$1(key) {
		return assocIndexOf$1(this.__data__, key) > -1;
	}
	module.exports = listCacheHas$1;
}));
var require__listCacheSet = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var assocIndexOf = require__assocIndexOf();
	function listCacheSet$1(key, value) {
		var data = this.__data__, index = assocIndexOf(data, key);
		if (index < 0) {
			++this.size;
			data.push([key, value]);
		} else data[index][1] = value;
		return this;
	}
	module.exports = listCacheSet$1;
}));
var require__ListCache = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var listCacheClear = require__listCacheClear(), listCacheDelete = require__listCacheDelete(), listCacheGet = require__listCacheGet(), listCacheHas = require__listCacheHas(), listCacheSet = require__listCacheSet();
	function ListCache$4(entries) {
		var index = -1, length = entries == null ? 0 : entries.length;
		this.clear();
		while (++index < length) {
			var entry = entries[index];
			this.set(entry[0], entry[1]);
		}
	}
	ListCache$4.prototype.clear = listCacheClear;
	ListCache$4.prototype["delete"] = listCacheDelete;
	ListCache$4.prototype.get = listCacheGet;
	ListCache$4.prototype.has = listCacheHas;
	ListCache$4.prototype.set = listCacheSet;
	module.exports = ListCache$4;
}));
var require__Map = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = require__getNative()(require__root(), "Map");
}));
var require__mapCacheClear = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Hash = require__Hash(), ListCache$3 = require__ListCache(), Map$3 = require__Map();
	function mapCacheClear$1() {
		this.size = 0;
		this.__data__ = {
			"hash": new Hash(),
			"map": new (Map$3 || ListCache$3)(),
			"string": new Hash()
		};
	}
	module.exports = mapCacheClear$1;
}));
var require__isKeyable = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function isKeyable$1(value) {
		var type = typeof value;
		return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
	}
	module.exports = isKeyable$1;
}));
var require__getMapData = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var isKeyable = require__isKeyable();
	function getMapData$4(map$4, key) {
		var data = map$4.__data__;
		return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
	}
	module.exports = getMapData$4;
}));
var require__mapCacheDelete = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var getMapData$3 = require__getMapData();
	function mapCacheDelete$1(key) {
		var result = getMapData$3(this, key)["delete"](key);
		this.size -= result ? 1 : 0;
		return result;
	}
	module.exports = mapCacheDelete$1;
}));
var require__mapCacheGet = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var getMapData$2 = require__getMapData();
	function mapCacheGet$1(key) {
		return getMapData$2(this, key).get(key);
	}
	module.exports = mapCacheGet$1;
}));
var require__mapCacheHas = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var getMapData$1 = require__getMapData();
	function mapCacheHas$1(key) {
		return getMapData$1(this, key).has(key);
	}
	module.exports = mapCacheHas$1;
}));
var require__mapCacheSet = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var getMapData = require__getMapData();
	function mapCacheSet$1(key, value) {
		var data = getMapData(this, key), size = data.size;
		data.set(key, value);
		this.size += data.size == size ? 0 : 1;
		return this;
	}
	module.exports = mapCacheSet$1;
}));
var require__MapCache = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var mapCacheClear = require__mapCacheClear(), mapCacheDelete = require__mapCacheDelete(), mapCacheGet = require__mapCacheGet(), mapCacheHas = require__mapCacheHas(), mapCacheSet = require__mapCacheSet();
	function MapCache$3(entries) {
		var index = -1, length = entries == null ? 0 : entries.length;
		this.clear();
		while (++index < length) {
			var entry = entries[index];
			this.set(entry[0], entry[1]);
		}
	}
	MapCache$3.prototype.clear = mapCacheClear;
	MapCache$3.prototype["delete"] = mapCacheDelete;
	MapCache$3.prototype.get = mapCacheGet;
	MapCache$3.prototype.has = mapCacheHas;
	MapCache$3.prototype.set = mapCacheSet;
	module.exports = MapCache$3;
}));
var require_memoize = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var MapCache$2 = require__MapCache();
	var FUNC_ERROR_TEXT$2 = "Expected a function";
	function memoize$3(func, resolver) {
		if (typeof func != "function" || resolver != null && typeof resolver != "function") throw new TypeError(FUNC_ERROR_TEXT$2);
		var memoized = function() {
			var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
			if (cache.has(key)) return cache.get(key);
			var result = func.apply(this, args);
			memoized.cache = cache.set(key, result) || cache;
			return result;
		};
		memoized.cache = new (memoize$3.Cache || MapCache$2)();
		return memoized;
	}
	memoize$3.Cache = MapCache$2;
	module.exports = memoize$3;
}));
var require__memoizeCapped = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var memoize$2 = require_memoize();
	var MAX_MEMOIZE_SIZE = 500;
	function memoizeCapped$1(func) {
		var result = memoize$2(func, function(key) {
			if (cache.size === MAX_MEMOIZE_SIZE) cache.clear();
			return key;
		});
		var cache = result.cache;
		return result;
	}
	module.exports = memoizeCapped$1;
}));
var require__stringToPath = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var memoizeCapped = require__memoizeCapped();
	var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
	var reEscapeChar = /\\(\\)?/g;
	module.exports = memoizeCapped(function(string$2) {
		var result = [];
		if (string$2.charCodeAt(0) === 46) result.push("");
		string$2.replace(rePropName, function(match, number$5, quote, subString) {
			result.push(quote ? subString.replace(reEscapeChar, "$1") : number$5 || match);
		});
		return result;
	});
}));
var require__arrayMap = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function arrayMap$3(array$1, iteratee) {
		var index = -1, length = array$1 == null ? 0 : array$1.length, result = Array(length);
		while (++index < length) result[index] = iteratee(array$1[index], index, array$1);
		return result;
	}
	module.exports = arrayMap$3;
}));
var require__baseToString = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Symbol$4 = require__Symbol(), arrayMap$2 = require__arrayMap(), isArray$12 = require_isArray(), isSymbol$4 = require_isSymbol();
	var INFINITY$2 = Infinity;
	var symbolProto$1 = Symbol$4 ? Symbol$4.prototype : void 0, symbolToString = symbolProto$1 ? symbolProto$1.toString : void 0;
	function baseToString$1(value) {
		if (typeof value == "string") return value;
		if (isArray$12(value)) return arrayMap$2(value, baseToString$1) + "";
		if (isSymbol$4(value)) return symbolToString ? symbolToString.call(value) : "";
		var result = value + "";
		return result == "0" && 1 / value == -INFINITY$2 ? "-0" : result;
	}
	module.exports = baseToString$1;
}));
var require_toString = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseToString = require__baseToString();
	function toString$3(value) {
		return value == null ? "" : baseToString(value);
	}
	module.exports = toString$3;
}));
var require__castPath = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var isArray$11 = require_isArray(), isKey$2 = require__isKey(), stringToPath = require__stringToPath(), toString$2 = require_toString();
	function castPath$2(value, object$1) {
		if (isArray$11(value)) return value;
		return isKey$2(value, object$1) ? [value] : stringToPath(toString$2(value));
	}
	module.exports = castPath$2;
}));
var require__toKey = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var isSymbol$3 = require_isSymbol();
	var INFINITY$1 = Infinity;
	function toKey$4(value) {
		if (typeof value == "string" || isSymbol$3(value)) return value;
		var result = value + "";
		return result == "0" && 1 / value == -INFINITY$1 ? "-0" : result;
	}
	module.exports = toKey$4;
}));
var require__baseGet = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var castPath$1 = require__castPath(), toKey$3 = require__toKey();
	function baseGet$3(object$1, path$1) {
		path$1 = castPath$1(path$1, object$1);
		var index = 0, length = path$1.length;
		while (object$1 != null && index < length) object$1 = object$1[toKey$3(path$1[index++])];
		return index && index == length ? object$1 : void 0;
	}
	module.exports = baseGet$3;
}));
var require_get = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseGet$2 = require__baseGet();
	function get$6(object$1, path$1, defaultValue) {
		var result = object$1 == null ? void 0 : baseGet$2(object$1, path$1);
		return result === void 0 ? defaultValue : result;
	}
	module.exports = get$6;
}));
var require_isNil = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function isNil$12(value) {
		return value == null;
	}
	module.exports = isNil$12;
}));
var require_isString = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseGetTag$6 = require__baseGetTag(), isArray$10 = require_isArray(), isObjectLike$7 = require_isObjectLike();
	var stringTag$2 = "[object String]";
	function isString$3(value) {
		return typeof value == "string" || !isArray$10(value) && isObjectLike$7(value) && baseGetTag$6(value) == stringTag$2;
	}
	module.exports = isString$3;
}));
/**
* @license React
* react-is.development.js
*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
var require_react_is_development$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	(function() {
		"use strict";
		var REACT_ELEMENT_TYPE = Symbol.for("react.element");
		var REACT_PORTAL_TYPE = Symbol.for("react.portal");
		var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
		var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
		var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
		var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
		var REACT_CONTEXT_TYPE = Symbol.for("react.context");
		var REACT_SERVER_CONTEXT_TYPE = Symbol.for("react.server_context");
		var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
		var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
		var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
		var REACT_MEMO_TYPE = Symbol.for("react.memo");
		var REACT_LAZY_TYPE = Symbol.for("react.lazy");
		var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
		var enableScopeAPI = false;
		var enableCacheElement = false;
		var enableTransitionTracing = false;
		var enableLegacyHidden = false;
		var enableDebugTracing = false;
		var REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
		function isValidElementType(type) {
			if (typeof type === "string" || typeof type === "function") return true;
			if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) return true;
			if (typeof type === "object" && type !== null) {
				if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) return true;
			}
			return false;
		}
		function typeOf(object$1) {
			if (typeof object$1 === "object" && object$1 !== null) {
				var $$typeof = object$1.$$typeof;
				switch ($$typeof) {
					case REACT_ELEMENT_TYPE:
						var type = object$1.type;
						switch (type) {
							case REACT_FRAGMENT_TYPE:
							case REACT_PROFILER_TYPE:
							case REACT_STRICT_MODE_TYPE:
							case REACT_SUSPENSE_TYPE:
							case REACT_SUSPENSE_LIST_TYPE: return type;
							default:
								var $$typeofType = type && type.$$typeof;
								switch ($$typeofType) {
									case REACT_SERVER_CONTEXT_TYPE:
									case REACT_CONTEXT_TYPE:
									case REACT_FORWARD_REF_TYPE:
									case REACT_LAZY_TYPE:
									case REACT_MEMO_TYPE:
									case REACT_PROVIDER_TYPE: return $$typeofType;
									default: return $$typeof;
								}
						}
					case REACT_PORTAL_TYPE: return $$typeof;
				}
			}
		}
		var ContextConsumer = REACT_CONTEXT_TYPE;
		var ContextProvider = REACT_PROVIDER_TYPE;
		var Element = REACT_ELEMENT_TYPE;
		var ForwardRef = REACT_FORWARD_REF_TYPE;
		var Fragment = REACT_FRAGMENT_TYPE;
		var Lazy = REACT_LAZY_TYPE;
		var Memo = REACT_MEMO_TYPE;
		var Portal = REACT_PORTAL_TYPE;
		var Profiler = REACT_PROFILER_TYPE;
		var StrictMode = REACT_STRICT_MODE_TYPE;
		var Suspense = REACT_SUSPENSE_TYPE;
		var SuspenseList = REACT_SUSPENSE_LIST_TYPE;
		var hasWarnedAboutDeprecatedIsAsyncMode = false;
		var hasWarnedAboutDeprecatedIsConcurrentMode = false;
		function isAsyncMode(object$1) {
			if (!hasWarnedAboutDeprecatedIsAsyncMode) {
				hasWarnedAboutDeprecatedIsAsyncMode = true;
				console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.");
			}
			return false;
		}
		function isConcurrentMode(object$1) {
			if (!hasWarnedAboutDeprecatedIsConcurrentMode) {
				hasWarnedAboutDeprecatedIsConcurrentMode = true;
				console["warn"]("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.");
			}
			return false;
		}
		function isContextConsumer(object$1) {
			return typeOf(object$1) === REACT_CONTEXT_TYPE;
		}
		function isContextProvider(object$1) {
			return typeOf(object$1) === REACT_PROVIDER_TYPE;
		}
		function isElement(object$1) {
			return typeof object$1 === "object" && object$1 !== null && object$1.$$typeof === REACT_ELEMENT_TYPE;
		}
		function isForwardRef(object$1) {
			return typeOf(object$1) === REACT_FORWARD_REF_TYPE;
		}
		function isFragment$1(object$1) {
			return typeOf(object$1) === REACT_FRAGMENT_TYPE;
		}
		function isLazy(object$1) {
			return typeOf(object$1) === REACT_LAZY_TYPE;
		}
		function isMemo(object$1) {
			return typeOf(object$1) === REACT_MEMO_TYPE;
		}
		function isPortal(object$1) {
			return typeOf(object$1) === REACT_PORTAL_TYPE;
		}
		function isProfiler(object$1) {
			return typeOf(object$1) === REACT_PROFILER_TYPE;
		}
		function isStrictMode(object$1) {
			return typeOf(object$1) === REACT_STRICT_MODE_TYPE;
		}
		function isSuspense(object$1) {
			return typeOf(object$1) === REACT_SUSPENSE_TYPE;
		}
		function isSuspenseList(object$1) {
			return typeOf(object$1) === REACT_SUSPENSE_LIST_TYPE;
		}
		exports.ContextConsumer = ContextConsumer;
		exports.ContextProvider = ContextProvider;
		exports.Element = Element;
		exports.ForwardRef = ForwardRef;
		exports.Fragment = Fragment;
		exports.Lazy = Lazy;
		exports.Memo = Memo;
		exports.Portal = Portal;
		exports.Profiler = Profiler;
		exports.StrictMode = StrictMode;
		exports.Suspense = Suspense;
		exports.SuspenseList = SuspenseList;
		exports.isAsyncMode = isAsyncMode;
		exports.isConcurrentMode = isConcurrentMode;
		exports.isContextConsumer = isContextConsumer;
		exports.isContextProvider = isContextProvider;
		exports.isElement = isElement;
		exports.isForwardRef = isForwardRef;
		exports.isFragment = isFragment$1;
		exports.isLazy = isLazy;
		exports.isMemo = isMemo;
		exports.isPortal = isPortal;
		exports.isProfiler = isProfiler;
		exports.isStrictMode = isStrictMode;
		exports.isSuspense = isSuspense;
		exports.isSuspenseList = isSuspenseList;
		exports.isValidElementType = isValidElementType;
		exports.typeOf = typeOf;
	})();
}));
var require_react_is$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = require_react_is_development$1();
}));
var require_isNumber = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseGetTag$5 = require__baseGetTag(), isObjectLike$6 = require_isObjectLike();
	var numberTag$2 = "[object Number]";
	function isNumber$2(value) {
		return typeof value == "number" || isObjectLike$6(value) && baseGetTag$5(value) == numberTag$2;
	}
	module.exports = isNumber$2;
}));
var require_isNaN = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var isNumber$1 = require_isNumber();
	function isNaN$1(value) {
		return isNumber$1(value) && value != +value;
	}
	module.exports = isNaN$1;
}));
var import_isString$2 = /* @__PURE__ */ __toESM(require_isString());
var import_isNaN$2 = /* @__PURE__ */ __toESM(require_isNaN());
var import_get$4 = /* @__PURE__ */ __toESM(require_get());
var import_isNumber = /* @__PURE__ */ __toESM(require_isNumber());
var import_isNil$11 = /* @__PURE__ */ __toESM(require_isNil());
var mathSign = function mathSign$1(value) {
	if (value === 0) return 0;
	if (value > 0) return 1;
	return -1;
};
var isPercent = function isPercent$1(value) {
	return (0, import_isString$2.default)(value) && value.indexOf("%") === value.length - 1;
};
var isNumber = function isNumber$3(value) {
	return (0, import_isNumber.default)(value) && !(0, import_isNaN$2.default)(value);
};
var isNullish = function isNullish$1(value) {
	return (0, import_isNil$11.default)(value);
};
var isNumOrStr = function isNumOrStr$1(value) {
	return isNumber(value) || (0, import_isString$2.default)(value);
};
var idCounter = 0;
var uniqueId = function uniqueId$1(prefix$2) {
	var id = ++idCounter;
	return "".concat(prefix$2 || "").concat(id);
};
var getPercentValue = function getPercentValue$1(percent, totalValue) {
	var defaultValue = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
	var validate = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
	if (!isNumber(percent) && !(0, import_isString$2.default)(percent)) return defaultValue;
	var value;
	if (isPercent(percent)) {
		var index = percent.indexOf("%");
		value = totalValue * parseFloat(percent.slice(0, index)) / 100;
	} else value = +percent;
	if ((0, import_isNaN$2.default)(value)) value = defaultValue;
	if (validate && value > totalValue) value = totalValue;
	return value;
};
var getAnyElementOfObject = function getAnyElementOfObject$1(obj) {
	if (!obj) return null;
	var keys$6 = Object.keys(obj);
	if (keys$6 && keys$6.length) return obj[keys$6[0]];
	return null;
};
var hasDuplicate = function hasDuplicate$1(ary) {
	if (!Array.isArray(ary)) return false;
	var len = ary.length;
	var cache = {};
	for (var i$2 = 0; i$2 < len; i$2++) if (!cache[ary[i$2]]) cache[ary[i$2]] = true;
	else return true;
	return false;
};
var interpolateNumber = function interpolateNumber$2(numberA, numberB) {
	if (isNumber(numberA) && isNumber(numberB)) return function(t$1) {
		return numberA + t$1 * (numberB - numberA);
	};
	return function() {
		return numberB;
	};
};
function findEntryInArray(ary, specifiedKey, specifiedValue) {
	if (!ary || !ary.length) return null;
	return ary.find(function(entry) {
		return entry && (typeof specifiedKey === "function" ? specifiedKey(entry) : (0, import_get$4.default)(entry, specifiedKey)) === specifiedValue;
	});
}
var compareValues = function compareValues$1(a$2, b) {
	if (isNumber(a$2) && isNumber(b)) return a$2 - b;
	if ((0, import_isString$2.default)(a$2) && (0, import_isString$2.default)(b)) return a$2.localeCompare(b);
	if (a$2 instanceof Date && b instanceof Date) return a$2.getTime() - b.getTime();
	return String(a$2).localeCompare(String(b));
};
function shallowEqual(a$2, b) {
	for (var key in a$2) if ({}.hasOwnProperty.call(a$2, key) && (!{}.hasOwnProperty.call(b, key) || a$2[key] !== b[key])) return false;
	for (var _key in b) if ({}.hasOwnProperty.call(b, _key) && !{}.hasOwnProperty.call(a$2, _key)) return false;
	return true;
}
var import_isObject$3 = /* @__PURE__ */ __toESM(require_isObject());
function _typeof$46(o$1) {
	"@babel/helpers - typeof";
	return _typeof$46 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$2) {
		return typeof o$2;
	} : function(o$2) {
		return o$2 && "function" == typeof Symbol && o$2.constructor === Symbol && o$2 !== Symbol.prototype ? "symbol" : typeof o$2;
	}, _typeof$46(o$1);
}
var SVGContainerPropKeys = ["viewBox", "children"];
var SVGElementPropKeys = [
	"aria-activedescendant",
	"aria-atomic",
	"aria-autocomplete",
	"aria-busy",
	"aria-checked",
	"aria-colcount",
	"aria-colindex",
	"aria-colspan",
	"aria-controls",
	"aria-current",
	"aria-describedby",
	"aria-details",
	"aria-disabled",
	"aria-errormessage",
	"aria-expanded",
	"aria-flowto",
	"aria-haspopup",
	"aria-hidden",
	"aria-invalid",
	"aria-keyshortcuts",
	"aria-label",
	"aria-labelledby",
	"aria-level",
	"aria-live",
	"aria-modal",
	"aria-multiline",
	"aria-multiselectable",
	"aria-orientation",
	"aria-owns",
	"aria-placeholder",
	"aria-posinset",
	"aria-pressed",
	"aria-readonly",
	"aria-relevant",
	"aria-required",
	"aria-roledescription",
	"aria-rowcount",
	"aria-rowindex",
	"aria-rowspan",
	"aria-selected",
	"aria-setsize",
	"aria-sort",
	"aria-valuemax",
	"aria-valuemin",
	"aria-valuenow",
	"aria-valuetext",
	"className",
	"color",
	"height",
	"id",
	"lang",
	"max",
	"media",
	"method",
	"min",
	"name",
	"style",
	"target",
	"width",
	"role",
	"tabIndex",
	"accentHeight",
	"accumulate",
	"additive",
	"alignmentBaseline",
	"allowReorder",
	"alphabetic",
	"amplitude",
	"arabicForm",
	"ascent",
	"attributeName",
	"attributeType",
	"autoReverse",
	"azimuth",
	"baseFrequency",
	"baselineShift",
	"baseProfile",
	"bbox",
	"begin",
	"bias",
	"by",
	"calcMode",
	"capHeight",
	"clip",
	"clipPath",
	"clipPathUnits",
	"clipRule",
	"colorInterpolation",
	"colorInterpolationFilters",
	"colorProfile",
	"colorRendering",
	"contentScriptType",
	"contentStyleType",
	"cursor",
	"cx",
	"cy",
	"d",
	"decelerate",
	"descent",
	"diffuseConstant",
	"direction",
	"display",
	"divisor",
	"dominantBaseline",
	"dur",
	"dx",
	"dy",
	"edgeMode",
	"elevation",
	"enableBackground",
	"end",
	"exponent",
	"externalResourcesRequired",
	"fill",
	"fillOpacity",
	"fillRule",
	"filter",
	"filterRes",
	"filterUnits",
	"floodColor",
	"floodOpacity",
	"focusable",
	"fontFamily",
	"fontSize",
	"fontSizeAdjust",
	"fontStretch",
	"fontStyle",
	"fontVariant",
	"fontWeight",
	"format",
	"from",
	"fx",
	"fy",
	"g1",
	"g2",
	"glyphName",
	"glyphOrientationHorizontal",
	"glyphOrientationVertical",
	"glyphRef",
	"gradientTransform",
	"gradientUnits",
	"hanging",
	"horizAdvX",
	"horizOriginX",
	"href",
	"ideographic",
	"imageRendering",
	"in2",
	"in",
	"intercept",
	"k1",
	"k2",
	"k3",
	"k4",
	"k",
	"kernelMatrix",
	"kernelUnitLength",
	"kerning",
	"keyPoints",
	"keySplines",
	"keyTimes",
	"lengthAdjust",
	"letterSpacing",
	"lightingColor",
	"limitingConeAngle",
	"local",
	"markerEnd",
	"markerHeight",
	"markerMid",
	"markerStart",
	"markerUnits",
	"markerWidth",
	"mask",
	"maskContentUnits",
	"maskUnits",
	"mathematical",
	"mode",
	"numOctaves",
	"offset",
	"opacity",
	"operator",
	"order",
	"orient",
	"orientation",
	"origin",
	"overflow",
	"overlinePosition",
	"overlineThickness",
	"paintOrder",
	"panose1",
	"pathLength",
	"patternContentUnits",
	"patternTransform",
	"patternUnits",
	"pointerEvents",
	"pointsAtX",
	"pointsAtY",
	"pointsAtZ",
	"preserveAlpha",
	"preserveAspectRatio",
	"primitiveUnits",
	"r",
	"radius",
	"refX",
	"refY",
	"renderingIntent",
	"repeatCount",
	"repeatDur",
	"requiredExtensions",
	"requiredFeatures",
	"restart",
	"result",
	"rotate",
	"rx",
	"ry",
	"seed",
	"shapeRendering",
	"slope",
	"spacing",
	"specularConstant",
	"specularExponent",
	"speed",
	"spreadMethod",
	"startOffset",
	"stdDeviation",
	"stemh",
	"stemv",
	"stitchTiles",
	"stopColor",
	"stopOpacity",
	"strikethroughPosition",
	"strikethroughThickness",
	"string",
	"stroke",
	"strokeDasharray",
	"strokeDashoffset",
	"strokeLinecap",
	"strokeLinejoin",
	"strokeMiterlimit",
	"strokeOpacity",
	"strokeWidth",
	"surfaceScale",
	"systemLanguage",
	"tableValues",
	"targetX",
	"targetY",
	"textAnchor",
	"textDecoration",
	"textLength",
	"textRendering",
	"to",
	"transform",
	"u1",
	"u2",
	"underlinePosition",
	"underlineThickness",
	"unicode",
	"unicodeBidi",
	"unicodeRange",
	"unitsPerEm",
	"vAlphabetic",
	"values",
	"vectorEffect",
	"version",
	"vertAdvY",
	"vertOriginX",
	"vertOriginY",
	"vHanging",
	"vIdeographic",
	"viewTarget",
	"visibility",
	"vMathematical",
	"widths",
	"wordSpacing",
	"writingMode",
	"x1",
	"x2",
	"x",
	"xChannelSelector",
	"xHeight",
	"xlinkActuate",
	"xlinkArcrole",
	"xlinkHref",
	"xlinkRole",
	"xlinkShow",
	"xlinkTitle",
	"xlinkType",
	"xmlBase",
	"xmlLang",
	"xmlns",
	"xmlnsXlink",
	"xmlSpace",
	"y1",
	"y2",
	"y",
	"yChannelSelector",
	"z",
	"zoomAndPan",
	"ref",
	"key",
	"angle"
];
var PolyElementKeys = ["points", "pathLength"];
var FilteredElementKeyMap = {
	svg: SVGContainerPropKeys,
	polygon: PolyElementKeys,
	polyline: PolyElementKeys
};
var EventKeys = [
	"dangerouslySetInnerHTML",
	"onCopy",
	"onCopyCapture",
	"onCut",
	"onCutCapture",
	"onPaste",
	"onPasteCapture",
	"onCompositionEnd",
	"onCompositionEndCapture",
	"onCompositionStart",
	"onCompositionStartCapture",
	"onCompositionUpdate",
	"onCompositionUpdateCapture",
	"onFocus",
	"onFocusCapture",
	"onBlur",
	"onBlurCapture",
	"onChange",
	"onChangeCapture",
	"onBeforeInput",
	"onBeforeInputCapture",
	"onInput",
	"onInputCapture",
	"onReset",
	"onResetCapture",
	"onSubmit",
	"onSubmitCapture",
	"onInvalid",
	"onInvalidCapture",
	"onLoad",
	"onLoadCapture",
	"onError",
	"onErrorCapture",
	"onKeyDown",
	"onKeyDownCapture",
	"onKeyPress",
	"onKeyPressCapture",
	"onKeyUp",
	"onKeyUpCapture",
	"onAbort",
	"onAbortCapture",
	"onCanPlay",
	"onCanPlayCapture",
	"onCanPlayThrough",
	"onCanPlayThroughCapture",
	"onDurationChange",
	"onDurationChangeCapture",
	"onEmptied",
	"onEmptiedCapture",
	"onEncrypted",
	"onEncryptedCapture",
	"onEnded",
	"onEndedCapture",
	"onLoadedData",
	"onLoadedDataCapture",
	"onLoadedMetadata",
	"onLoadedMetadataCapture",
	"onLoadStart",
	"onLoadStartCapture",
	"onPause",
	"onPauseCapture",
	"onPlay",
	"onPlayCapture",
	"onPlaying",
	"onPlayingCapture",
	"onProgress",
	"onProgressCapture",
	"onRateChange",
	"onRateChangeCapture",
	"onSeeked",
	"onSeekedCapture",
	"onSeeking",
	"onSeekingCapture",
	"onStalled",
	"onStalledCapture",
	"onSuspend",
	"onSuspendCapture",
	"onTimeUpdate",
	"onTimeUpdateCapture",
	"onVolumeChange",
	"onVolumeChangeCapture",
	"onWaiting",
	"onWaitingCapture",
	"onAuxClick",
	"onAuxClickCapture",
	"onClick",
	"onClickCapture",
	"onContextMenu",
	"onContextMenuCapture",
	"onDoubleClick",
	"onDoubleClickCapture",
	"onDrag",
	"onDragCapture",
	"onDragEnd",
	"onDragEndCapture",
	"onDragEnter",
	"onDragEnterCapture",
	"onDragExit",
	"onDragExitCapture",
	"onDragLeave",
	"onDragLeaveCapture",
	"onDragOver",
	"onDragOverCapture",
	"onDragStart",
	"onDragStartCapture",
	"onDrop",
	"onDropCapture",
	"onMouseDown",
	"onMouseDownCapture",
	"onMouseEnter",
	"onMouseLeave",
	"onMouseMove",
	"onMouseMoveCapture",
	"onMouseOut",
	"onMouseOutCapture",
	"onMouseOver",
	"onMouseOverCapture",
	"onMouseUp",
	"onMouseUpCapture",
	"onSelect",
	"onSelectCapture",
	"onTouchCancel",
	"onTouchCancelCapture",
	"onTouchEnd",
	"onTouchEndCapture",
	"onTouchMove",
	"onTouchMoveCapture",
	"onTouchStart",
	"onTouchStartCapture",
	"onPointerDown",
	"onPointerDownCapture",
	"onPointerMove",
	"onPointerMoveCapture",
	"onPointerUp",
	"onPointerUpCapture",
	"onPointerCancel",
	"onPointerCancelCapture",
	"onPointerEnter",
	"onPointerEnterCapture",
	"onPointerLeave",
	"onPointerLeaveCapture",
	"onPointerOver",
	"onPointerOverCapture",
	"onPointerOut",
	"onPointerOutCapture",
	"onGotPointerCapture",
	"onGotPointerCaptureCapture",
	"onLostPointerCapture",
	"onLostPointerCaptureCapture",
	"onScroll",
	"onScrollCapture",
	"onWheel",
	"onWheelCapture",
	"onAnimationStart",
	"onAnimationStartCapture",
	"onAnimationEnd",
	"onAnimationEndCapture",
	"onAnimationIteration",
	"onAnimationIterationCapture",
	"onTransitionEnd",
	"onTransitionEndCapture"
];
var adaptEventHandlers = function adaptEventHandlers$1(props, newHandler) {
	if (!props || typeof props === "function" || typeof props === "boolean") return null;
	var inputProps = props;
	if (/* @__PURE__ */ (0, import_react.isValidElement)(props)) inputProps = props.props;
	if (!(0, import_isObject$3.default)(inputProps)) return null;
	var out = {};
	Object.keys(inputProps).forEach(function(key) {
		if (EventKeys.includes(key)) out[key] = newHandler || function(e) {
			return inputProps[key](inputProps, e);
		};
	});
	return out;
};
var getEventHandlerOfChild = function getEventHandlerOfChild$1(originalHandler, data, index) {
	return function(e) {
		originalHandler(data, index, e);
		return null;
	};
};
var adaptEventsOfChild = function adaptEventsOfChild$1(props, data, index) {
	if (!(0, import_isObject$3.default)(props) || _typeof$46(props) !== "object") return null;
	var out = null;
	Object.keys(props).forEach(function(key) {
		var item = props[key];
		if (EventKeys.includes(key) && typeof item === "function") {
			if (!out) out = {};
			out[key] = getEventHandlerOfChild(item, data, index);
		}
	});
	return out;
};
var import_get$3 = /* @__PURE__ */ __toESM(require_get());
var import_isNil$10 = /* @__PURE__ */ __toESM(require_isNil());
var import_isString$1 = /* @__PURE__ */ __toESM(require_isString());
var import_isFunction$18 = /* @__PURE__ */ __toESM(require_isFunction());
var import_isObject$2 = /* @__PURE__ */ __toESM(require_isObject());
var import_react_is = require_react_is$1();
var _excluded$18 = ["children"], _excluded2$7 = ["children"];
function _objectWithoutProperties$18(source, excluded) {
	if (source == null) return {};
	var target = _objectWithoutPropertiesLoose$18(source, excluded);
	var key, i$2;
	if (Object.getOwnPropertySymbols) {
		var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
		for (i$2 = 0; i$2 < sourceSymbolKeys.length; i$2++) {
			key = sourceSymbolKeys[i$2];
			if (excluded.indexOf(key) >= 0) continue;
			if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
			target[key] = source[key];
		}
	}
	return target;
}
function _objectWithoutPropertiesLoose$18(source, excluded) {
	if (source == null) return {};
	var target = {};
	for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) {
		if (excluded.indexOf(key) >= 0) continue;
		target[key] = source[key];
	}
	return target;
}
function _typeof$45(o$1) {
	"@babel/helpers - typeof";
	return _typeof$45 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$2) {
		return typeof o$2;
	} : function(o$2) {
		return o$2 && "function" == typeof Symbol && o$2.constructor === Symbol && o$2 !== Symbol.prototype ? "symbol" : typeof o$2;
	}, _typeof$45(o$1);
}
var REACT_BROWSER_EVENT_MAP = {
	click: "onClick",
	mousedown: "onMouseDown",
	mouseup: "onMouseUp",
	mouseover: "onMouseOver",
	mousemove: "onMouseMove",
	mouseout: "onMouseOut",
	mouseenter: "onMouseEnter",
	mouseleave: "onMouseLeave",
	touchcancel: "onTouchCancel",
	touchend: "onTouchEnd",
	touchmove: "onTouchMove",
	touchstart: "onTouchStart",
	contextmenu: "onContextMenu",
	dblclick: "onDoubleClick"
};
var getDisplayName = function getDisplayName$1(Comp) {
	if (typeof Comp === "string") return Comp;
	if (!Comp) return "";
	return Comp.displayName || Comp.name || "Component";
};
var lastChildren = null;
var lastResult = null;
var toArray = function toArray$1(children) {
	if (children === lastChildren && Array.isArray(lastResult)) return lastResult;
	var result = [];
	import_react.Children.forEach(children, function(child) {
		if ((0, import_isNil$10.default)(child)) return;
		if ((0, import_react_is.isFragment)(child)) result = result.concat(toArray$1(child.props.children));
		else result.push(child);
	});
	lastResult = result;
	lastChildren = children;
	return result;
};
function findAllByType(children, type) {
	var result = [];
	var types = [];
	if (Array.isArray(type)) types = type.map(function(t$1) {
		return getDisplayName(t$1);
	});
	else types = [getDisplayName(type)];
	toArray(children).forEach(function(child) {
		var childType = (0, import_get$3.default)(child, "type.displayName") || (0, import_get$3.default)(child, "type.name");
		if (types.indexOf(childType) !== -1) result.push(child);
	});
	return result;
}
function findChildByType(children, type) {
	var result = findAllByType(children, type);
	return result && result[0];
}
var validateWidthHeight = function validateWidthHeight$1(el) {
	if (!el || !el.props) return false;
	var _el$props = el.props, width = _el$props.width, height = _el$props.height;
	if (!isNumber(width) || width <= 0 || !isNumber(height) || height <= 0) return false;
	return true;
};
var SVG_TAGS = [
	"a",
	"altGlyph",
	"altGlyphDef",
	"altGlyphItem",
	"animate",
	"animateColor",
	"animateMotion",
	"animateTransform",
	"circle",
	"clipPath",
	"color-profile",
	"cursor",
	"defs",
	"desc",
	"ellipse",
	"feBlend",
	"feColormatrix",
	"feComponentTransfer",
	"feComposite",
	"feConvolveMatrix",
	"feDiffuseLighting",
	"feDisplacementMap",
	"feDistantLight",
	"feFlood",
	"feFuncA",
	"feFuncB",
	"feFuncG",
	"feFuncR",
	"feGaussianBlur",
	"feImage",
	"feMerge",
	"feMergeNode",
	"feMorphology",
	"feOffset",
	"fePointLight",
	"feSpecularLighting",
	"feSpotLight",
	"feTile",
	"feTurbulence",
	"filter",
	"font",
	"font-face",
	"font-face-format",
	"font-face-name",
	"font-face-url",
	"foreignObject",
	"g",
	"glyph",
	"glyphRef",
	"hkern",
	"image",
	"line",
	"lineGradient",
	"marker",
	"mask",
	"metadata",
	"missing-glyph",
	"mpath",
	"path",
	"pattern",
	"polygon",
	"polyline",
	"radialGradient",
	"rect",
	"script",
	"set",
	"stop",
	"style",
	"svg",
	"switch",
	"symbol",
	"text",
	"textPath",
	"title",
	"tref",
	"tspan",
	"use",
	"view",
	"vkern"
];
var isSvgElement = function isSvgElement$1(child) {
	return child && child.type && (0, import_isString$1.default)(child.type) && SVG_TAGS.indexOf(child.type) >= 0;
};
var hasClipDot = function hasClipDot$1(dot) {
	return dot && _typeof$45(dot) === "object" && "clipDot" in dot;
};
var isValidSpreadableProp = function isValidSpreadableProp$1(property$2, key, includeEvents, svgElementType) {
	var _FilteredElementKeyMa;
	var matchingElementTypeKeys = (_FilteredElementKeyMa = FilteredElementKeyMap === null || FilteredElementKeyMap === void 0 ? void 0 : FilteredElementKeyMap[svgElementType]) !== null && _FilteredElementKeyMa !== void 0 ? _FilteredElementKeyMa : [];
	return key.startsWith("data-") || !(0, import_isFunction$18.default)(property$2) && (svgElementType && matchingElementTypeKeys.includes(key) || SVGElementPropKeys.includes(key)) || includeEvents && EventKeys.includes(key);
};
var filterProps = function filterProps$1(props, includeEvents, svgElementType) {
	if (!props || typeof props === "function" || typeof props === "boolean") return null;
	var inputProps = props;
	if (/* @__PURE__ */ (0, import_react.isValidElement)(props)) inputProps = props.props;
	if (!(0, import_isObject$2.default)(inputProps)) return null;
	var out = {};
	Object.keys(inputProps).forEach(function(key) {
		var _inputProps;
		if (isValidSpreadableProp((_inputProps = inputProps) === null || _inputProps === void 0 ? void 0 : _inputProps[key], key, includeEvents, svgElementType)) out[key] = inputProps[key];
	});
	return out;
};
var isChildrenEqual = function isChildrenEqual$1(nextChildren, prevChildren) {
	if (nextChildren === prevChildren) return true;
	var count = import_react.Children.count(nextChildren);
	if (count !== import_react.Children.count(prevChildren)) return false;
	if (count === 0) return true;
	if (count === 1) return isSingleChildEqual(Array.isArray(nextChildren) ? nextChildren[0] : nextChildren, Array.isArray(prevChildren) ? prevChildren[0] : prevChildren);
	for (var i$2 = 0; i$2 < count; i$2++) {
		var nextChild = nextChildren[i$2];
		var prevChild = prevChildren[i$2];
		if (Array.isArray(nextChild) || Array.isArray(prevChild)) {
			if (!isChildrenEqual$1(nextChild, prevChild)) return false;
		} else if (!isSingleChildEqual(nextChild, prevChild)) return false;
	}
	return true;
};
var isSingleChildEqual = function isSingleChildEqual$1(nextChild, prevChild) {
	if ((0, import_isNil$10.default)(nextChild) && (0, import_isNil$10.default)(prevChild)) return true;
	if (!(0, import_isNil$10.default)(nextChild) && !(0, import_isNil$10.default)(prevChild)) {
		var _ref = nextChild.props || {}, nextChildren = _ref.children, nextProps = _objectWithoutProperties$18(_ref, _excluded$18);
		var _ref2 = prevChild.props || {}, prevChildren = _ref2.children, prevProps = _objectWithoutProperties$18(_ref2, _excluded2$7);
		if (nextChildren && prevChildren) return shallowEqual(nextProps, prevProps) && isChildrenEqual(nextChildren, prevChildren);
		if (!nextChildren && !prevChildren) return shallowEqual(nextProps, prevProps);
		return false;
	}
	return false;
};
var renderByOrder = function renderByOrder$1(children, renderMap) {
	var elements = [];
	var record = {};
	toArray(children).forEach(function(child, index) {
		if (isSvgElement(child)) elements.push(child);
		else if (child) {
			var displayName = getDisplayName(child.type);
			var _ref3 = renderMap[displayName] || {}, handler = _ref3.handler, once = _ref3.once;
			if (handler && (!once || !record[displayName])) {
				var results = handler(child, displayName, index);
				elements.push(results);
				record[displayName] = true;
			}
		}
	});
	return elements;
};
var getReactEventByType = function getReactEventByType$1(e) {
	var type = e && e.type;
	if (type && REACT_BROWSER_EVENT_MAP[type]) return REACT_BROWSER_EVENT_MAP[type];
	return null;
};
var parseChildIndex = function parseChildIndex$1(child, children) {
	return toArray(children).indexOf(child);
};
var _excluded$17 = [
	"children",
	"width",
	"height",
	"viewBox",
	"className",
	"style",
	"title",
	"desc"
];
function _extends$27() {
	_extends$27 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i$2 = 1; i$2 < arguments.length; i$2++) {
			var source = arguments[i$2];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$27.apply(this, arguments);
}
function _objectWithoutProperties$17(source, excluded) {
	if (source == null) return {};
	var target = _objectWithoutPropertiesLoose$17(source, excluded);
	var key, i$2;
	if (Object.getOwnPropertySymbols) {
		var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
		for (i$2 = 0; i$2 < sourceSymbolKeys.length; i$2++) {
			key = sourceSymbolKeys[i$2];
			if (excluded.indexOf(key) >= 0) continue;
			if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
			target[key] = source[key];
		}
	}
	return target;
}
function _objectWithoutPropertiesLoose$17(source, excluded) {
	if (source == null) return {};
	var target = {};
	for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) {
		if (excluded.indexOf(key) >= 0) continue;
		target[key] = source[key];
	}
	return target;
}
function Surface(props) {
	var children = props.children, width = props.width, height = props.height, viewBox = props.viewBox, className = props.className, style = props.style, title = props.title, desc = props.desc, others = _objectWithoutProperties$17(props, _excluded$17);
	var svgView = viewBox || {
		width,
		height,
		x: 0,
		y: 0
	};
	var layerClass = clsx_default("recharts-surface", className);
	return /* @__PURE__ */ import_react.createElement("svg", _extends$27({}, filterProps(others, true, "svg"), {
		className: layerClass,
		width,
		height,
		style,
		viewBox: "".concat(svgView.x, " ").concat(svgView.y, " ").concat(svgView.width, " ").concat(svgView.height)
	}), /* @__PURE__ */ import_react.createElement("title", null, title), /* @__PURE__ */ import_react.createElement("desc", null, desc), children);
}
var _excluded$16 = ["children", "className"];
function _extends$26() {
	_extends$26 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i$2 = 1; i$2 < arguments.length; i$2++) {
			var source = arguments[i$2];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$26.apply(this, arguments);
}
function _objectWithoutProperties$16(source, excluded) {
	if (source == null) return {};
	var target = _objectWithoutPropertiesLoose$16(source, excluded);
	var key, i$2;
	if (Object.getOwnPropertySymbols) {
		var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
		for (i$2 = 0; i$2 < sourceSymbolKeys.length; i$2++) {
			key = sourceSymbolKeys[i$2];
			if (excluded.indexOf(key) >= 0) continue;
			if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
			target[key] = source[key];
		}
	}
	return target;
}
function _objectWithoutPropertiesLoose$16(source, excluded) {
	if (source == null) return {};
	var target = {};
	for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) {
		if (excluded.indexOf(key) >= 0) continue;
		target[key] = source[key];
	}
	return target;
}
var Layer = /* @__PURE__ */ import_react.forwardRef(function(props, ref) {
	var children = props.children, className = props.className, others = _objectWithoutProperties$16(props, _excluded$16);
	var layerClass = clsx_default("recharts-layer", className);
	return /* @__PURE__ */ import_react.createElement("g", _extends$26({ className: layerClass }, filterProps(others, true), { ref }), children);
});
var isDev$1 = true;
var warn = function warn$2(condition, format$2) {
	for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) args[_key - 2] = arguments[_key];
	if (isDev$1 && typeof console !== "undefined" && console.warn) {
		if (format$2 === void 0) console.warn("LogUtils requires an error message argument");
		if (!condition) if (format$2 === void 0) console.warn("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
		else {
			var argIndex = 0;
			console.warn(format$2.replace(/%s/g, function() {
				return args[argIndex++];
			}));
		}
	}
};
var require__baseSlice = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function baseSlice$1(array$1, start, end) {
		var index = -1, length = array$1.length;
		if (start < 0) start = -start > length ? 0 : length + start;
		end = end > length ? length : end;
		if (end < 0) end += length;
		length = start > end ? 0 : end - start >>> 0;
		start >>>= 0;
		var result = Array(length);
		while (++index < length) result[index] = array$1[index + start];
		return result;
	}
	module.exports = baseSlice$1;
}));
var require__castSlice = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseSlice = require__baseSlice();
	function castSlice$1(array$1, start, end) {
		var length = array$1.length;
		end = end === void 0 ? length : end;
		return !start && end >= length ? array$1 : baseSlice(array$1, start, end);
	}
	module.exports = castSlice$1;
}));
var require__hasUnicode = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var reHasUnicode = RegExp("[\\u200d\\ud800-\\udfff\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff\\ufe0e\\ufe0f]");
	function hasUnicode$2(string$2) {
		return reHasUnicode.test(string$2);
	}
	module.exports = hasUnicode$2;
}));
var require__asciiToArray = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function asciiToArray$1(string$2) {
		return string$2.split("");
	}
	module.exports = asciiToArray$1;
}));
var require__unicodeToArray = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var rsAstralRange = "\\ud800-\\udfff", rsComboRange = "\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff", rsVarRange = "\\ufe0e\\ufe0f";
	var rsAstral = "[" + rsAstralRange + "]", rsCombo = "[" + rsComboRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsZWJ = "\\u200d";
	var reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [
		rsNonAstral,
		rsRegional,
		rsSurrPair
	].join("|") + ")" + rsOptVar + reOptMod + ")*", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsSymbol = "(?:" + [
		rsNonAstral + rsCombo + "?",
		rsCombo,
		rsRegional,
		rsSurrPair,
		rsAstral
	].join("|") + ")";
	var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
	function unicodeToArray$1(string$2) {
		return string$2.match(reUnicode) || [];
	}
	module.exports = unicodeToArray$1;
}));
var require__stringToArray = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var asciiToArray = require__asciiToArray(), hasUnicode$1 = require__hasUnicode(), unicodeToArray = require__unicodeToArray();
	function stringToArray$1(string$2) {
		return hasUnicode$1(string$2) ? unicodeToArray(string$2) : asciiToArray(string$2);
	}
	module.exports = stringToArray$1;
}));
var require__createCaseFirst = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var castSlice = require__castSlice(), hasUnicode = require__hasUnicode(), stringToArray = require__stringToArray(), toString$1 = require_toString();
	function createCaseFirst(methodName) {
		return function(string$2) {
			string$2 = toString$1(string$2);
			var strSymbols = hasUnicode(string$2) ? stringToArray(string$2) : void 0;
			var chr = strSymbols ? strSymbols[0] : string$2.charAt(0);
			var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string$2.slice(1);
			return chr[methodName]() + trailing;
		};
	}
	module.exports = createCaseFirst;
}));
var require_upperFirst = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = require__createCaseFirst()("toUpperCase");
}));
function constant_default$1(x$1) {
	return function constant$2() {
		return x$1;
	};
}
const cos = Math.cos;
const sin = Math.sin;
const sqrt$1 = Math.sqrt;
const pi = Math.PI;
pi / 2;
const tau = 2 * pi;
var pi$1 = Math.PI, tau$1 = 2 * pi$1, epsilon = 1e-6, tauEpsilon = tau$1 - epsilon;
function append(strings) {
	this._ += strings[0];
	for (let i$2 = 1, n$1 = strings.length; i$2 < n$1; ++i$2) this._ += arguments[i$2] + strings[i$2];
}
function appendRound(digits) {
	let d = Math.floor(digits);
	if (!(d >= 0)) throw new Error(`invalid digits: ${digits}`);
	if (d > 15) return append;
	const k$1 = 10 ** d;
	return function(strings) {
		this._ += strings[0];
		for (let i$2 = 1, n$1 = strings.length; i$2 < n$1; ++i$2) this._ += Math.round(arguments[i$2] * k$1) / k$1 + strings[i$2];
	};
}
var Path = class {
	constructor(digits) {
		this._x0 = this._y0 = this._x1 = this._y1 = null;
		this._ = "";
		this._append = digits == null ? append : appendRound(digits);
	}
	moveTo(x$1, y$1) {
		this._append`M${this._x0 = this._x1 = +x$1},${this._y0 = this._y1 = +y$1}`;
	}
	closePath() {
		if (this._x1 !== null) {
			this._x1 = this._x0, this._y1 = this._y0;
			this._append`Z`;
		}
	}
	lineTo(x$1, y$1) {
		this._append`L${this._x1 = +x$1},${this._y1 = +y$1}`;
	}
	quadraticCurveTo(x1, y1, x$1, y$1) {
		this._append`Q${+x1},${+y1},${this._x1 = +x$1},${this._y1 = +y$1}`;
	}
	bezierCurveTo(x1, y1, x2, y2, x$1, y$1) {
		this._append`C${+x1},${+y1},${+x2},${+y2},${this._x1 = +x$1},${this._y1 = +y$1}`;
	}
	arcTo(x1, y1, x2, y2, r$1) {
		x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r$1 = +r$1;
		if (r$1 < 0) throw new Error(`negative radius: ${r$1}`);
		let x0 = this._x1, y0 = this._y1, x21 = x2 - x1, y21 = y2 - y1, x01 = x0 - x1, y01 = y0 - y1, l01_2 = x01 * x01 + y01 * y01;
		if (this._x1 === null) this._append`M${this._x1 = x1},${this._y1 = y1}`;
		else if (!(l01_2 > epsilon));
		else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r$1) this._append`L${this._x1 = x1},${this._y1 = y1}`;
		else {
			let x20 = x2 - x0, y20 = y2 - y0, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l = r$1 * Math.tan((pi$1 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l / l01, t21 = l / l21;
			if (Math.abs(t01 - 1) > epsilon) this._append`L${x1 + t01 * x01},${y1 + t01 * y01}`;
			this._append`A${r$1},${r$1},0,0,${+(y01 * x20 > x01 * y20)},${this._x1 = x1 + t21 * x21},${this._y1 = y1 + t21 * y21}`;
		}
	}
	arc(x$1, y$1, r$1, a0, a1, ccw) {
		x$1 = +x$1, y$1 = +y$1, r$1 = +r$1, ccw = !!ccw;
		if (r$1 < 0) throw new Error(`negative radius: ${r$1}`);
		let dx = r$1 * Math.cos(a0), dy = r$1 * Math.sin(a0), x0 = x$1 + dx, y0 = y$1 + dy, cw = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
		if (this._x1 === null) this._append`M${x0},${y0}`;
		else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) this._append`L${x0},${y0}`;
		if (!r$1) return;
		if (da < 0) da = da % tau$1 + tau$1;
		if (da > tauEpsilon) this._append`A${r$1},${r$1},0,1,${cw},${x$1 - dx},${y$1 - dy}A${r$1},${r$1},0,1,${cw},${this._x1 = x0},${this._y1 = y0}`;
		else if (da > epsilon) this._append`A${r$1},${r$1},0,${+(da >= pi$1)},${cw},${this._x1 = x$1 + r$1 * Math.cos(a1)},${this._y1 = y$1 + r$1 * Math.sin(a1)}`;
	}
	rect(x$1, y$1, w, h) {
		this._append`M${this._x0 = this._x1 = +x$1},${this._y0 = this._y1 = +y$1}h${w = +w}v${+h}h${-w}Z`;
	}
	toString() {
		return this._;
	}
};
function path() {
	return new Path();
}
path.prototype = Path.prototype;
function withPath(shape) {
	let digits = 3;
	shape.digits = function(_) {
		if (!arguments.length) return digits;
		if (_ == null) digits = null;
		else {
			const d = Math.floor(_);
			if (!(d >= 0)) throw new RangeError(`invalid digits: ${_}`);
			digits = d;
		}
		return shape;
	};
	return () => new Path(digits);
}
Array.prototype.slice;
function array_default(x$1) {
	return typeof x$1 === "object" && "length" in x$1 ? x$1 : Array.from(x$1);
}
function Linear(context) {
	this._context = context;
}
Linear.prototype = {
	areaStart: function() {
		this._line = 0;
	},
	areaEnd: function() {
		this._line = NaN;
	},
	lineStart: function() {
		this._point = 0;
	},
	lineEnd: function() {
		if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
		this._line = 1 - this._line;
	},
	point: function(x$1, y$1) {
		x$1 = +x$1, y$1 = +y$1;
		switch (this._point) {
			case 0:
				this._point = 1;
				this._line ? this._context.lineTo(x$1, y$1) : this._context.moveTo(x$1, y$1);
				break;
			case 1: this._point = 2;
			default:
				this._context.lineTo(x$1, y$1);
				break;
		}
	}
};
function linear_default(context) {
	return new Linear(context);
}
function x(p) {
	return p[0];
}
function y(p) {
	return p[1];
}
function line_default(x$1, y$1) {
	var defined$1 = constant_default$1(true), context = null, curve = linear_default, output = null, path$1 = withPath(line);
	x$1 = typeof x$1 === "function" ? x$1 : x$1 === void 0 ? x : constant_default$1(x$1);
	y$1 = typeof y$1 === "function" ? y$1 : y$1 === void 0 ? y : constant_default$1(y$1);
	function line(data) {
		var i$2, n$1 = (data = array_default(data)).length, d, defined0 = false, buffer;
		if (context == null) output = curve(buffer = path$1());
		for (i$2 = 0; i$2 <= n$1; ++i$2) {
			if (!(i$2 < n$1 && defined$1(d = data[i$2], i$2, data)) === defined0) if (defined0 = !defined0) output.lineStart();
			else output.lineEnd();
			if (defined0) output.point(+x$1(d, i$2, data), +y$1(d, i$2, data));
		}
		if (buffer) return output = null, buffer + "" || null;
	}
	line.x = function(_) {
		return arguments.length ? (x$1 = typeof _ === "function" ? _ : constant_default$1(+_), line) : x$1;
	};
	line.y = function(_) {
		return arguments.length ? (y$1 = typeof _ === "function" ? _ : constant_default$1(+_), line) : y$1;
	};
	line.defined = function(_) {
		return arguments.length ? (defined$1 = typeof _ === "function" ? _ : constant_default$1(!!_), line) : defined$1;
	};
	line.curve = function(_) {
		return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
	};
	line.context = function(_) {
		return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
	};
	return line;
}
function area_default(x0, y0, y1) {
	var x1 = null, defined$1 = constant_default$1(true), context = null, curve = linear_default, output = null, path$1 = withPath(area);
	x0 = typeof x0 === "function" ? x0 : x0 === void 0 ? x : constant_default$1(+x0);
	y0 = typeof y0 === "function" ? y0 : y0 === void 0 ? constant_default$1(0) : constant_default$1(+y0);
	y1 = typeof y1 === "function" ? y1 : y1 === void 0 ? y : constant_default$1(+y1);
	function area(data) {
		var i$2, j, k$1, n$1 = (data = array_default(data)).length, d, defined0 = false, buffer, x0z = new Array(n$1), y0z = new Array(n$1);
		if (context == null) output = curve(buffer = path$1());
		for (i$2 = 0; i$2 <= n$1; ++i$2) {
			if (!(i$2 < n$1 && defined$1(d = data[i$2], i$2, data)) === defined0) if (defined0 = !defined0) {
				j = i$2;
				output.areaStart();
				output.lineStart();
			} else {
				output.lineEnd();
				output.lineStart();
				for (k$1 = i$2 - 1; k$1 >= j; --k$1) output.point(x0z[k$1], y0z[k$1]);
				output.lineEnd();
				output.areaEnd();
			}
			if (defined0) {
				x0z[i$2] = +x0(d, i$2, data), y0z[i$2] = +y0(d, i$2, data);
				output.point(x1 ? +x1(d, i$2, data) : x0z[i$2], y1 ? +y1(d, i$2, data) : y0z[i$2]);
			}
		}
		if (buffer) return output = null, buffer + "" || null;
	}
	function arealine() {
		return line_default().defined(defined$1).curve(curve).context(context);
	}
	area.x = function(_) {
		return arguments.length ? (x0 = typeof _ === "function" ? _ : constant_default$1(+_), x1 = null, area) : x0;
	};
	area.x0 = function(_) {
		return arguments.length ? (x0 = typeof _ === "function" ? _ : constant_default$1(+_), area) : x0;
	};
	area.x1 = function(_) {
		return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : constant_default$1(+_), area) : x1;
	};
	area.y = function(_) {
		return arguments.length ? (y0 = typeof _ === "function" ? _ : constant_default$1(+_), y1 = null, area) : y0;
	};
	area.y0 = function(_) {
		return arguments.length ? (y0 = typeof _ === "function" ? _ : constant_default$1(+_), area) : y0;
	};
	area.y1 = function(_) {
		return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : constant_default$1(+_), area) : y1;
	};
	area.lineX0 = area.lineY0 = function() {
		return arealine().x(x0).y(y0);
	};
	area.lineY1 = function() {
		return arealine().x(x0).y(y1);
	};
	area.lineX1 = function() {
		return arealine().x(x1).y(y0);
	};
	area.defined = function(_) {
		return arguments.length ? (defined$1 = typeof _ === "function" ? _ : constant_default$1(!!_), area) : defined$1;
	};
	area.curve = function(_) {
		return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
	};
	area.context = function(_) {
		return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
	};
	return area;
}
var Bump = class {
	constructor(context, x$1) {
		this._context = context;
		this._x = x$1;
	}
	areaStart() {
		this._line = 0;
	}
	areaEnd() {
		this._line = NaN;
	}
	lineStart() {
		this._point = 0;
	}
	lineEnd() {
		if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
		this._line = 1 - this._line;
	}
	point(x$1, y$1) {
		x$1 = +x$1, y$1 = +y$1;
		switch (this._point) {
			case 0:
				this._point = 1;
				if (this._line) this._context.lineTo(x$1, y$1);
				else this._context.moveTo(x$1, y$1);
				break;
			case 1: this._point = 2;
			default:
				if (this._x) this._context.bezierCurveTo(this._x0 = (this._x0 + x$1) / 2, this._y0, this._x0, y$1, x$1, y$1);
				else this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + y$1) / 2, x$1, this._y0, x$1, y$1);
				break;
		}
		this._x0 = x$1, this._y0 = y$1;
	}
};
function bumpX(context) {
	return new Bump(context, true);
}
function bumpY(context) {
	return new Bump(context, false);
}
var circle_default = { draw(context, size) {
	const r$1 = sqrt$1(size / pi);
	context.moveTo(r$1, 0);
	context.arc(0, 0, r$1, 0, tau);
} };
var cross_default = { draw(context, size) {
	const r$1 = sqrt$1(size / 5) / 2;
	context.moveTo(-3 * r$1, -r$1);
	context.lineTo(-r$1, -r$1);
	context.lineTo(-r$1, -3 * r$1);
	context.lineTo(r$1, -3 * r$1);
	context.lineTo(r$1, -r$1);
	context.lineTo(3 * r$1, -r$1);
	context.lineTo(3 * r$1, r$1);
	context.lineTo(r$1, r$1);
	context.lineTo(r$1, 3 * r$1);
	context.lineTo(-r$1, 3 * r$1);
	context.lineTo(-r$1, r$1);
	context.lineTo(-3 * r$1, r$1);
	context.closePath();
} };
var tan30 = sqrt$1(1 / 3);
var tan30_2 = tan30 * 2;
var diamond_default = { draw(context, size) {
	const y$1 = sqrt$1(size / tan30_2);
	const x$1 = y$1 * tan30;
	context.moveTo(0, -y$1);
	context.lineTo(x$1, 0);
	context.lineTo(0, y$1);
	context.lineTo(-x$1, 0);
	context.closePath();
} };
var square_default = { draw(context, size) {
	const w = sqrt$1(size);
	const x$1 = -w / 2;
	context.rect(x$1, x$1, w, w);
} };
var ka = .8908130915292852;
var kr = sin(pi / 10) / sin(7 * pi / 10);
var kx = sin(tau / 10) * kr;
var ky = -cos(tau / 10) * kr;
var star_default = { draw(context, size) {
	const r$1 = sqrt$1(size * ka);
	const x$1 = kx * r$1;
	const y$1 = ky * r$1;
	context.moveTo(0, -r$1);
	context.lineTo(x$1, y$1);
	for (let i$2 = 1; i$2 < 5; ++i$2) {
		const a$2 = tau * i$2 / 5;
		const c$1 = cos(a$2);
		const s$3 = sin(a$2);
		context.lineTo(s$3 * r$1, -c$1 * r$1);
		context.lineTo(c$1 * x$1 - s$3 * y$1, s$3 * x$1 + c$1 * y$1);
	}
	context.closePath();
} };
var sqrt3 = sqrt$1(3);
var triangle_default = { draw(context, size) {
	const y$1 = -sqrt$1(size / (sqrt3 * 3));
	context.moveTo(0, y$1 * 2);
	context.lineTo(-sqrt3 * y$1, -y$1);
	context.lineTo(sqrt3 * y$1, -y$1);
	context.closePath();
} };
var c = -.5;
var s = sqrt$1(3) / 2;
var k = 1 / sqrt$1(12);
var a = (k / 2 + 1) * 3;
var wye_default = { draw(context, size) {
	const r$1 = sqrt$1(size / a);
	const x0 = r$1 / 2, y0 = r$1 * k;
	const x1 = x0, y1 = r$1 * k + r$1;
	const x2 = -x1, y2 = y1;
	context.moveTo(x0, y0);
	context.lineTo(x1, y1);
	context.lineTo(x2, y2);
	context.lineTo(c * x0 - s * y0, s * x0 + c * y0);
	context.lineTo(c * x1 - s * y1, s * x1 + c * y1);
	context.lineTo(c * x2 - s * y2, s * x2 + c * y2);
	context.lineTo(c * x0 + s * y0, c * y0 - s * x0);
	context.lineTo(c * x1 + s * y1, c * y1 - s * x1);
	context.lineTo(c * x2 + s * y2, c * y2 - s * x2);
	context.closePath();
} };
function Symbol$3(type, size) {
	let context = null, path$1 = withPath(symbol);
	type = typeof type === "function" ? type : constant_default$1(type || circle_default);
	size = typeof size === "function" ? size : constant_default$1(size === void 0 ? 64 : +size);
	function symbol() {
		let buffer;
		if (!context) context = buffer = path$1();
		type.apply(this, arguments).draw(context, +size.apply(this, arguments));
		if (buffer) return context = null, buffer + "" || null;
	}
	symbol.type = function(_) {
		return arguments.length ? (type = typeof _ === "function" ? _ : constant_default$1(_), symbol) : type;
	};
	symbol.size = function(_) {
		return arguments.length ? (size = typeof _ === "function" ? _ : constant_default$1(+_), symbol) : size;
	};
	symbol.context = function(_) {
		return arguments.length ? (context = _ == null ? null : _, symbol) : context;
	};
	return symbol;
}
function noop_default() {}
function point$2(that, x$1, y$1) {
	that._context.bezierCurveTo((2 * that._x0 + that._x1) / 3, (2 * that._y0 + that._y1) / 3, (that._x0 + 2 * that._x1) / 3, (that._y0 + 2 * that._y1) / 3, (that._x0 + 4 * that._x1 + x$1) / 6, (that._y0 + 4 * that._y1 + y$1) / 6);
}
function Basis(context) {
	this._context = context;
}
Basis.prototype = {
	areaStart: function() {
		this._line = 0;
	},
	areaEnd: function() {
		this._line = NaN;
	},
	lineStart: function() {
		this._x0 = this._x1 = this._y0 = this._y1 = NaN;
		this._point = 0;
	},
	lineEnd: function() {
		switch (this._point) {
			case 3: point$2(this, this._x1, this._y1);
			case 2:
				this._context.lineTo(this._x1, this._y1);
				break;
		}
		if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
		this._line = 1 - this._line;
	},
	point: function(x$1, y$1) {
		x$1 = +x$1, y$1 = +y$1;
		switch (this._point) {
			case 0:
				this._point = 1;
				this._line ? this._context.lineTo(x$1, y$1) : this._context.moveTo(x$1, y$1);
				break;
			case 1:
				this._point = 2;
				break;
			case 2:
				this._point = 3;
				this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
			default:
				point$2(this, x$1, y$1);
				break;
		}
		this._x0 = this._x1, this._x1 = x$1;
		this._y0 = this._y1, this._y1 = y$1;
	}
};
function basis_default(context) {
	return new Basis(context);
}
function BasisClosed(context) {
	this._context = context;
}
BasisClosed.prototype = {
	areaStart: noop_default,
	areaEnd: noop_default,
	lineStart: function() {
		this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
		this._point = 0;
	},
	lineEnd: function() {
		switch (this._point) {
			case 1:
				this._context.moveTo(this._x2, this._y2);
				this._context.closePath();
				break;
			case 2:
				this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
				this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
				this._context.closePath();
				break;
			case 3:
				this.point(this._x2, this._y2);
				this.point(this._x3, this._y3);
				this.point(this._x4, this._y4);
				break;
		}
	},
	point: function(x$1, y$1) {
		x$1 = +x$1, y$1 = +y$1;
		switch (this._point) {
			case 0:
				this._point = 1;
				this._x2 = x$1, this._y2 = y$1;
				break;
			case 1:
				this._point = 2;
				this._x3 = x$1, this._y3 = y$1;
				break;
			case 2:
				this._point = 3;
				this._x4 = x$1, this._y4 = y$1;
				this._context.moveTo((this._x0 + 4 * this._x1 + x$1) / 6, (this._y0 + 4 * this._y1 + y$1) / 6);
				break;
			default:
				point$2(this, x$1, y$1);
				break;
		}
		this._x0 = this._x1, this._x1 = x$1;
		this._y0 = this._y1, this._y1 = y$1;
	}
};
function basisClosed_default(context) {
	return new BasisClosed(context);
}
function BasisOpen(context) {
	this._context = context;
}
BasisOpen.prototype = {
	areaStart: function() {
		this._line = 0;
	},
	areaEnd: function() {
		this._line = NaN;
	},
	lineStart: function() {
		this._x0 = this._x1 = this._y0 = this._y1 = NaN;
		this._point = 0;
	},
	lineEnd: function() {
		if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
		this._line = 1 - this._line;
	},
	point: function(x$1, y$1) {
		x$1 = +x$1, y$1 = +y$1;
		switch (this._point) {
			case 0:
				this._point = 1;
				break;
			case 1:
				this._point = 2;
				break;
			case 2:
				this._point = 3;
				var x0 = (this._x0 + 4 * this._x1 + x$1) / 6, y0 = (this._y0 + 4 * this._y1 + y$1) / 6;
				this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0);
				break;
			case 3: this._point = 4;
			default:
				point$2(this, x$1, y$1);
				break;
		}
		this._x0 = this._x1, this._x1 = x$1;
		this._y0 = this._y1, this._y1 = y$1;
	}
};
function basisOpen_default(context) {
	return new BasisOpen(context);
}
function LinearClosed(context) {
	this._context = context;
}
LinearClosed.prototype = {
	areaStart: noop_default,
	areaEnd: noop_default,
	lineStart: function() {
		this._point = 0;
	},
	lineEnd: function() {
		if (this._point) this._context.closePath();
	},
	point: function(x$1, y$1) {
		x$1 = +x$1, y$1 = +y$1;
		if (this._point) this._context.lineTo(x$1, y$1);
		else this._point = 1, this._context.moveTo(x$1, y$1);
	}
};
function linearClosed_default(context) {
	return new LinearClosed(context);
}
function sign(x$1) {
	return x$1 < 0 ? -1 : 1;
}
function slope3(that, x2, y2) {
	var h0 = that._x1 - that._x0, h1 = x2 - that._x1, s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0), s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0), p = (s0 * h1 + s1 * h0) / (h0 + h1);
	return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), .5 * Math.abs(p)) || 0;
}
function slope2(that, t$1) {
	var h = that._x1 - that._x0;
	return h ? (3 * (that._y1 - that._y0) / h - t$1) / 2 : t$1;
}
function point$1(that, t0$1, t1$1) {
	var x0 = that._x0, y0 = that._y0, x1 = that._x1, y1 = that._y1, dx = (x1 - x0) / 3;
	that._context.bezierCurveTo(x0 + dx, y0 + dx * t0$1, x1 - dx, y1 - dx * t1$1, x1, y1);
}
function MonotoneX(context) {
	this._context = context;
}
MonotoneX.prototype = {
	areaStart: function() {
		this._line = 0;
	},
	areaEnd: function() {
		this._line = NaN;
	},
	lineStart: function() {
		this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
		this._point = 0;
	},
	lineEnd: function() {
		switch (this._point) {
			case 2:
				this._context.lineTo(this._x1, this._y1);
				break;
			case 3:
				point$1(this, this._t0, slope2(this, this._t0));
				break;
		}
		if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
		this._line = 1 - this._line;
	},
	point: function(x$1, y$1) {
		var t1$1 = NaN;
		x$1 = +x$1, y$1 = +y$1;
		if (x$1 === this._x1 && y$1 === this._y1) return;
		switch (this._point) {
			case 0:
				this._point = 1;
				this._line ? this._context.lineTo(x$1, y$1) : this._context.moveTo(x$1, y$1);
				break;
			case 1:
				this._point = 2;
				break;
			case 2:
				this._point = 3;
				point$1(this, slope2(this, t1$1 = slope3(this, x$1, y$1)), t1$1);
				break;
			default:
				point$1(this, this._t0, t1$1 = slope3(this, x$1, y$1));
				break;
		}
		this._x0 = this._x1, this._x1 = x$1;
		this._y0 = this._y1, this._y1 = y$1;
		this._t0 = t1$1;
	}
};
function MonotoneY(context) {
	this._context = new ReflectContext(context);
}
(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x$1, y$1) {
	MonotoneX.prototype.point.call(this, y$1, x$1);
};
function ReflectContext(context) {
	this._context = context;
}
ReflectContext.prototype = {
	moveTo: function(x$1, y$1) {
		this._context.moveTo(y$1, x$1);
	},
	closePath: function() {
		this._context.closePath();
	},
	lineTo: function(x$1, y$1) {
		this._context.lineTo(y$1, x$1);
	},
	bezierCurveTo: function(x1, y1, x2, y2, x$1, y$1) {
		this._context.bezierCurveTo(y1, x1, y2, x2, y$1, x$1);
	}
};
function monotoneX(context) {
	return new MonotoneX(context);
}
function monotoneY(context) {
	return new MonotoneY(context);
}
function Natural(context) {
	this._context = context;
}
Natural.prototype = {
	areaStart: function() {
		this._line = 0;
	},
	areaEnd: function() {
		this._line = NaN;
	},
	lineStart: function() {
		this._x = [];
		this._y = [];
	},
	lineEnd: function() {
		var x$1 = this._x, y$1 = this._y, n$1 = x$1.length;
		if (n$1) {
			this._line ? this._context.lineTo(x$1[0], y$1[0]) : this._context.moveTo(x$1[0], y$1[0]);
			if (n$1 === 2) this._context.lineTo(x$1[1], y$1[1]);
			else {
				var px = controlPoints(x$1), py = controlPoints(y$1);
				for (var i0 = 0, i1 = 1; i1 < n$1; ++i0, ++i1) this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x$1[i1], y$1[i1]);
			}
		}
		if (this._line || this._line !== 0 && n$1 === 1) this._context.closePath();
		this._line = 1 - this._line;
		this._x = this._y = null;
	},
	point: function(x$1, y$1) {
		this._x.push(+x$1);
		this._y.push(+y$1);
	}
};
function controlPoints(x$1) {
	var i$2, n$1 = x$1.length - 1, m, a$2 = new Array(n$1), b = new Array(n$1), r$1 = new Array(n$1);
	a$2[0] = 0, b[0] = 2, r$1[0] = x$1[0] + 2 * x$1[1];
	for (i$2 = 1; i$2 < n$1 - 1; ++i$2) a$2[i$2] = 1, b[i$2] = 4, r$1[i$2] = 4 * x$1[i$2] + 2 * x$1[i$2 + 1];
	a$2[n$1 - 1] = 2, b[n$1 - 1] = 7, r$1[n$1 - 1] = 8 * x$1[n$1 - 1] + x$1[n$1];
	for (i$2 = 1; i$2 < n$1; ++i$2) m = a$2[i$2] / b[i$2 - 1], b[i$2] -= m, r$1[i$2] -= m * r$1[i$2 - 1];
	a$2[n$1 - 1] = r$1[n$1 - 1] / b[n$1 - 1];
	for (i$2 = n$1 - 2; i$2 >= 0; --i$2) a$2[i$2] = (r$1[i$2] - a$2[i$2 + 1]) / b[i$2];
	b[n$1 - 1] = (x$1[n$1] + a$2[n$1 - 1]) / 2;
	for (i$2 = 0; i$2 < n$1 - 1; ++i$2) b[i$2] = 2 * x$1[i$2 + 1] - a$2[i$2 + 1];
	return [a$2, b];
}
function natural_default(context) {
	return new Natural(context);
}
function Step(context, t$1) {
	this._context = context;
	this._t = t$1;
}
Step.prototype = {
	areaStart: function() {
		this._line = 0;
	},
	areaEnd: function() {
		this._line = NaN;
	},
	lineStart: function() {
		this._x = this._y = NaN;
		this._point = 0;
	},
	lineEnd: function() {
		if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
		if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
		if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
	},
	point: function(x$1, y$1) {
		x$1 = +x$1, y$1 = +y$1;
		switch (this._point) {
			case 0:
				this._point = 1;
				this._line ? this._context.lineTo(x$1, y$1) : this._context.moveTo(x$1, y$1);
				break;
			case 1: this._point = 2;
			default:
				if (this._t <= 0) {
					this._context.lineTo(this._x, y$1);
					this._context.lineTo(x$1, y$1);
				} else {
					var x1 = this._x * (1 - this._t) + x$1 * this._t;
					this._context.lineTo(x1, this._y);
					this._context.lineTo(x1, y$1);
				}
				break;
		}
		this._x = x$1, this._y = y$1;
	}
};
function step_default(context) {
	return new Step(context, .5);
}
function stepBefore(context) {
	return new Step(context, 0);
}
function stepAfter(context) {
	return new Step(context, 1);
}
function none_default(series, order) {
	if (!((n$1 = series.length) > 1)) return;
	for (var i$2 = 1, j, s0, s1 = series[order[0]], n$1, m = s1.length; i$2 < n$1; ++i$2) {
		s0 = s1, s1 = series[order[i$2]];
		for (j = 0; j < m; ++j) s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
	}
}
function none_default$1(series) {
	var n$1 = series.length, o$1 = new Array(n$1);
	while (--n$1 >= 0) o$1[n$1] = n$1;
	return o$1;
}
function stackValue(d, key) {
	return d[key];
}
function stackSeries(key) {
	const series = [];
	series.key = key;
	return series;
}
function stack_default() {
	var keys$6 = constant_default$1([]), order = none_default$1, offset = none_default, value = stackValue;
	function stack(data) {
		var sz = Array.from(keys$6.apply(this, arguments), stackSeries), i$2, n$1 = sz.length, j = -1, oz;
		for (const d of data) for (i$2 = 0, ++j; i$2 < n$1; ++i$2) (sz[i$2][j] = [0, +value(d, sz[i$2].key, j, data)]).data = d;
		for (i$2 = 0, oz = array_default(order(sz)); i$2 < n$1; ++i$2) sz[oz[i$2]].index = i$2;
		offset(sz, oz);
		return sz;
	}
	stack.keys = function(_) {
		return arguments.length ? (keys$6 = typeof _ === "function" ? _ : constant_default$1(Array.from(_)), stack) : keys$6;
	};
	stack.value = function(_) {
		return arguments.length ? (value = typeof _ === "function" ? _ : constant_default$1(+_), stack) : value;
	};
	stack.order = function(_) {
		return arguments.length ? (order = _ == null ? none_default$1 : typeof _ === "function" ? _ : constant_default$1(Array.from(_)), stack) : order;
	};
	stack.offset = function(_) {
		return arguments.length ? (offset = _ == null ? none_default : _, stack) : offset;
	};
	return stack;
}
function expand_default(series, order) {
	if (!((n$1 = series.length) > 0)) return;
	for (var i$2, n$1, j = 0, m = series[0].length, y$1; j < m; ++j) {
		for (y$1 = i$2 = 0; i$2 < n$1; ++i$2) y$1 += series[i$2][j][1] || 0;
		if (y$1) for (i$2 = 0; i$2 < n$1; ++i$2) series[i$2][j][1] /= y$1;
	}
	none_default(series, order);
}
function silhouette_default(series, order) {
	if (!((n$1 = series.length) > 0)) return;
	for (var j = 0, s0 = series[order[0]], n$1, m = s0.length; j < m; ++j) {
		for (var i$2 = 0, y$1 = 0; i$2 < n$1; ++i$2) y$1 += series[i$2][j][1] || 0;
		s0[j][1] += s0[j][0] = -y$1 / 2;
	}
	none_default(series, order);
}
function wiggle_default(series, order) {
	if (!((n$1 = series.length) > 0) || !((m = (s0 = series[order[0]]).length) > 0)) return;
	for (var y$1 = 0, j = 1, s0, m, n$1; j < m; ++j) {
		for (var i$2 = 0, s1 = 0, s2 = 0; i$2 < n$1; ++i$2) {
			var si = series[order[i$2]], sij0 = si[j][1] || 0, s3 = (sij0 - (si[j - 1][1] || 0)) / 2;
			for (var k$1 = 0; k$1 < i$2; ++k$1) {
				var sk = series[order[k$1]], skj0 = sk[j][1] || 0, skj1 = sk[j - 1][1] || 0;
				s3 += skj0 - skj1;
			}
			s1 += sij0, s2 += s3 * sij0;
		}
		s0[j - 1][1] += s0[j - 1][0] = y$1;
		if (s1) y$1 -= s2 / s1;
	}
	s0[j - 1][1] += s0[j - 1][0] = y$1;
	none_default(series, order);
}
var import_upperFirst$2 = /* @__PURE__ */ __toESM(require_upperFirst());
function _typeof$44(o$1) {
	"@babel/helpers - typeof";
	return _typeof$44 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$2) {
		return typeof o$2;
	} : function(o$2) {
		return o$2 && "function" == typeof Symbol && o$2.constructor === Symbol && o$2 !== Symbol.prototype ? "symbol" : typeof o$2;
	}, _typeof$44(o$1);
}
var _excluded$15 = [
	"type",
	"size",
	"sizeType"
];
function _extends$25() {
	_extends$25 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i$2 = 1; i$2 < arguments.length; i$2++) {
			var source = arguments[i$2];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$25.apply(this, arguments);
}
function ownKeys$36(e, r$1) {
	var t$1 = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o$1 = Object.getOwnPropertySymbols(e);
		r$1 && (o$1 = o$1.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t$1.push.apply(t$1, o$1);
	}
	return t$1;
}
function _objectSpread$36(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t$1 = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$36(Object(t$1), !0).forEach(function(r$2) {
			_defineProperty$41(e, r$2, t$1[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t$1)) : ownKeys$36(Object(t$1)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t$1, r$2));
		});
	}
	return e;
}
function _defineProperty$41(obj, key, value) {
	key = _toPropertyKey$42(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$42(t$1) {
	var i$2 = _toPrimitive$42(t$1, "string");
	return "symbol" == _typeof$44(i$2) ? i$2 : i$2 + "";
}
function _toPrimitive$42(t$1, r$1) {
	if ("object" != _typeof$44(t$1) || !t$1) return t$1;
	var e = t$1[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i$2 = e.call(t$1, r$1 || "default");
		if ("object" != _typeof$44(i$2)) return i$2;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t$1);
}
function _objectWithoutProperties$15(source, excluded) {
	if (source == null) return {};
	var target = _objectWithoutPropertiesLoose$15(source, excluded);
	var key, i$2;
	if (Object.getOwnPropertySymbols) {
		var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
		for (i$2 = 0; i$2 < sourceSymbolKeys.length; i$2++) {
			key = sourceSymbolKeys[i$2];
			if (excluded.indexOf(key) >= 0) continue;
			if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
			target[key] = source[key];
		}
	}
	return target;
}
function _objectWithoutPropertiesLoose$15(source, excluded) {
	if (source == null) return {};
	var target = {};
	for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) {
		if (excluded.indexOf(key) >= 0) continue;
		target[key] = source[key];
	}
	return target;
}
var symbolFactories = {
	symbolCircle: circle_default,
	symbolCross: cross_default,
	symbolDiamond: diamond_default,
	symbolSquare: square_default,
	symbolStar: star_default,
	symbolTriangle: triangle_default,
	symbolWye: wye_default
};
var RADIAN$1 = Math.PI / 180;
var getSymbolFactory = function getSymbolFactory$1(type) {
	return symbolFactories["symbol".concat((0, import_upperFirst$2.default)(type))] || circle_default;
};
var calculateAreaSize = function calculateAreaSize$1(size, sizeType, type) {
	if (sizeType === "area") return size;
	switch (type) {
		case "cross": return 5 * size * size / 9;
		case "diamond": return .5 * size * size / Math.sqrt(3);
		case "square": return size * size;
		case "star":
			var angle = 18 * RADIAN$1;
			return 1.25 * size * size * (Math.tan(angle) - Math.tan(angle * 2) * Math.pow(Math.tan(angle), 2));
		case "triangle": return Math.sqrt(3) * size * size / 4;
		case "wye": return (21 - 10 * Math.sqrt(3)) * size * size / 8;
		default: return Math.PI * size * size / 4;
	}
};
var registerSymbol = function registerSymbol$1(key, factory) {
	symbolFactories["symbol".concat((0, import_upperFirst$2.default)(key))] = factory;
};
var Symbols = function Symbols$1(_ref) {
	var _ref$type = _ref.type, type = _ref$type === void 0 ? "circle" : _ref$type, _ref$size = _ref.size, size = _ref$size === void 0 ? 64 : _ref$size, _ref$sizeType = _ref.sizeType, sizeType = _ref$sizeType === void 0 ? "area" : _ref$sizeType;
	var props = _objectSpread$36(_objectSpread$36({}, _objectWithoutProperties$15(_ref, _excluded$15)), {}, {
		type,
		size,
		sizeType
	});
	var getPath$2 = function getPath$3() {
		var symbolFactory = getSymbolFactory(type);
		return Symbol$3().type(symbolFactory).size(calculateAreaSize(size, sizeType, type))();
	};
	var className = props.className, cx = props.cx, cy = props.cy;
	var filteredProps = filterProps(props, true);
	if (cx === +cx && cy === +cy && size === +size) return /* @__PURE__ */ import_react.createElement("path", _extends$25({}, filteredProps, {
		className: clsx_default("recharts-symbols", className),
		transform: "translate(".concat(cx, ", ").concat(cy, ")"),
		d: getPath$2()
	}));
	return null;
};
Symbols.registerSymbol = registerSymbol;
var import_isFunction$17 = /* @__PURE__ */ __toESM(require_isFunction());
function _typeof$43(o$1) {
	"@babel/helpers - typeof";
	return _typeof$43 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$2) {
		return typeof o$2;
	} : function(o$2) {
		return o$2 && "function" == typeof Symbol && o$2.constructor === Symbol && o$2 !== Symbol.prototype ? "symbol" : typeof o$2;
	}, _typeof$43(o$1);
}
function _extends$24() {
	_extends$24 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i$2 = 1; i$2 < arguments.length; i$2++) {
			var source = arguments[i$2];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$24.apply(this, arguments);
}
function ownKeys$35(e, r$1) {
	var t$1 = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o$1 = Object.getOwnPropertySymbols(e);
		r$1 && (o$1 = o$1.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t$1.push.apply(t$1, o$1);
	}
	return t$1;
}
function _objectSpread$35(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t$1 = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$35(Object(t$1), !0).forEach(function(r$2) {
			_defineProperty$40(e, r$2, t$1[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t$1)) : ownKeys$35(Object(t$1)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t$1, r$2));
		});
	}
	return e;
}
function _classCallCheck$19(instance, Constructor) {
	if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties$19(target, props) {
	for (var i$2 = 0; i$2 < props.length; i$2++) {
		var descriptor = props[i$2];
		descriptor.enumerable = descriptor.enumerable || false;
		descriptor.configurable = true;
		if ("value" in descriptor) descriptor.writable = true;
		Object.defineProperty(target, _toPropertyKey$41(descriptor.key), descriptor);
	}
}
function _createClass$19(Constructor, protoProps, staticProps) {
	if (protoProps) _defineProperties$19(Constructor.prototype, protoProps);
	if (staticProps) _defineProperties$19(Constructor, staticProps);
	Object.defineProperty(Constructor, "prototype", { writable: false });
	return Constructor;
}
function _callSuper$15(t$1, o$1, e) {
	return o$1 = _getPrototypeOf$16(o$1), _possibleConstructorReturn$16(t$1, _isNativeReflectConstruct$16() ? Reflect.construct(o$1, e || [], _getPrototypeOf$16(t$1).constructor) : o$1.apply(t$1, e));
}
function _possibleConstructorReturn$16(self$1, call) {
	if (call && (_typeof$43(call) === "object" || typeof call === "function")) return call;
	else if (call !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
	return _assertThisInitialized$16(self$1);
}
function _assertThisInitialized$16(self$1) {
	if (self$1 === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	return self$1;
}
function _isNativeReflectConstruct$16() {
	try {
		var t$1 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
	} catch (t$2) {}
	return (_isNativeReflectConstruct$16 = function _isNativeReflectConstruct$17() {
		return !!t$1;
	})();
}
function _getPrototypeOf$16(o$1) {
	_getPrototypeOf$16 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf$17(o$2) {
		return o$2.__proto__ || Object.getPrototypeOf(o$2);
	};
	return _getPrototypeOf$16(o$1);
}
function _inherits$16(subClass, superClass) {
	if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
	subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: {
		value: subClass,
		writable: true,
		configurable: true
	} });
	Object.defineProperty(subClass, "prototype", { writable: false });
	if (superClass) _setPrototypeOf$16(subClass, superClass);
}
function _setPrototypeOf$16(o$1, p) {
	_setPrototypeOf$16 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf$17(o$2, p$1) {
		o$2.__proto__ = p$1;
		return o$2;
	};
	return _setPrototypeOf$16(o$1, p);
}
function _defineProperty$40(obj, key, value) {
	key = _toPropertyKey$41(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$41(t$1) {
	var i$2 = _toPrimitive$41(t$1, "string");
	return "symbol" == _typeof$43(i$2) ? i$2 : i$2 + "";
}
function _toPrimitive$41(t$1, r$1) {
	if ("object" != _typeof$43(t$1) || !t$1) return t$1;
	var e = t$1[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i$2 = e.call(t$1, r$1 || "default");
		if ("object" != _typeof$43(i$2)) return i$2;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t$1);
}
var SIZE = 32;
var DefaultLegendContent = /* @__PURE__ */ function(_PureComponent) {
	function DefaultLegendContent$1() {
		_classCallCheck$19(this, DefaultLegendContent$1);
		return _callSuper$15(this, DefaultLegendContent$1, arguments);
	}
	_inherits$16(DefaultLegendContent$1, _PureComponent);
	return _createClass$19(DefaultLegendContent$1, [
		{
			key: "renderIcon",
			value: function renderIcon(data) {
				var inactiveColor = this.props.inactiveColor;
				var halfSize = SIZE / 2;
				var sixthSize = SIZE / 6;
				var thirdSize = SIZE / 3;
				var color$1 = data.inactive ? inactiveColor : data.color;
				if (data.type === "plainline") return /* @__PURE__ */ import_react.createElement("line", {
					strokeWidth: 4,
					fill: "none",
					stroke: color$1,
					strokeDasharray: data.payload.strokeDasharray,
					x1: 0,
					y1: halfSize,
					x2: SIZE,
					y2: halfSize,
					className: "recharts-legend-icon"
				});
				if (data.type === "line") return /* @__PURE__ */ import_react.createElement("path", {
					strokeWidth: 4,
					fill: "none",
					stroke: color$1,
					d: "M0,".concat(halfSize, "h").concat(thirdSize, "\n            A").concat(sixthSize, ",").concat(sixthSize, ",0,1,1,").concat(2 * thirdSize, ",").concat(halfSize, "\n            H").concat(SIZE, "M").concat(2 * thirdSize, ",").concat(halfSize, "\n            A").concat(sixthSize, ",").concat(sixthSize, ",0,1,1,").concat(thirdSize, ",").concat(halfSize),
					className: "recharts-legend-icon"
				});
				if (data.type === "rect") return /* @__PURE__ */ import_react.createElement("path", {
					stroke: "none",
					fill: color$1,
					d: "M0,".concat(SIZE / 8, "h").concat(SIZE, "v").concat(SIZE * 3 / 4, "h").concat(-SIZE, "z"),
					className: "recharts-legend-icon"
				});
				if (/* @__PURE__ */ import_react.isValidElement(data.legendIcon)) {
					var iconProps = _objectSpread$35({}, data);
					delete iconProps.legendIcon;
					return /* @__PURE__ */ import_react.cloneElement(data.legendIcon, iconProps);
				}
				return /* @__PURE__ */ import_react.createElement(Symbols, {
					fill: color$1,
					cx: halfSize,
					cy: halfSize,
					size: SIZE,
					sizeType: "diameter",
					type: data.type
				});
			}
		},
		{
			key: "renderItems",
			value: function renderItems() {
				var _this = this;
				var _this$props = this.props, payload = _this$props.payload, iconSize = _this$props.iconSize, layout = _this$props.layout, formatter = _this$props.formatter, inactiveColor = _this$props.inactiveColor;
				var viewBox = {
					x: 0,
					y: 0,
					width: SIZE,
					height: SIZE
				};
				var itemStyle = {
					display: layout === "horizontal" ? "inline-block" : "block",
					marginRight: 10
				};
				var svgStyle = {
					display: "inline-block",
					verticalAlign: "middle",
					marginRight: 4
				};
				return payload.map(function(entry, i$2) {
					var finalFormatter = entry.formatter || formatter;
					var className = clsx_default(_defineProperty$40(_defineProperty$40({ "recharts-legend-item": true }, "legend-item-".concat(i$2), true), "inactive", entry.inactive));
					if (entry.type === "none") return null;
					var entryValue = !(0, import_isFunction$17.default)(entry.value) ? entry.value : null;
					warn(!(0, import_isFunction$17.default)(entry.value), "The name property is also required when using a function for the dataKey of a chart's cartesian components. Ex: <Bar name=\"Name of my Data\"/>");
					var color$1 = entry.inactive ? inactiveColor : entry.color;
					return /* @__PURE__ */ import_react.createElement("li", _extends$24({
						className,
						style: itemStyle,
						key: "legend-item-".concat(i$2)
					}, adaptEventsOfChild(_this.props, entry, i$2)), /* @__PURE__ */ import_react.createElement(Surface, {
						width: iconSize,
						height: iconSize,
						viewBox,
						style: svgStyle
					}, _this.renderIcon(entry)), /* @__PURE__ */ import_react.createElement("span", {
						className: "recharts-legend-item-text",
						style: { color: color$1 }
					}, finalFormatter ? finalFormatter(entryValue, entry, i$2) : entryValue));
				});
			}
		},
		{
			key: "render",
			value: function render() {
				var _this$props2 = this.props, payload = _this$props2.payload, layout = _this$props2.layout, align = _this$props2.align;
				if (!payload || !payload.length) return null;
				var finalStyle = {
					padding: 0,
					margin: 0,
					textAlign: layout === "horizontal" ? align : "left"
				};
				return /* @__PURE__ */ import_react.createElement("ul", {
					className: "recharts-default-legend",
					style: finalStyle
				}, this.renderItems());
			}
		}
	]);
}(import_react.PureComponent);
_defineProperty$40(DefaultLegendContent, "displayName", "Legend");
_defineProperty$40(DefaultLegendContent, "defaultProps", {
	iconSize: 14,
	layout: "horizontal",
	align: "center",
	verticalAlign: "middle",
	inactiveColor: "#ccc"
});
var require__stackClear = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var ListCache$2 = require__ListCache();
	function stackClear$1() {
		this.__data__ = new ListCache$2();
		this.size = 0;
	}
	module.exports = stackClear$1;
}));
var require__stackDelete = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function stackDelete$1(key) {
		var data = this.__data__, result = data["delete"](key);
		this.size = data.size;
		return result;
	}
	module.exports = stackDelete$1;
}));
var require__stackGet = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function stackGet$1(key) {
		return this.__data__.get(key);
	}
	module.exports = stackGet$1;
}));
var require__stackHas = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function stackHas$1(key) {
		return this.__data__.has(key);
	}
	module.exports = stackHas$1;
}));
var require__stackSet = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var ListCache$1 = require__ListCache(), Map$2 = require__Map(), MapCache$1 = require__MapCache();
	var LARGE_ARRAY_SIZE$1 = 200;
	function stackSet$1(key, value) {
		var data = this.__data__;
		if (data instanceof ListCache$1) {
			var pairs = data.__data__;
			if (!Map$2 || pairs.length < LARGE_ARRAY_SIZE$1 - 1) {
				pairs.push([key, value]);
				this.size = ++data.size;
				return this;
			}
			data = this.__data__ = new MapCache$1(pairs);
		}
		data.set(key, value);
		this.size = data.size;
		return this;
	}
	module.exports = stackSet$1;
}));
var require__Stack = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var ListCache = require__ListCache(), stackClear = require__stackClear(), stackDelete = require__stackDelete(), stackGet = require__stackGet(), stackHas = require__stackHas(), stackSet = require__stackSet();
	function Stack$2(entries) {
		this.size = (this.__data__ = new ListCache(entries)).size;
	}
	Stack$2.prototype.clear = stackClear;
	Stack$2.prototype["delete"] = stackDelete;
	Stack$2.prototype.get = stackGet;
	Stack$2.prototype.has = stackHas;
	Stack$2.prototype.set = stackSet;
	module.exports = Stack$2;
}));
var require__setCacheAdd = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var HASH_UNDEFINED = "__lodash_hash_undefined__";
	function setCacheAdd$1(value) {
		this.__data__.set(value, HASH_UNDEFINED);
		return this;
	}
	module.exports = setCacheAdd$1;
}));
var require__setCacheHas = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function setCacheHas$1(value) {
		return this.__data__.has(value);
	}
	module.exports = setCacheHas$1;
}));
var require__SetCache = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var MapCache = require__MapCache(), setCacheAdd = require__setCacheAdd(), setCacheHas = require__setCacheHas();
	function SetCache$2(values) {
		var index = -1, length = values == null ? 0 : values.length;
		this.__data__ = new MapCache();
		while (++index < length) this.add(values[index]);
	}
	SetCache$2.prototype.add = SetCache$2.prototype.push = setCacheAdd;
	SetCache$2.prototype.has = setCacheHas;
	module.exports = SetCache$2;
}));
var require__arraySome = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function arraySome$2(array$1, predicate) {
		var index = -1, length = array$1 == null ? 0 : array$1.length;
		while (++index < length) if (predicate(array$1[index], index, array$1)) return true;
		return false;
	}
	module.exports = arraySome$2;
}));
var require__cacheHas = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function cacheHas$2(cache, key) {
		return cache.has(key);
	}
	module.exports = cacheHas$2;
}));
var require__equalArrays = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var SetCache$1 = require__SetCache(), arraySome$1 = require__arraySome(), cacheHas$1 = require__cacheHas();
	var COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;
	function equalArrays$2(array$1, other, bitmask, customizer, equalFunc, stack) {
		var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5, arrLength = array$1.length, othLength = other.length;
		if (arrLength != othLength && !(isPartial && othLength > arrLength)) return false;
		var arrStacked = stack.get(array$1);
		var othStacked = stack.get(other);
		if (arrStacked && othStacked) return arrStacked == other && othStacked == array$1;
		var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache$1() : void 0;
		stack.set(array$1, other);
		stack.set(other, array$1);
		while (++index < arrLength) {
			var arrValue = array$1[index], othValue = other[index];
			if (customizer) var compared = isPartial ? customizer(othValue, arrValue, index, other, array$1, stack) : customizer(arrValue, othValue, index, array$1, other, stack);
			if (compared !== void 0) {
				if (compared) continue;
				result = false;
				break;
			}
			if (seen) {
				if (!arraySome$1(other, function(othValue$1, othIndex) {
					if (!cacheHas$1(seen, othIndex) && (arrValue === othValue$1 || equalFunc(arrValue, othValue$1, bitmask, customizer, stack))) return seen.push(othIndex);
				})) {
					result = false;
					break;
				}
			} else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
				result = false;
				break;
			}
		}
		stack["delete"](array$1);
		stack["delete"](other);
		return result;
	}
	module.exports = equalArrays$2;
}));
var require__Uint8Array = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = require__root().Uint8Array;
}));
var require__mapToArray = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function mapToArray$1(map$4) {
		var index = -1, result = Array(map$4.size);
		map$4.forEach(function(value, key) {
			result[++index] = [key, value];
		});
		return result;
	}
	module.exports = mapToArray$1;
}));
var require__setToArray = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function setToArray$3(set$1) {
		var index = -1, result = Array(set$1.size);
		set$1.forEach(function(value) {
			result[++index] = value;
		});
		return result;
	}
	module.exports = setToArray$3;
}));
var require__equalByTag = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Symbol$2 = require__Symbol(), Uint8Array$1 = require__Uint8Array(), eq$1 = require_eq(), equalArrays$1 = require__equalArrays(), mapToArray = require__mapToArray(), setToArray$2 = require__setToArray();
	var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2;
	var boolTag$2 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", symbolTag = "[object Symbol]";
	var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]";
	var symbolProto = Symbol$2 ? Symbol$2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
	function equalByTag$1(object$1, other, tag, bitmask, customizer, equalFunc, stack) {
		switch (tag) {
			case dataViewTag$2:
				if (object$1.byteLength != other.byteLength || object$1.byteOffset != other.byteOffset) return false;
				object$1 = object$1.buffer;
				other = other.buffer;
			case arrayBufferTag$1:
				if (object$1.byteLength != other.byteLength || !equalFunc(new Uint8Array$1(object$1), new Uint8Array$1(other))) return false;
				return true;
			case boolTag$2:
			case dateTag$1:
			case numberTag$1: return eq$1(+object$1, +other);
			case errorTag$1: return object$1.name == other.name && object$1.message == other.message;
			case regexpTag$1:
			case stringTag$1: return object$1 == other + "";
			case mapTag$2: var convert = mapToArray;
			case setTag$2:
				var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
				convert || (convert = setToArray$2);
				if (object$1.size != other.size && !isPartial) return false;
				var stacked = stack.get(object$1);
				if (stacked) return stacked == other;
				bitmask |= COMPARE_UNORDERED_FLAG$2;
				stack.set(object$1, other);
				var result = equalArrays$1(convert(object$1), convert(other), bitmask, customizer, equalFunc, stack);
				stack["delete"](object$1);
				return result;
			case symbolTag: if (symbolValueOf) return symbolValueOf.call(object$1) == symbolValueOf.call(other);
		}
		return false;
	}
	module.exports = equalByTag$1;
}));
var require__arrayPush = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function arrayPush$2(array$1, values) {
		var index = -1, length = values.length, offset = array$1.length;
		while (++index < length) array$1[offset + index] = values[index];
		return array$1;
	}
	module.exports = arrayPush$2;
}));
var require__baseGetAllKeys = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var arrayPush$1 = require__arrayPush(), isArray$9 = require_isArray();
	function baseGetAllKeys$1(object$1, keysFunc, symbolsFunc) {
		var result = keysFunc(object$1);
		return isArray$9(object$1) ? result : arrayPush$1(result, symbolsFunc(object$1));
	}
	module.exports = baseGetAllKeys$1;
}));
var require__arrayFilter = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function arrayFilter$1(array$1, predicate) {
		var index = -1, length = array$1 == null ? 0 : array$1.length, resIndex = 0, result = [];
		while (++index < length) {
			var value = array$1[index];
			if (predicate(value, index, array$1)) result[resIndex++] = value;
		}
		return result;
	}
	module.exports = arrayFilter$1;
}));
var require_stubArray = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function stubArray$1() {
		return [];
	}
	module.exports = stubArray$1;
}));
var require__getSymbols = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var arrayFilter = require__arrayFilter(), stubArray = require_stubArray();
	var propertyIsEnumerable$1 = Object.prototype.propertyIsEnumerable;
	var nativeGetSymbols = Object.getOwnPropertySymbols;
	module.exports = !nativeGetSymbols ? stubArray : function(object$1) {
		if (object$1 == null) return [];
		object$1 = Object(object$1);
		return arrayFilter(nativeGetSymbols(object$1), function(symbol) {
			return propertyIsEnumerable$1.call(object$1, symbol);
		});
	};
}));
var require__baseTimes = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function baseTimes$1(n$1, iteratee) {
		var index = -1, result = Array(n$1);
		while (++index < n$1) result[index] = iteratee(index);
		return result;
	}
	module.exports = baseTimes$1;
}));
var require__baseIsArguments = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseGetTag$4 = require__baseGetTag(), isObjectLike$5 = require_isObjectLike();
	var argsTag$2 = "[object Arguments]";
	function baseIsArguments$1(value) {
		return isObjectLike$5(value) && baseGetTag$4(value) == argsTag$2;
	}
	module.exports = baseIsArguments$1;
}));
var require_isArguments = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseIsArguments = require__baseIsArguments(), isObjectLike$4 = require_isObjectLike();
	var objectProto$2 = Object.prototype;
	var hasOwnProperty$7 = objectProto$2.hasOwnProperty;
	var propertyIsEnumerable = objectProto$2.propertyIsEnumerable;
	module.exports = baseIsArguments(function() {
		return arguments;
	}()) ? baseIsArguments : function(value) {
		return isObjectLike$4(value) && hasOwnProperty$7.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
	};
}));
var require_stubFalse = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function stubFalse$1() {
		return false;
	}
	module.exports = stubFalse$1;
}));
var require_isBuffer = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var root$1 = require__root(), stubFalse = require_stubFalse();
	var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
	var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
	var Buffer = freeModule$1 && freeModule$1.exports === freeExports$1 ? root$1.Buffer : void 0;
	module.exports = (Buffer ? Buffer.isBuffer : void 0) || stubFalse;
}));
var require__isIndex = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var MAX_SAFE_INTEGER$1 = 9007199254740991;
	var reIsUint = /^(?:0|[1-9]\d*)$/;
	function isIndex$3(value, length) {
		var type = typeof value;
		length = length == null ? MAX_SAFE_INTEGER$1 : length;
		return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
	}
	module.exports = isIndex$3;
}));
var require_isLength = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var MAX_SAFE_INTEGER = 9007199254740991;
	function isLength$3(value) {
		return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}
	module.exports = isLength$3;
}));
var require__baseIsTypedArray = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseGetTag$3 = require__baseGetTag(), isLength$2 = require_isLength(), isObjectLike$3 = require_isObjectLike();
	var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$1 = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", mapTag$1 = "[object Map]", numberTag = "[object Number]", objectTag$3 = "[object Object]", regexpTag = "[object RegExp]", setTag$1 = "[object Set]", stringTag = "[object String]", weakMapTag$1 = "[object WeakMap]";
	var arrayBufferTag = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
	var typedArrayTags = {};
	typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
	typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag$1] = typedArrayTags[dataViewTag$1] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag$1] = typedArrayTags[numberTag] = typedArrayTags[objectTag$3] = typedArrayTags[regexpTag] = typedArrayTags[setTag$1] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag$1] = false;
	function baseIsTypedArray$1(value) {
		return isObjectLike$3(value) && isLength$2(value.length) && !!typedArrayTags[baseGetTag$3(value)];
	}
	module.exports = baseIsTypedArray$1;
}));
var require__baseUnary = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function baseUnary$2(func) {
		return function(value) {
			return func(value);
		};
	}
	module.exports = baseUnary$2;
}));
var require__nodeUtil = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var freeGlobal = require__freeGlobal();
	var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
	var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
	var freeProcess = freeModule && freeModule.exports === freeExports && freeGlobal.process;
	module.exports = function() {
		try {
			var types = freeModule && freeModule.require && freeModule.require("util").types;
			if (types) return types;
			return freeProcess && freeProcess.binding && freeProcess.binding("util");
		} catch (e) {}
	}();
}));
var require_isTypedArray = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseIsTypedArray = require__baseIsTypedArray(), baseUnary$1 = require__baseUnary(), nodeUtil = require__nodeUtil();
	var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
	module.exports = nodeIsTypedArray ? baseUnary$1(nodeIsTypedArray) : baseIsTypedArray;
}));
var require__arrayLikeKeys = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseTimes = require__baseTimes(), isArguments$2 = require_isArguments(), isArray$8 = require_isArray(), isBuffer$1 = require_isBuffer(), isIndex$2 = require__isIndex(), isTypedArray$1 = require_isTypedArray();
	var hasOwnProperty$6 = Object.prototype.hasOwnProperty;
	function arrayLikeKeys$1(value, inherited) {
		var isArr = isArray$8(value), isArg = !isArr && isArguments$2(value), isBuff = !isArr && !isArg && isBuffer$1(value), isType = !isArr && !isArg && !isBuff && isTypedArray$1(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
		for (var key in value) if ((inherited || hasOwnProperty$6.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex$2(key, length)))) result.push(key);
		return result;
	}
	module.exports = arrayLikeKeys$1;
}));
var require__isPrototype = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var objectProto$1 = Object.prototype;
	function isPrototype$1(value) {
		var Ctor = value && value.constructor;
		return value === (typeof Ctor == "function" && Ctor.prototype || objectProto$1);
	}
	module.exports = isPrototype$1;
}));
var require__overArg = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function overArg(func, transform$1) {
		return function(arg) {
			return func(transform$1(arg));
		};
	}
	module.exports = overArg;
}));
var require__nativeKeys = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = require__overArg()(Object.keys, Object);
}));
var require__baseKeys = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var isPrototype = require__isPrototype(), nativeKeys = require__nativeKeys();
	var hasOwnProperty$5 = Object.prototype.hasOwnProperty;
	function baseKeys$1(object$1) {
		if (!isPrototype(object$1)) return nativeKeys(object$1);
		var result = [];
		for (var key in Object(object$1)) if (hasOwnProperty$5.call(object$1, key) && key != "constructor") result.push(key);
		return result;
	}
	module.exports = baseKeys$1;
}));
var require_isArrayLike = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var isFunction$17 = require_isFunction(), isLength$1 = require_isLength();
	function isArrayLike$5(value) {
		return value != null && isLength$1(value.length) && !isFunction$17(value);
	}
	module.exports = isArrayLike$5;
}));
var require_keys = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var arrayLikeKeys = require__arrayLikeKeys(), baseKeys = require__baseKeys(), isArrayLike$4 = require_isArrayLike();
	function keys$5(object$1) {
		return isArrayLike$4(object$1) ? arrayLikeKeys(object$1) : baseKeys(object$1);
	}
	module.exports = keys$5;
}));
var require__getAllKeys = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseGetAllKeys = require__baseGetAllKeys(), getSymbols = require__getSymbols(), keys$4 = require_keys();
	function getAllKeys$1(object$1) {
		return baseGetAllKeys(object$1, keys$4, getSymbols);
	}
	module.exports = getAllKeys$1;
}));
var require__equalObjects = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var getAllKeys = require__getAllKeys();
	var COMPARE_PARTIAL_FLAG$3 = 1;
	var hasOwnProperty$4 = Object.prototype.hasOwnProperty;
	function equalObjects$1(object$1, other, bitmask, customizer, equalFunc, stack) {
		var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, objProps = getAllKeys(object$1), objLength = objProps.length;
		if (objLength != getAllKeys(other).length && !isPartial) return false;
		var index = objLength;
		while (index--) {
			var key = objProps[index];
			if (!(isPartial ? key in other : hasOwnProperty$4.call(other, key))) return false;
		}
		var objStacked = stack.get(object$1);
		var othStacked = stack.get(other);
		if (objStacked && othStacked) return objStacked == other && othStacked == object$1;
		var result = true;
		stack.set(object$1, other);
		stack.set(other, object$1);
		var skipCtor = isPartial;
		while (++index < objLength) {
			key = objProps[index];
			var objValue = object$1[key], othValue = other[key];
			if (customizer) var compared = isPartial ? customizer(othValue, objValue, key, other, object$1, stack) : customizer(objValue, othValue, key, object$1, other, stack);
			if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
				result = false;
				break;
			}
			skipCtor || (skipCtor = key == "constructor");
		}
		if (result && !skipCtor) {
			var objCtor = object$1.constructor, othCtor = other.constructor;
			if (objCtor != othCtor && "constructor" in object$1 && "constructor" in other && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) result = false;
		}
		stack["delete"](object$1);
		stack["delete"](other);
		return result;
	}
	module.exports = equalObjects$1;
}));
var require__DataView = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = require__getNative()(require__root(), "DataView");
}));
var require__Promise = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = require__getNative()(require__root(), "Promise");
}));
var require__Set = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = require__getNative()(require__root(), "Set");
}));
var require__WeakMap = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = require__getNative()(require__root(), "WeakMap");
}));
var require__getTag = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var DataView$1 = require__DataView(), Map$1 = require__Map(), Promise$1 = require__Promise(), Set$2 = require__Set(), WeakMap$1 = require__WeakMap(), baseGetTag$2 = require__baseGetTag(), toSource = require__toSource();
	var mapTag = "[object Map]", objectTag$2 = "[object Object]", promiseTag = "[object Promise]", setTag = "[object Set]", weakMapTag = "[object WeakMap]";
	var dataViewTag = "[object DataView]";
	var dataViewCtorString = toSource(DataView$1), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$2), weakMapCtorString = toSource(WeakMap$1);
	var getTag$1 = baseGetTag$2;
	if (DataView$1 && getTag$1(new DataView$1(/* @__PURE__ */ new ArrayBuffer(1))) != dataViewTag || Map$1 && getTag$1(new Map$1()) != mapTag || Promise$1 && getTag$1(Promise$1.resolve()) != promiseTag || Set$2 && getTag$1(new Set$2()) != setTag || WeakMap$1 && getTag$1(new WeakMap$1()) != weakMapTag) getTag$1 = function(value) {
		var result = baseGetTag$2(value), Ctor = result == objectTag$2 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
		if (ctorString) switch (ctorString) {
			case dataViewCtorString: return dataViewTag;
			case mapCtorString: return mapTag;
			case promiseCtorString: return promiseTag;
			case setCtorString: return setTag;
			case weakMapCtorString: return weakMapTag;
		}
		return result;
	};
	module.exports = getTag$1;
}));
var require__baseIsEqualDeep = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Stack$1 = require__Stack(), equalArrays = require__equalArrays(), equalByTag = require__equalByTag(), equalObjects = require__equalObjects(), getTag = require__getTag(), isArray$7 = require_isArray(), isBuffer = require_isBuffer(), isTypedArray = require_isTypedArray();
	var COMPARE_PARTIAL_FLAG$2 = 1;
	var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag$1 = "[object Object]";
	var hasOwnProperty$3 = Object.prototype.hasOwnProperty;
	function baseIsEqualDeep$1(object$1, other, bitmask, customizer, equalFunc, stack) {
		var objIsArr = isArray$7(object$1), othIsArr = isArray$7(other), objTag = objIsArr ? arrayTag : getTag(object$1), othTag = othIsArr ? arrayTag : getTag(other);
		objTag = objTag == argsTag ? objectTag$1 : objTag;
		othTag = othTag == argsTag ? objectTag$1 : othTag;
		var objIsObj = objTag == objectTag$1, othIsObj = othTag == objectTag$1, isSameTag = objTag == othTag;
		if (isSameTag && isBuffer(object$1)) {
			if (!isBuffer(other)) return false;
			objIsArr = true;
			objIsObj = false;
		}
		if (isSameTag && !objIsObj) {
			stack || (stack = new Stack$1());
			return objIsArr || isTypedArray(object$1) ? equalArrays(object$1, other, bitmask, customizer, equalFunc, stack) : equalByTag(object$1, other, objTag, bitmask, customizer, equalFunc, stack);
		}
		if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
			var objIsWrapped = objIsObj && hasOwnProperty$3.call(object$1, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty$3.call(other, "__wrapped__");
			if (objIsWrapped || othIsWrapped) {
				var objUnwrapped = objIsWrapped ? object$1.value() : object$1, othUnwrapped = othIsWrapped ? other.value() : other;
				stack || (stack = new Stack$1());
				return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
			}
		}
		if (!isSameTag) return false;
		stack || (stack = new Stack$1());
		return equalObjects(object$1, other, bitmask, customizer, equalFunc, stack);
	}
	module.exports = baseIsEqualDeep$1;
}));
var require__baseIsEqual = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseIsEqualDeep = require__baseIsEqualDeep(), isObjectLike$2 = require_isObjectLike();
	function baseIsEqual$3(value, other, bitmask, customizer, stack) {
		if (value === other) return true;
		if (value == null || other == null || !isObjectLike$2(value) && !isObjectLike$2(other)) return value !== value && other !== other;
		return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual$3, stack);
	}
	module.exports = baseIsEqual$3;
}));
var require__baseIsMatch = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Stack = require__Stack(), baseIsEqual$2 = require__baseIsEqual();
	var COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
	function baseIsMatch$1(object$1, source, matchData, customizer) {
		var index = matchData.length, length = index, noCustomizer = !customizer;
		if (object$1 == null) return !length;
		object$1 = Object(object$1);
		while (index--) {
			var data = matchData[index];
			if (noCustomizer && data[2] ? data[1] !== object$1[data[0]] : !(data[0] in object$1)) return false;
		}
		while (++index < length) {
			data = matchData[index];
			var key = data[0], objValue = object$1[key], srcValue = data[1];
			if (noCustomizer && data[2]) {
				if (objValue === void 0 && !(key in object$1)) return false;
			} else {
				var stack = new Stack();
				if (customizer) var result = customizer(objValue, srcValue, key, object$1, source, stack);
				if (!(result === void 0 ? baseIsEqual$2(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack) : result)) return false;
			}
		}
		return true;
	}
	module.exports = baseIsMatch$1;
}));
var require__isStrictComparable = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var isObject$6 = require_isObject();
	function isStrictComparable$2(value) {
		return value === value && !isObject$6(value);
	}
	module.exports = isStrictComparable$2;
}));
var require__getMatchData = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var isStrictComparable$1 = require__isStrictComparable(), keys$3 = require_keys();
	function getMatchData$1(object$1) {
		var result = keys$3(object$1), length = result.length;
		while (length--) {
			var key = result[length], value = object$1[key];
			result[length] = [
				key,
				value,
				isStrictComparable$1(value)
			];
		}
		return result;
	}
	module.exports = getMatchData$1;
}));
var require__matchesStrictComparable = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function matchesStrictComparable$2(key, srcValue) {
		return function(object$1) {
			if (object$1 == null) return false;
			return object$1[key] === srcValue && (srcValue !== void 0 || key in Object(object$1));
		};
	}
	module.exports = matchesStrictComparable$2;
}));
var require__baseMatches = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseIsMatch = require__baseIsMatch(), getMatchData = require__getMatchData(), matchesStrictComparable$1 = require__matchesStrictComparable();
	function baseMatches$1(source) {
		var matchData = getMatchData(source);
		if (matchData.length == 1 && matchData[0][2]) return matchesStrictComparable$1(matchData[0][0], matchData[0][1]);
		return function(object$1) {
			return object$1 === source || baseIsMatch(object$1, source, matchData);
		};
	}
	module.exports = baseMatches$1;
}));
var require__baseHasIn = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function baseHasIn$1(object$1, key) {
		return object$1 != null && key in Object(object$1);
	}
	module.exports = baseHasIn$1;
}));
var require__hasPath = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var castPath = require__castPath(), isArguments$1 = require_isArguments(), isArray$6 = require_isArray(), isIndex$1 = require__isIndex(), isLength = require_isLength(), toKey$2 = require__toKey();
	function hasPath$1(object$1, path$1, hasFunc) {
		path$1 = castPath(path$1, object$1);
		var index = -1, length = path$1.length, result = false;
		while (++index < length) {
			var key = toKey$2(path$1[index]);
			if (!(result = object$1 != null && hasFunc(object$1, key))) break;
			object$1 = object$1[key];
		}
		if (result || ++index != length) return result;
		length = object$1 == null ? 0 : object$1.length;
		return !!length && isLength(length) && isIndex$1(key, length) && (isArray$6(object$1) || isArguments$1(object$1));
	}
	module.exports = hasPath$1;
}));
var require_hasIn = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseHasIn = require__baseHasIn(), hasPath = require__hasPath();
	function hasIn$1(object$1, path$1) {
		return object$1 != null && hasPath(object$1, path$1, baseHasIn);
	}
	module.exports = hasIn$1;
}));
var require__baseMatchesProperty = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseIsEqual$1 = require__baseIsEqual(), get$3 = require_get(), hasIn = require_hasIn(), isKey$1 = require__isKey(), isStrictComparable = require__isStrictComparable(), matchesStrictComparable = require__matchesStrictComparable(), toKey$1 = require__toKey();
	var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
	function baseMatchesProperty$1(path$1, srcValue) {
		if (isKey$1(path$1) && isStrictComparable(srcValue)) return matchesStrictComparable(toKey$1(path$1), srcValue);
		return function(object$1) {
			var objValue = get$3(object$1, path$1);
			return objValue === void 0 && objValue === srcValue ? hasIn(object$1, path$1) : baseIsEqual$1(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
		};
	}
	module.exports = baseMatchesProperty$1;
}));
var require_identity = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function identity$10(value) {
		return value;
	}
	module.exports = identity$10;
}));
var require__baseProperty = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function baseProperty$1(key) {
		return function(object$1) {
			return object$1 == null ? void 0 : object$1[key];
		};
	}
	module.exports = baseProperty$1;
}));
var require__basePropertyDeep = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseGet$1 = require__baseGet();
	function basePropertyDeep$1(path$1) {
		return function(object$1) {
			return baseGet$1(object$1, path$1);
		};
	}
	module.exports = basePropertyDeep$1;
}));
var require_property = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseProperty = require__baseProperty(), basePropertyDeep = require__basePropertyDeep(), isKey = require__isKey(), toKey = require__toKey();
	function property$1(path$1) {
		return isKey(path$1) ? baseProperty(toKey(path$1)) : basePropertyDeep(path$1);
	}
	module.exports = property$1;
}));
var require__baseIteratee = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseMatches = require__baseMatches(), baseMatchesProperty = require__baseMatchesProperty(), identity$9 = require_identity(), isArray$5 = require_isArray(), property = require_property();
	function baseIteratee$8(value) {
		if (typeof value == "function") return value;
		if (value == null) return identity$9;
		if (typeof value == "object") return isArray$5(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
		return property(value);
	}
	module.exports = baseIteratee$8;
}));
var require__baseFindIndex = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function baseFindIndex$2(array$1, predicate, fromIndex, fromRight) {
		var length = array$1.length, index = fromIndex + (fromRight ? 1 : -1);
		while (fromRight ? index-- : ++index < length) if (predicate(array$1[index], index, array$1)) return index;
		return -1;
	}
	module.exports = baseFindIndex$2;
}));
var require__baseIsNaN = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function baseIsNaN$1(value) {
		return value !== value;
	}
	module.exports = baseIsNaN$1;
}));
var require__strictIndexOf = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function strictIndexOf$1(array$1, value, fromIndex) {
		var index = fromIndex - 1, length = array$1.length;
		while (++index < length) if (array$1[index] === value) return index;
		return -1;
	}
	module.exports = strictIndexOf$1;
}));
var require__baseIndexOf = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseFindIndex$1 = require__baseFindIndex(), baseIsNaN = require__baseIsNaN(), strictIndexOf = require__strictIndexOf();
	function baseIndexOf$1(array$1, value, fromIndex) {
		return value === value ? strictIndexOf(array$1, value, fromIndex) : baseFindIndex$1(array$1, baseIsNaN, fromIndex);
	}
	module.exports = baseIndexOf$1;
}));
var require__arrayIncludes = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseIndexOf = require__baseIndexOf();
	function arrayIncludes$1(array$1, value) {
		return !!(array$1 == null ? 0 : array$1.length) && baseIndexOf(array$1, value, 0) > -1;
	}
	module.exports = arrayIncludes$1;
}));
var require__arrayIncludesWith = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function arrayIncludesWith$1(array$1, value, comparator) {
		var index = -1, length = array$1 == null ? 0 : array$1.length;
		while (++index < length) if (comparator(value, array$1[index])) return true;
		return false;
	}
	module.exports = arrayIncludesWith$1;
}));
var require_noop = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function noop$1() {}
	module.exports = noop$1;
}));
var require__createSet = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Set$1 = require__Set(), noop = require_noop(), setToArray$1 = require__setToArray();
	module.exports = !(Set$1 && 1 / setToArray$1(new Set$1([, -0]))[1] == Infinity) ? noop : function(values) {
		return new Set$1(values);
	};
}));
var require__baseUniq = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var SetCache = require__SetCache(), arrayIncludes = require__arrayIncludes(), arrayIncludesWith = require__arrayIncludesWith(), cacheHas = require__cacheHas(), createSet = require__createSet(), setToArray = require__setToArray();
	var LARGE_ARRAY_SIZE = 200;
	function baseUniq$1(array$1, iteratee, comparator) {
		var index = -1, includes = arrayIncludes, length = array$1.length, isCommon = true, result = [], seen = result;
		if (comparator) {
			isCommon = false;
			includes = arrayIncludesWith;
		} else if (length >= LARGE_ARRAY_SIZE) {
			var set$1 = iteratee ? null : createSet(array$1);
			if (set$1) return setToArray(set$1);
			isCommon = false;
			includes = cacheHas;
			seen = new SetCache();
		} else seen = iteratee ? [] : result;
		outer: while (++index < length) {
			var value = array$1[index], computed = iteratee ? iteratee(value) : value;
			value = comparator || value !== 0 ? value : 0;
			if (isCommon && computed === computed) {
				var seenIndex = seen.length;
				while (seenIndex--) if (seen[seenIndex] === computed) continue outer;
				if (iteratee) seen.push(computed);
				result.push(value);
			} else if (!includes(seen, computed, comparator)) {
				if (seen !== result) seen.push(computed);
				result.push(value);
			}
		}
		return result;
	}
	module.exports = baseUniq$1;
}));
var import_uniqBy = /* @__PURE__ */ __toESM((/* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseIteratee$7 = require__baseIteratee(), baseUniq = require__baseUniq();
	function uniqBy$1(array$1, iteratee) {
		return array$1 && array$1.length ? baseUniq(array$1, baseIteratee$7(iteratee, 2)) : [];
	}
	module.exports = uniqBy$1;
})))());
var import_isFunction$16 = /* @__PURE__ */ __toESM(require_isFunction());
function getUniqPayload(payload, option, defaultUniqBy$2) {
	if (option === true) return (0, import_uniqBy.default)(payload, defaultUniqBy$2);
	if ((0, import_isFunction$16.default)(option)) return (0, import_uniqBy.default)(payload, option);
	return payload;
}
function _typeof$42(o$1) {
	"@babel/helpers - typeof";
	return _typeof$42 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$2) {
		return typeof o$2;
	} : function(o$2) {
		return o$2 && "function" == typeof Symbol && o$2.constructor === Symbol && o$2 !== Symbol.prototype ? "symbol" : typeof o$2;
	}, _typeof$42(o$1);
}
var _excluded$14 = ["ref"];
function ownKeys$34(e, r$1) {
	var t$1 = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o$1 = Object.getOwnPropertySymbols(e);
		r$1 && (o$1 = o$1.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t$1.push.apply(t$1, o$1);
	}
	return t$1;
}
function _objectSpread$34(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t$1 = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$34(Object(t$1), !0).forEach(function(r$2) {
			_defineProperty$39(e, r$2, t$1[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t$1)) : ownKeys$34(Object(t$1)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t$1, r$2));
		});
	}
	return e;
}
function _classCallCheck$18(instance, Constructor) {
	if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties$18(target, props) {
	for (var i$2 = 0; i$2 < props.length; i$2++) {
		var descriptor = props[i$2];
		descriptor.enumerable = descriptor.enumerable || false;
		descriptor.configurable = true;
		if ("value" in descriptor) descriptor.writable = true;
		Object.defineProperty(target, _toPropertyKey$40(descriptor.key), descriptor);
	}
}
function _createClass$18(Constructor, protoProps, staticProps) {
	if (protoProps) _defineProperties$18(Constructor.prototype, protoProps);
	if (staticProps) _defineProperties$18(Constructor, staticProps);
	Object.defineProperty(Constructor, "prototype", { writable: false });
	return Constructor;
}
function _callSuper$14(t$1, o$1, e) {
	return o$1 = _getPrototypeOf$15(o$1), _possibleConstructorReturn$15(t$1, _isNativeReflectConstruct$15() ? Reflect.construct(o$1, e || [], _getPrototypeOf$15(t$1).constructor) : o$1.apply(t$1, e));
}
function _possibleConstructorReturn$15(self$1, call) {
	if (call && (_typeof$42(call) === "object" || typeof call === "function")) return call;
	else if (call !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
	return _assertThisInitialized$15(self$1);
}
function _assertThisInitialized$15(self$1) {
	if (self$1 === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	return self$1;
}
function _isNativeReflectConstruct$15() {
	try {
		var t$1 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
	} catch (t$2) {}
	return (_isNativeReflectConstruct$15 = function _isNativeReflectConstruct$17() {
		return !!t$1;
	})();
}
function _getPrototypeOf$15(o$1) {
	_getPrototypeOf$15 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf$17(o$2) {
		return o$2.__proto__ || Object.getPrototypeOf(o$2);
	};
	return _getPrototypeOf$15(o$1);
}
function _inherits$15(subClass, superClass) {
	if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
	subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: {
		value: subClass,
		writable: true,
		configurable: true
	} });
	Object.defineProperty(subClass, "prototype", { writable: false });
	if (superClass) _setPrototypeOf$15(subClass, superClass);
}
function _setPrototypeOf$15(o$1, p) {
	_setPrototypeOf$15 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf$17(o$2, p$1) {
		o$2.__proto__ = p$1;
		return o$2;
	};
	return _setPrototypeOf$15(o$1, p);
}
function _defineProperty$39(obj, key, value) {
	key = _toPropertyKey$40(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$40(t$1) {
	var i$2 = _toPrimitive$40(t$1, "string");
	return "symbol" == _typeof$42(i$2) ? i$2 : i$2 + "";
}
function _toPrimitive$40(t$1, r$1) {
	if ("object" != _typeof$42(t$1) || !t$1) return t$1;
	var e = t$1[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i$2 = e.call(t$1, r$1 || "default");
		if ("object" != _typeof$42(i$2)) return i$2;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t$1);
}
function _objectWithoutProperties$14(source, excluded) {
	if (source == null) return {};
	var target = _objectWithoutPropertiesLoose$14(source, excluded);
	var key, i$2;
	if (Object.getOwnPropertySymbols) {
		var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
		for (i$2 = 0; i$2 < sourceSymbolKeys.length; i$2++) {
			key = sourceSymbolKeys[i$2];
			if (excluded.indexOf(key) >= 0) continue;
			if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
			target[key] = source[key];
		}
	}
	return target;
}
function _objectWithoutPropertiesLoose$14(source, excluded) {
	if (source == null) return {};
	var target = {};
	for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) {
		if (excluded.indexOf(key) >= 0) continue;
		target[key] = source[key];
	}
	return target;
}
function defaultUniqBy$1(entry) {
	return entry.value;
}
function renderContent$1(content, props) {
	if (/* @__PURE__ */ import_react.isValidElement(content)) return /* @__PURE__ */ import_react.cloneElement(content, props);
	if (typeof content === "function") return /* @__PURE__ */ import_react.createElement(content, props);
	props.ref;
	var otherProps = _objectWithoutProperties$14(props, _excluded$14);
	return /* @__PURE__ */ import_react.createElement(DefaultLegendContent, otherProps);
}
var EPS$1 = 1;
var Legend = /* @__PURE__ */ function(_PureComponent) {
	function Legend$1() {
		var _this;
		_classCallCheck$18(this, Legend$1);
		for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
		_this = _callSuper$14(this, Legend$1, [].concat(args));
		_defineProperty$39(_this, "lastBoundingBox", {
			width: -1,
			height: -1
		});
		return _this;
	}
	_inherits$15(Legend$1, _PureComponent);
	return _createClass$18(Legend$1, [
		{
			key: "componentDidMount",
			value: function componentDidMount() {
				this.updateBBox();
			}
		},
		{
			key: "componentDidUpdate",
			value: function componentDidUpdate() {
				this.updateBBox();
			}
		},
		{
			key: "getBBox",
			value: function getBBox() {
				if (this.wrapperNode && this.wrapperNode.getBoundingClientRect) {
					var box = this.wrapperNode.getBoundingClientRect();
					box.height = this.wrapperNode.offsetHeight;
					box.width = this.wrapperNode.offsetWidth;
					return box;
				}
				return null;
			}
		},
		{
			key: "updateBBox",
			value: function updateBBox() {
				var onBBoxUpdate = this.props.onBBoxUpdate;
				var box = this.getBBox();
				if (box) {
					if (Math.abs(box.width - this.lastBoundingBox.width) > EPS$1 || Math.abs(box.height - this.lastBoundingBox.height) > EPS$1) {
						this.lastBoundingBox.width = box.width;
						this.lastBoundingBox.height = box.height;
						if (onBBoxUpdate) onBBoxUpdate(box);
					}
				} else if (this.lastBoundingBox.width !== -1 || this.lastBoundingBox.height !== -1) {
					this.lastBoundingBox.width = -1;
					this.lastBoundingBox.height = -1;
					if (onBBoxUpdate) onBBoxUpdate(null);
				}
			}
		},
		{
			key: "getBBoxSnapshot",
			value: function getBBoxSnapshot() {
				if (this.lastBoundingBox.width >= 0 && this.lastBoundingBox.height >= 0) return _objectSpread$34({}, this.lastBoundingBox);
				return {
					width: 0,
					height: 0
				};
			}
		},
		{
			key: "getDefaultPosition",
			value: function getDefaultPosition(style) {
				var _this$props = this.props, layout = _this$props.layout, align = _this$props.align, verticalAlign = _this$props.verticalAlign, margin = _this$props.margin, chartWidth = _this$props.chartWidth, chartHeight = _this$props.chartHeight;
				var hPos, vPos;
				if (!style || (style.left === void 0 || style.left === null) && (style.right === void 0 || style.right === null)) if (align === "center" && layout === "vertical") {
					var box = this.getBBoxSnapshot();
					hPos = { left: ((chartWidth || 0) - box.width) / 2 };
				} else hPos = align === "right" ? { right: margin && margin.right || 0 } : { left: margin && margin.left || 0 };
				if (!style || (style.top === void 0 || style.top === null) && (style.bottom === void 0 || style.bottom === null)) if (verticalAlign === "middle") {
					var _box = this.getBBoxSnapshot();
					vPos = { top: ((chartHeight || 0) - _box.height) / 2 };
				} else vPos = verticalAlign === "bottom" ? { bottom: margin && margin.bottom || 0 } : { top: margin && margin.top || 0 };
				return _objectSpread$34(_objectSpread$34({}, hPos), vPos);
			}
		},
		{
			key: "render",
			value: function render() {
				var _this2 = this;
				var _this$props2 = this.props, content = _this$props2.content, width = _this$props2.width, height = _this$props2.height, wrapperStyle = _this$props2.wrapperStyle, payloadUniqBy = _this$props2.payloadUniqBy, payload = _this$props2.payload;
				var outerStyle = _objectSpread$34(_objectSpread$34({
					position: "absolute",
					width: width || "auto",
					height: height || "auto"
				}, this.getDefaultPosition(wrapperStyle)), wrapperStyle);
				return /* @__PURE__ */ import_react.createElement("div", {
					className: "recharts-legend-wrapper",
					style: outerStyle,
					ref: function ref(node) {
						_this2.wrapperNode = node;
					}
				}, renderContent$1(content, _objectSpread$34(_objectSpread$34({}, this.props), {}, { payload: getUniqPayload(payload, payloadUniqBy, defaultUniqBy$1) })));
			}
		}
	], [{
		key: "getWithHeight",
		value: function getWithHeight(item, chartWidth) {
			var layout = _objectSpread$34(_objectSpread$34({}, this.defaultProps), item.props).layout;
			if (layout === "vertical" && isNumber(item.props.height)) return { height: item.props.height };
			if (layout === "horizontal") return { width: item.props.width || chartWidth };
			return null;
		}
	}]);
}(import_react.PureComponent);
_defineProperty$39(Legend, "displayName", "Legend");
_defineProperty$39(Legend, "defaultProps", {
	iconSize: 14,
	layout: "horizontal",
	align: "center",
	verticalAlign: "bottom"
});
var require__isFlattenable = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Symbol$1 = require__Symbol(), isArguments = require_isArguments(), isArray$4 = require_isArray();
	var spreadableSymbol = Symbol$1 ? Symbol$1.isConcatSpreadable : void 0;
	function isFlattenable$1(value) {
		return isArray$4(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
	}
	module.exports = isFlattenable$1;
}));
var require__baseFlatten = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var arrayPush = require__arrayPush(), isFlattenable = require__isFlattenable();
	function baseFlatten$2(array$1, depth, predicate, isStrict, result) {
		var index = -1, length = array$1.length;
		predicate || (predicate = isFlattenable);
		result || (result = []);
		while (++index < length) {
			var value = array$1[index];
			if (depth > 0 && predicate(value)) if (depth > 1) baseFlatten$2(value, depth - 1, predicate, isStrict, result);
			else arrayPush(result, value);
			else if (!isStrict) result[result.length] = value;
		}
		return result;
	}
	module.exports = baseFlatten$2;
}));
var require__createBaseFor = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function createBaseFor(fromRight) {
		return function(object$1, iteratee, keysFunc) {
			var index = -1, iterable = Object(object$1), props = keysFunc(object$1), length = props.length;
			while (length--) {
				var key = props[fromRight ? length : ++index];
				if (iteratee(iterable[key], key, iterable) === false) break;
			}
			return object$1;
		};
	}
	module.exports = createBaseFor;
}));
var require__baseFor = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = require__createBaseFor()();
}));
var require__baseForOwn = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseFor = require__baseFor(), keys$2 = require_keys();
	function baseForOwn$2(object$1, iteratee) {
		return object$1 && baseFor(object$1, iteratee, keys$2);
	}
	module.exports = baseForOwn$2;
}));
var require__createBaseEach = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var isArrayLike$3 = require_isArrayLike();
	function createBaseEach(eachFunc, fromRight) {
		return function(collection, iteratee) {
			if (collection == null) return collection;
			if (!isArrayLike$3(collection)) return eachFunc(collection, iteratee);
			var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
			while (fromRight ? index-- : ++index < length) if (iteratee(iterable[index], index, iterable) === false) break;
			return collection;
		};
	}
	module.exports = createBaseEach;
}));
var require__baseEach = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseForOwn$1 = require__baseForOwn();
	module.exports = require__createBaseEach()(baseForOwn$1);
}));
var require__baseMap = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseEach$2 = require__baseEach(), isArrayLike$2 = require_isArrayLike();
	function baseMap$2(collection, iteratee) {
		var index = -1, result = isArrayLike$2(collection) ? Array(collection.length) : [];
		baseEach$2(collection, function(value, key, collection$1) {
			result[++index] = iteratee(value, key, collection$1);
		});
		return result;
	}
	module.exports = baseMap$2;
}));
var require__baseSortBy = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function baseSortBy$1(array$1, comparer) {
		var length = array$1.length;
		array$1.sort(comparer);
		while (length--) array$1[length] = array$1[length].value;
		return array$1;
	}
	module.exports = baseSortBy$1;
}));
var require__compareAscending = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var isSymbol$2 = require_isSymbol();
	function compareAscending$1(value, other) {
		if (value !== other) {
			var valIsDefined = value !== void 0, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol$2(value);
			var othIsDefined = other !== void 0, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol$2(other);
			if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) return 1;
			if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) return -1;
		}
		return 0;
	}
	module.exports = compareAscending$1;
}));
var require__compareMultiple = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var compareAscending = require__compareAscending();
	function compareMultiple$1(object$1, other, orders) {
		var index = -1, objCriteria = object$1.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
		while (++index < length) {
			var result = compareAscending(objCriteria[index], othCriteria[index]);
			if (result) {
				if (index >= ordersLength) return result;
				return result * (orders[index] == "desc" ? -1 : 1);
			}
		}
		return object$1.index - other.index;
	}
	module.exports = compareMultiple$1;
}));
var require__baseOrderBy = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var arrayMap$1 = require__arrayMap(), baseGet = require__baseGet(), baseIteratee$6 = require__baseIteratee(), baseMap$1 = require__baseMap(), baseSortBy = require__baseSortBy(), baseUnary = require__baseUnary(), compareMultiple = require__compareMultiple(), identity$8 = require_identity(), isArray$3 = require_isArray();
	function baseOrderBy$1(collection, iteratees, orders) {
		if (iteratees.length) iteratees = arrayMap$1(iteratees, function(iteratee) {
			if (isArray$3(iteratee)) return function(value) {
				return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
			};
			return iteratee;
		});
		else iteratees = [identity$8];
		var index = -1;
		iteratees = arrayMap$1(iteratees, baseUnary(baseIteratee$6));
		return baseSortBy(baseMap$1(collection, function(value, key, collection$1) {
			var criteria = arrayMap$1(iteratees, function(iteratee) {
				return iteratee(value);
			});
			return {
				"criteria": criteria,
				"index": ++index,
				"value": value
			};
		}), function(object$1, other) {
			return compareMultiple(object$1, other, orders);
		});
	}
	module.exports = baseOrderBy$1;
}));
var require__apply = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function apply$1(func, thisArg, args) {
		switch (args.length) {
			case 0: return func.call(thisArg);
			case 1: return func.call(thisArg, args[0]);
			case 2: return func.call(thisArg, args[0], args[1]);
			case 3: return func.call(thisArg, args[0], args[1], args[2]);
		}
		return func.apply(thisArg, args);
	}
	module.exports = apply$1;
}));
var require__overRest = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var apply = require__apply();
	var nativeMax$3 = Math.max;
	function overRest$1(func, start, transform$1) {
		start = nativeMax$3(start === void 0 ? func.length - 1 : start, 0);
		return function() {
			var args = arguments, index = -1, length = nativeMax$3(args.length - start, 0), array$1 = Array(length);
			while (++index < length) array$1[index] = args[start + index];
			index = -1;
			var otherArgs = Array(start + 1);
			while (++index < start) otherArgs[index] = args[index];
			otherArgs[start] = transform$1(array$1);
			return apply(func, this, otherArgs);
		};
	}
	module.exports = overRest$1;
}));
var require_constant = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function constant$1(value) {
		return function() {
			return value;
		};
	}
	module.exports = constant$1;
}));
var require__defineProperty = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var getNative = require__getNative();
	module.exports = function() {
		try {
			var func = getNative(Object, "defineProperty");
			func({}, "", {});
			return func;
		} catch (e) {}
	}();
}));
var require__baseSetToString = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var constant = require_constant(), defineProperty$1 = require__defineProperty(), identity$7 = require_identity();
	module.exports = !defineProperty$1 ? identity$7 : function(func, string$2) {
		return defineProperty$1(func, "toString", {
			"configurable": true,
			"enumerable": false,
			"value": constant(string$2),
			"writable": true
		});
	};
}));
var require__shortOut = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var HOT_COUNT = 800, HOT_SPAN = 16;
	var nativeNow = Date.now;
	function shortOut(func) {
		var count = 0, lastCalled = 0;
		return function() {
			var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
			lastCalled = stamp;
			if (remaining > 0) {
				if (++count >= HOT_COUNT) return arguments[0];
			} else count = 0;
			return func.apply(void 0, arguments);
		};
	}
	module.exports = shortOut;
}));
var require__setToString = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseSetToString = require__baseSetToString();
	module.exports = require__shortOut()(baseSetToString);
}));
var require__baseRest = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var identity$6 = require_identity(), overRest = require__overRest(), setToString = require__setToString();
	function baseRest$1(func, start) {
		return setToString(overRest(func, start, identity$6), func + "");
	}
	module.exports = baseRest$1;
}));
var require__isIterateeCall = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var eq = require_eq(), isArrayLike$1 = require_isArrayLike(), isIndex = require__isIndex(), isObject$5 = require_isObject();
	function isIterateeCall$4(value, index, object$1) {
		if (!isObject$5(object$1)) return false;
		var type = typeof index;
		if (type == "number" ? isArrayLike$1(object$1) && isIndex(index, object$1.length) : type == "string" && index in object$1) return eq(object$1[index], value);
		return false;
	}
	module.exports = isIterateeCall$4;
}));
var require_sortBy = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseFlatten$1 = require__baseFlatten(), baseOrderBy = require__baseOrderBy(), baseRest = require__baseRest(), isIterateeCall$3 = require__isIterateeCall();
	module.exports = baseRest(function(collection, iteratees) {
		if (collection == null) return [];
		var length = iteratees.length;
		if (length > 1 && isIterateeCall$3(collection, iteratees[0], iteratees[1])) iteratees = [];
		else if (length > 2 && isIterateeCall$3(iteratees[0], iteratees[1], iteratees[2])) iteratees = [iteratees[0]];
		return baseOrderBy(collection, baseFlatten$1(iteratees, 1), []);
	});
}));
var import_sortBy$2 = /* @__PURE__ */ __toESM(require_sortBy());
var import_isNil$9 = /* @__PURE__ */ __toESM(require_isNil());
function _typeof$41(o$1) {
	"@babel/helpers - typeof";
	return _typeof$41 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$2) {
		return typeof o$2;
	} : function(o$2) {
		return o$2 && "function" == typeof Symbol && o$2.constructor === Symbol && o$2 !== Symbol.prototype ? "symbol" : typeof o$2;
	}, _typeof$41(o$1);
}
function _extends$23() {
	_extends$23 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i$2 = 1; i$2 < arguments.length; i$2++) {
			var source = arguments[i$2];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$23.apply(this, arguments);
}
function _slicedToArray$11(arr, i$2) {
	return _arrayWithHoles$12(arr) || _iterableToArrayLimit$11(arr, i$2) || _unsupportedIterableToArray$19(arr, i$2) || _nonIterableRest$12();
}
function _nonIterableRest$12() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$19(o$1, minLen) {
	if (!o$1) return;
	if (typeof o$1 === "string") return _arrayLikeToArray$19(o$1, minLen);
	var n$1 = Object.prototype.toString.call(o$1).slice(8, -1);
	if (n$1 === "Object" && o$1.constructor) n$1 = o$1.constructor.name;
	if (n$1 === "Map" || n$1 === "Set") return Array.from(o$1);
	if (n$1 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n$1)) return _arrayLikeToArray$19(o$1, minLen);
}
function _arrayLikeToArray$19(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i$2 = 0, arr2 = new Array(len); i$2 < len; i$2++) arr2[i$2] = arr[i$2];
	return arr2;
}
function _iterableToArrayLimit$11(r$1, l) {
	var t$1 = null == r$1 ? null : "undefined" != typeof Symbol && r$1[Symbol.iterator] || r$1["@@iterator"];
	if (null != t$1) {
		var e, n$1, i$2, u, a$2 = [], f = !0, o$1 = !1;
		try {
			if (i$2 = (t$1 = t$1.call(r$1)).next, 0 === l) {
				if (Object(t$1) !== t$1) return;
				f = !1;
			} else for (; !(f = (e = i$2.call(t$1)).done) && (a$2.push(e.value), a$2.length !== l); f = !0);
		} catch (r$2) {
			o$1 = !0, n$1 = r$2;
		} finally {
			try {
				if (!f && null != t$1["return"] && (u = t$1["return"](), Object(u) !== u)) return;
			} finally {
				if (o$1) throw n$1;
			}
		}
		return a$2;
	}
}
function _arrayWithHoles$12(arr) {
	if (Array.isArray(arr)) return arr;
}
function ownKeys$33(e, r$1) {
	var t$1 = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o$1 = Object.getOwnPropertySymbols(e);
		r$1 && (o$1 = o$1.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t$1.push.apply(t$1, o$1);
	}
	return t$1;
}
function _objectSpread$33(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t$1 = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$33(Object(t$1), !0).forEach(function(r$2) {
			_defineProperty$38(e, r$2, t$1[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t$1)) : ownKeys$33(Object(t$1)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t$1, r$2));
		});
	}
	return e;
}
function _defineProperty$38(obj, key, value) {
	key = _toPropertyKey$39(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$39(t$1) {
	var i$2 = _toPrimitive$39(t$1, "string");
	return "symbol" == _typeof$41(i$2) ? i$2 : i$2 + "";
}
function _toPrimitive$39(t$1, r$1) {
	if ("object" != _typeof$41(t$1) || !t$1) return t$1;
	var e = t$1[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i$2 = e.call(t$1, r$1 || "default");
		if ("object" != _typeof$41(i$2)) return i$2;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t$1);
}
function defaultFormatter(value) {
	return Array.isArray(value) && isNumOrStr(value[0]) && isNumOrStr(value[1]) ? value.join(" ~ ") : value;
}
var DefaultTooltipContent = function DefaultTooltipContent$1(props) {
	var _props$separator = props.separator, separator = _props$separator === void 0 ? " : " : _props$separator, _props$contentStyle = props.contentStyle, contentStyle = _props$contentStyle === void 0 ? {} : _props$contentStyle, _props$itemStyle = props.itemStyle, itemStyle = _props$itemStyle === void 0 ? {} : _props$itemStyle, _props$labelStyle = props.labelStyle, labelStyle = _props$labelStyle === void 0 ? {} : _props$labelStyle, payload = props.payload, formatter = props.formatter, itemSorter = props.itemSorter, wrapperClassName = props.wrapperClassName, labelClassName = props.labelClassName, label = props.label, labelFormatter = props.labelFormatter, _props$accessibilityL = props.accessibilityLayer, accessibilityLayer = _props$accessibilityL === void 0 ? false : _props$accessibilityL;
	var renderContent$2 = function renderContent$3() {
		if (payload && payload.length) {
			var listStyle = {
				padding: 0,
				margin: 0
			};
			var items = (itemSorter ? (0, import_sortBy$2.default)(payload, itemSorter) : payload).map(function(entry, i$2) {
				if (entry.type === "none") return null;
				var finalItemStyle = _objectSpread$33({
					display: "block",
					paddingTop: 4,
					paddingBottom: 4,
					color: entry.color || "#000"
				}, itemStyle);
				var finalFormatter = entry.formatter || formatter || defaultFormatter;
				var value = entry.value, name = entry.name;
				var finalValue = value;
				var finalName = name;
				if (finalFormatter && finalValue != null && finalName != null) {
					var formatted = finalFormatter(value, name, entry, i$2, payload);
					if (Array.isArray(formatted)) {
						var _formatted = _slicedToArray$11(formatted, 2);
						finalValue = _formatted[0];
						finalName = _formatted[1];
					} else finalValue = formatted;
				}
				return /* @__PURE__ */ import_react.createElement("li", {
					className: "recharts-tooltip-item",
					key: "tooltip-item-".concat(i$2),
					style: finalItemStyle
				}, isNumOrStr(finalName) ? /* @__PURE__ */ import_react.createElement("span", { className: "recharts-tooltip-item-name" }, finalName) : null, isNumOrStr(finalName) ? /* @__PURE__ */ import_react.createElement("span", { className: "recharts-tooltip-item-separator" }, separator) : null, /* @__PURE__ */ import_react.createElement("span", { className: "recharts-tooltip-item-value" }, finalValue), /* @__PURE__ */ import_react.createElement("span", { className: "recharts-tooltip-item-unit" }, entry.unit || ""));
			});
			return /* @__PURE__ */ import_react.createElement("ul", {
				className: "recharts-tooltip-item-list",
				style: listStyle
			}, items);
		}
		return null;
	};
	var finalStyle = _objectSpread$33({
		margin: 0,
		padding: 10,
		backgroundColor: "#fff",
		border: "1px solid #ccc",
		whiteSpace: "nowrap"
	}, contentStyle);
	var finalLabelStyle = _objectSpread$33({ margin: 0 }, labelStyle);
	var hasLabel = !(0, import_isNil$9.default)(label);
	var finalLabel = hasLabel ? label : "";
	var wrapperCN = clsx_default("recharts-default-tooltip", wrapperClassName);
	var labelCN = clsx_default("recharts-tooltip-label", labelClassName);
	if (hasLabel && labelFormatter && payload !== void 0 && payload !== null) finalLabel = labelFormatter(label, payload);
	var accessibilityAttributes = accessibilityLayer ? {
		role: "status",
		"aria-live": "assertive"
	} : {};
	return /* @__PURE__ */ import_react.createElement("div", _extends$23({
		className: wrapperCN,
		style: finalStyle
	}, accessibilityAttributes), /* @__PURE__ */ import_react.createElement("p", {
		className: labelCN,
		style: finalLabelStyle
	}, /* @__PURE__ */ import_react.isValidElement(finalLabel) ? finalLabel : "".concat(finalLabel)), renderContent$2());
};
function _typeof$40(o$1) {
	"@babel/helpers - typeof";
	return _typeof$40 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$2) {
		return typeof o$2;
	} : function(o$2) {
		return o$2 && "function" == typeof Symbol && o$2.constructor === Symbol && o$2 !== Symbol.prototype ? "symbol" : typeof o$2;
	}, _typeof$40(o$1);
}
function _defineProperty$37(obj, key, value) {
	key = _toPropertyKey$38(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$38(t$1) {
	var i$2 = _toPrimitive$38(t$1, "string");
	return "symbol" == _typeof$40(i$2) ? i$2 : i$2 + "";
}
function _toPrimitive$38(t$1, r$1) {
	if ("object" != _typeof$40(t$1) || !t$1) return t$1;
	var e = t$1[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i$2 = e.call(t$1, r$1 || "default");
		if ("object" != _typeof$40(i$2)) return i$2;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t$1);
}
var CSS_CLASS_PREFIX = "recharts-tooltip-wrapper";
var TOOLTIP_HIDDEN = { visibility: "hidden" };
function getTooltipCSSClassName(_ref) {
	var coordinate = _ref.coordinate, translateX = _ref.translateX, translateY = _ref.translateY;
	return clsx_default(CSS_CLASS_PREFIX, _defineProperty$37(_defineProperty$37(_defineProperty$37(_defineProperty$37({}, "".concat(CSS_CLASS_PREFIX, "-right"), isNumber(translateX) && coordinate && isNumber(coordinate.x) && translateX >= coordinate.x), "".concat(CSS_CLASS_PREFIX, "-left"), isNumber(translateX) && coordinate && isNumber(coordinate.x) && translateX < coordinate.x), "".concat(CSS_CLASS_PREFIX, "-bottom"), isNumber(translateY) && coordinate && isNumber(coordinate.y) && translateY >= coordinate.y), "".concat(CSS_CLASS_PREFIX, "-top"), isNumber(translateY) && coordinate && isNumber(coordinate.y) && translateY < coordinate.y));
}
function getTooltipTranslateXY(_ref2) {
	var allowEscapeViewBox = _ref2.allowEscapeViewBox, coordinate = _ref2.coordinate, key = _ref2.key, offsetTopLeft = _ref2.offsetTopLeft, position = _ref2.position, reverseDirection = _ref2.reverseDirection, tooltipDimension = _ref2.tooltipDimension, viewBox = _ref2.viewBox, viewBoxDimension = _ref2.viewBoxDimension;
	if (position && isNumber(position[key])) return position[key];
	var negative = coordinate[key] - tooltipDimension - offsetTopLeft;
	var positive = coordinate[key] + offsetTopLeft;
	if (allowEscapeViewBox[key]) return reverseDirection[key] ? negative : positive;
	if (reverseDirection[key]) {
		if (negative < viewBox[key]) return Math.max(positive, viewBox[key]);
		return Math.max(negative, viewBox[key]);
	}
	if (positive + tooltipDimension > viewBox[key] + viewBoxDimension) return Math.max(negative, viewBox[key]);
	return Math.max(positive, viewBox[key]);
}
function getTransformStyle(_ref3) {
	var translateX = _ref3.translateX, translateY = _ref3.translateY;
	return { transform: _ref3.useTranslate3d ? "translate3d(".concat(translateX, "px, ").concat(translateY, "px, 0)") : "translate(".concat(translateX, "px, ").concat(translateY, "px)") };
}
function getTooltipTranslate(_ref4) {
	var allowEscapeViewBox = _ref4.allowEscapeViewBox, coordinate = _ref4.coordinate, offsetTopLeft = _ref4.offsetTopLeft, position = _ref4.position, reverseDirection = _ref4.reverseDirection, tooltipBox = _ref4.tooltipBox, useTranslate3d = _ref4.useTranslate3d, viewBox = _ref4.viewBox;
	var cssProperties, translateX, translateY;
	if (tooltipBox.height > 0 && tooltipBox.width > 0 && coordinate) {
		translateX = getTooltipTranslateXY({
			allowEscapeViewBox,
			coordinate,
			key: "x",
			offsetTopLeft,
			position,
			reverseDirection,
			tooltipDimension: tooltipBox.width,
			viewBox,
			viewBoxDimension: viewBox.width
		});
		translateY = getTooltipTranslateXY({
			allowEscapeViewBox,
			coordinate,
			key: "y",
			offsetTopLeft,
			position,
			reverseDirection,
			tooltipDimension: tooltipBox.height,
			viewBox,
			viewBoxDimension: viewBox.height
		});
		cssProperties = getTransformStyle({
			translateX,
			translateY,
			useTranslate3d
		});
	} else cssProperties = TOOLTIP_HIDDEN;
	return {
		cssProperties,
		cssClasses: getTooltipCSSClassName({
			translateX,
			translateY,
			coordinate
		})
	};
}
function _typeof$39(o$1) {
	"@babel/helpers - typeof";
	return _typeof$39 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$2) {
		return typeof o$2;
	} : function(o$2) {
		return o$2 && "function" == typeof Symbol && o$2.constructor === Symbol && o$2 !== Symbol.prototype ? "symbol" : typeof o$2;
	}, _typeof$39(o$1);
}
function ownKeys$32(e, r$1) {
	var t$1 = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o$1 = Object.getOwnPropertySymbols(e);
		r$1 && (o$1 = o$1.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t$1.push.apply(t$1, o$1);
	}
	return t$1;
}
function _objectSpread$32(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t$1 = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$32(Object(t$1), !0).forEach(function(r$2) {
			_defineProperty$36(e, r$2, t$1[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t$1)) : ownKeys$32(Object(t$1)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t$1, r$2));
		});
	}
	return e;
}
function _classCallCheck$17(instance, Constructor) {
	if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties$17(target, props) {
	for (var i$2 = 0; i$2 < props.length; i$2++) {
		var descriptor = props[i$2];
		descriptor.enumerable = descriptor.enumerable || false;
		descriptor.configurable = true;
		if ("value" in descriptor) descriptor.writable = true;
		Object.defineProperty(target, _toPropertyKey$37(descriptor.key), descriptor);
	}
}
function _createClass$17(Constructor, protoProps, staticProps) {
	if (protoProps) _defineProperties$17(Constructor.prototype, protoProps);
	if (staticProps) _defineProperties$17(Constructor, staticProps);
	Object.defineProperty(Constructor, "prototype", { writable: false });
	return Constructor;
}
function _callSuper$13(t$1, o$1, e) {
	return o$1 = _getPrototypeOf$14(o$1), _possibleConstructorReturn$14(t$1, _isNativeReflectConstruct$14() ? Reflect.construct(o$1, e || [], _getPrototypeOf$14(t$1).constructor) : o$1.apply(t$1, e));
}
function _possibleConstructorReturn$14(self$1, call) {
	if (call && (_typeof$39(call) === "object" || typeof call === "function")) return call;
	else if (call !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
	return _assertThisInitialized$14(self$1);
}
function _assertThisInitialized$14(self$1) {
	if (self$1 === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	return self$1;
}
function _isNativeReflectConstruct$14() {
	try {
		var t$1 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
	} catch (t$2) {}
	return (_isNativeReflectConstruct$14 = function _isNativeReflectConstruct$17() {
		return !!t$1;
	})();
}
function _getPrototypeOf$14(o$1) {
	_getPrototypeOf$14 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf$17(o$2) {
		return o$2.__proto__ || Object.getPrototypeOf(o$2);
	};
	return _getPrototypeOf$14(o$1);
}
function _inherits$14(subClass, superClass) {
	if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
	subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: {
		value: subClass,
		writable: true,
		configurable: true
	} });
	Object.defineProperty(subClass, "prototype", { writable: false });
	if (superClass) _setPrototypeOf$14(subClass, superClass);
}
function _setPrototypeOf$14(o$1, p) {
	_setPrototypeOf$14 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf$17(o$2, p$1) {
		o$2.__proto__ = p$1;
		return o$2;
	};
	return _setPrototypeOf$14(o$1, p);
}
function _defineProperty$36(obj, key, value) {
	key = _toPropertyKey$37(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$37(t$1) {
	var i$2 = _toPrimitive$37(t$1, "string");
	return "symbol" == _typeof$39(i$2) ? i$2 : i$2 + "";
}
function _toPrimitive$37(t$1, r$1) {
	if ("object" != _typeof$39(t$1) || !t$1) return t$1;
	var e = t$1[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i$2 = e.call(t$1, r$1 || "default");
		if ("object" != _typeof$39(i$2)) return i$2;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t$1);
}
var EPSILON = 1;
var TooltipBoundingBox = /* @__PURE__ */ function(_PureComponent) {
	function TooltipBoundingBox$1() {
		var _this;
		_classCallCheck$17(this, TooltipBoundingBox$1);
		for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
		_this = _callSuper$13(this, TooltipBoundingBox$1, [].concat(args));
		_defineProperty$36(_this, "state", {
			dismissed: false,
			dismissedAtCoordinate: {
				x: 0,
				y: 0
			},
			lastBoundingBox: {
				width: -1,
				height: -1
			}
		});
		_defineProperty$36(_this, "handleKeyDown", function(event) {
			if (event.key === "Escape") {
				var _this$props$coordinat, _this$props$coordinat2, _this$props$coordinat3, _this$props$coordinat4;
				_this.setState({
					dismissed: true,
					dismissedAtCoordinate: {
						x: (_this$props$coordinat = (_this$props$coordinat2 = _this.props.coordinate) === null || _this$props$coordinat2 === void 0 ? void 0 : _this$props$coordinat2.x) !== null && _this$props$coordinat !== void 0 ? _this$props$coordinat : 0,
						y: (_this$props$coordinat3 = (_this$props$coordinat4 = _this.props.coordinate) === null || _this$props$coordinat4 === void 0 ? void 0 : _this$props$coordinat4.y) !== null && _this$props$coordinat3 !== void 0 ? _this$props$coordinat3 : 0
					}
				});
			}
		});
		return _this;
	}
	_inherits$14(TooltipBoundingBox$1, _PureComponent);
	return _createClass$17(TooltipBoundingBox$1, [
		{
			key: "updateBBox",
			value: function updateBBox() {
				if (this.wrapperNode && this.wrapperNode.getBoundingClientRect) {
					var box = this.wrapperNode.getBoundingClientRect();
					if (Math.abs(box.width - this.state.lastBoundingBox.width) > EPSILON || Math.abs(box.height - this.state.lastBoundingBox.height) > EPSILON) this.setState({ lastBoundingBox: {
						width: box.width,
						height: box.height
					} });
				} else if (this.state.lastBoundingBox.width !== -1 || this.state.lastBoundingBox.height !== -1) this.setState({ lastBoundingBox: {
					width: -1,
					height: -1
				} });
			}
		},
		{
			key: "componentDidMount",
			value: function componentDidMount() {
				document.addEventListener("keydown", this.handleKeyDown);
				this.updateBBox();
			}
		},
		{
			key: "componentWillUnmount",
			value: function componentWillUnmount() {
				document.removeEventListener("keydown", this.handleKeyDown);
			}
		},
		{
			key: "componentDidUpdate",
			value: function componentDidUpdate() {
				var _this$props$coordinat5, _this$props$coordinat6;
				if (this.props.active) this.updateBBox();
				if (!this.state.dismissed) return;
				if (((_this$props$coordinat5 = this.props.coordinate) === null || _this$props$coordinat5 === void 0 ? void 0 : _this$props$coordinat5.x) !== this.state.dismissedAtCoordinate.x || ((_this$props$coordinat6 = this.props.coordinate) === null || _this$props$coordinat6 === void 0 ? void 0 : _this$props$coordinat6.y) !== this.state.dismissedAtCoordinate.y) this.state.dismissed = false;
			}
		},
		{
			key: "render",
			value: function render() {
				var _this2 = this;
				var _this$props = this.props, active = _this$props.active, allowEscapeViewBox = _this$props.allowEscapeViewBox, animationDuration = _this$props.animationDuration, animationEasing = _this$props.animationEasing, children = _this$props.children, coordinate = _this$props.coordinate, hasPayload = _this$props.hasPayload, isAnimationActive = _this$props.isAnimationActive, offset = _this$props.offset, position = _this$props.position, reverseDirection = _this$props.reverseDirection, useTranslate3d = _this$props.useTranslate3d, viewBox = _this$props.viewBox, wrapperStyle = _this$props.wrapperStyle;
				var _getTooltipTranslate = getTooltipTranslate({
					allowEscapeViewBox,
					coordinate,
					offsetTopLeft: offset,
					position,
					reverseDirection,
					tooltipBox: this.state.lastBoundingBox,
					useTranslate3d,
					viewBox
				}), cssClasses = _getTooltipTranslate.cssClasses, cssProperties = _getTooltipTranslate.cssProperties;
				var outerStyle = _objectSpread$32(_objectSpread$32({ transition: isAnimationActive && active ? "transform ".concat(animationDuration, "ms ").concat(animationEasing) : void 0 }, cssProperties), {}, {
					pointerEvents: "none",
					visibility: !this.state.dismissed && active && hasPayload ? "visible" : "hidden",
					position: "absolute",
					top: 0,
					left: 0
				}, wrapperStyle);
				return /* @__PURE__ */ import_react.createElement("div", {
					tabIndex: -1,
					className: cssClasses,
					style: outerStyle,
					ref: function ref(node) {
						_this2.wrapperNode = node;
					}
				}, children);
			}
		}
	]);
}(import_react.PureComponent);
var Global = {
	isSsr: function parseIsSsrByDefault$1() {
		return !(typeof window !== "undefined" && window.document && window.document.createElement && window.setTimeout);
	}(),
	get: function get$8(key) {
		return Global[key];
	},
	set: function set$1(key, value) {
		if (typeof key === "string") Global[key] = value;
		else {
			var keys$6 = Object.keys(key);
			if (keys$6 && keys$6.length) keys$6.forEach(function(k$1) {
				Global[k$1] = key[k$1];
			});
		}
	}
};
function _typeof$38(o$1) {
	"@babel/helpers - typeof";
	return _typeof$38 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$2) {
		return typeof o$2;
	} : function(o$2) {
		return o$2 && "function" == typeof Symbol && o$2.constructor === Symbol && o$2 !== Symbol.prototype ? "symbol" : typeof o$2;
	}, _typeof$38(o$1);
}
function ownKeys$31(e, r$1) {
	var t$1 = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o$1 = Object.getOwnPropertySymbols(e);
		r$1 && (o$1 = o$1.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t$1.push.apply(t$1, o$1);
	}
	return t$1;
}
function _objectSpread$31(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t$1 = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$31(Object(t$1), !0).forEach(function(r$2) {
			_defineProperty$35(e, r$2, t$1[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t$1)) : ownKeys$31(Object(t$1)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t$1, r$2));
		});
	}
	return e;
}
function _classCallCheck$16(instance, Constructor) {
	if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties$16(target, props) {
	for (var i$2 = 0; i$2 < props.length; i$2++) {
		var descriptor = props[i$2];
		descriptor.enumerable = descriptor.enumerable || false;
		descriptor.configurable = true;
		if ("value" in descriptor) descriptor.writable = true;
		Object.defineProperty(target, _toPropertyKey$36(descriptor.key), descriptor);
	}
}
function _createClass$16(Constructor, protoProps, staticProps) {
	if (protoProps) _defineProperties$16(Constructor.prototype, protoProps);
	if (staticProps) _defineProperties$16(Constructor, staticProps);
	Object.defineProperty(Constructor, "prototype", { writable: false });
	return Constructor;
}
function _callSuper$12(t$1, o$1, e) {
	return o$1 = _getPrototypeOf$13(o$1), _possibleConstructorReturn$13(t$1, _isNativeReflectConstruct$13() ? Reflect.construct(o$1, e || [], _getPrototypeOf$13(t$1).constructor) : o$1.apply(t$1, e));
}
function _possibleConstructorReturn$13(self$1, call) {
	if (call && (_typeof$38(call) === "object" || typeof call === "function")) return call;
	else if (call !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
	return _assertThisInitialized$13(self$1);
}
function _assertThisInitialized$13(self$1) {
	if (self$1 === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	return self$1;
}
function _isNativeReflectConstruct$13() {
	try {
		var t$1 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
	} catch (t$2) {}
	return (_isNativeReflectConstruct$13 = function _isNativeReflectConstruct$17() {
		return !!t$1;
	})();
}
function _getPrototypeOf$13(o$1) {
	_getPrototypeOf$13 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf$17(o$2) {
		return o$2.__proto__ || Object.getPrototypeOf(o$2);
	};
	return _getPrototypeOf$13(o$1);
}
function _inherits$13(subClass, superClass) {
	if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
	subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: {
		value: subClass,
		writable: true,
		configurable: true
	} });
	Object.defineProperty(subClass, "prototype", { writable: false });
	if (superClass) _setPrototypeOf$13(subClass, superClass);
}
function _setPrototypeOf$13(o$1, p) {
	_setPrototypeOf$13 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf$17(o$2, p$1) {
		o$2.__proto__ = p$1;
		return o$2;
	};
	return _setPrototypeOf$13(o$1, p);
}
function _defineProperty$35(obj, key, value) {
	key = _toPropertyKey$36(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$36(t$1) {
	var i$2 = _toPrimitive$36(t$1, "string");
	return "symbol" == _typeof$38(i$2) ? i$2 : i$2 + "";
}
function _toPrimitive$36(t$1, r$1) {
	if ("object" != _typeof$38(t$1) || !t$1) return t$1;
	var e = t$1[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i$2 = e.call(t$1, r$1 || "default");
		if ("object" != _typeof$38(i$2)) return i$2;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t$1);
}
function defaultUniqBy(entry) {
	return entry.dataKey;
}
function renderContent(content, props) {
	if (/* @__PURE__ */ import_react.isValidElement(content)) return /* @__PURE__ */ import_react.cloneElement(content, props);
	if (typeof content === "function") return /* @__PURE__ */ import_react.createElement(content, props);
	return /* @__PURE__ */ import_react.createElement(DefaultTooltipContent, props);
}
var Tooltip = /* @__PURE__ */ function(_PureComponent) {
	function Tooltip$1() {
		_classCallCheck$16(this, Tooltip$1);
		return _callSuper$12(this, Tooltip$1, arguments);
	}
	_inherits$13(Tooltip$1, _PureComponent);
	return _createClass$16(Tooltip$1, [{
		key: "render",
		value: function render() {
			var _this = this;
			var _this$props = this.props, active = _this$props.active, allowEscapeViewBox = _this$props.allowEscapeViewBox, animationDuration = _this$props.animationDuration, animationEasing = _this$props.animationEasing, content = _this$props.content, coordinate = _this$props.coordinate, filterNull = _this$props.filterNull, isAnimationActive = _this$props.isAnimationActive, offset = _this$props.offset, payload = _this$props.payload, payloadUniqBy = _this$props.payloadUniqBy, position = _this$props.position, reverseDirection = _this$props.reverseDirection, useTranslate3d = _this$props.useTranslate3d, viewBox = _this$props.viewBox, wrapperStyle = _this$props.wrapperStyle;
			var finalPayload = payload !== null && payload !== void 0 ? payload : [];
			if (filterNull && finalPayload.length) finalPayload = getUniqPayload(payload.filter(function(entry) {
				return entry.value != null && (entry.hide !== true || _this.props.includeHidden);
			}), payloadUniqBy, defaultUniqBy);
			var hasPayload = finalPayload.length > 0;
			return /* @__PURE__ */ import_react.createElement(TooltipBoundingBox, {
				allowEscapeViewBox,
				animationDuration,
				animationEasing,
				isAnimationActive,
				active,
				coordinate,
				hasPayload,
				offset,
				position,
				reverseDirection,
				useTranslate3d,
				viewBox,
				wrapperStyle
			}, renderContent(content, _objectSpread$31(_objectSpread$31({}, this.props), {}, { payload: finalPayload })));
		}
	}]);
}(import_react.PureComponent);
_defineProperty$35(Tooltip, "displayName", "Tooltip");
_defineProperty$35(Tooltip, "defaultProps", {
	accessibilityLayer: false,
	allowEscapeViewBox: {
		x: false,
		y: false
	},
	animationDuration: 400,
	animationEasing: "ease",
	contentStyle: {},
	coordinate: {
		x: 0,
		y: 0
	},
	cursor: true,
	cursorStyle: {},
	filterNull: true,
	isAnimationActive: !Global.isSsr,
	itemStyle: {},
	labelStyle: {},
	offset: 10,
	reverseDirection: {
		x: false,
		y: false
	},
	separator: " : ",
	trigger: "hover",
	useTranslate3d: false,
	viewBox: {
		x: 0,
		y: 0,
		height: 0,
		width: 0
	},
	wrapperStyle: {}
});
var require_now = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var root = require__root();
	var now$1 = function() {
		return root.Date.now();
	};
	module.exports = now$1;
}));
var require__trimmedEndIndex = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var reWhitespace = /\s/;
	function trimmedEndIndex$1(string$2) {
		var index = string$2.length;
		while (index-- && reWhitespace.test(string$2.charAt(index)));
		return index;
	}
	module.exports = trimmedEndIndex$1;
}));
var require__baseTrim = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var trimmedEndIndex = require__trimmedEndIndex();
	var reTrimStart = /^\s+/;
	function baseTrim$1(string$2) {
		return string$2 ? string$2.slice(0, trimmedEndIndex(string$2) + 1).replace(reTrimStart, "") : string$2;
	}
	module.exports = baseTrim$1;
}));
var require_toNumber = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseTrim = require__baseTrim(), isObject$4 = require_isObject(), isSymbol$1 = require_isSymbol();
	var NAN = NaN;
	var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
	var reIsBinary = /^0b[01]+$/i;
	var reIsOctal = /^0o[0-7]+$/i;
	var freeParseInt = parseInt;
	function toNumber$2(value) {
		if (typeof value == "number") return value;
		if (isSymbol$1(value)) return NAN;
		if (isObject$4(value)) {
			var other = typeof value.valueOf == "function" ? value.valueOf() : value;
			value = isObject$4(other) ? other + "" : other;
		}
		if (typeof value != "string") return value === 0 ? value : +value;
		value = baseTrim(value);
		var isBinary = reIsBinary.test(value);
		return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
	}
	module.exports = toNumber$2;
}));
var require_debounce = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var isObject$3 = require_isObject(), now = require_now(), toNumber$1 = require_toNumber();
	var FUNC_ERROR_TEXT$1 = "Expected a function";
	var nativeMax$2 = Math.max, nativeMin = Math.min;
	function debounce$1(func, wait, options) {
		var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
		if (typeof func != "function") throw new TypeError(FUNC_ERROR_TEXT$1);
		wait = toNumber$1(wait) || 0;
		if (isObject$3(options)) {
			leading = !!options.leading;
			maxing = "maxWait" in options;
			maxWait = maxing ? nativeMax$2(toNumber$1(options.maxWait) || 0, wait) : maxWait;
			trailing = "trailing" in options ? !!options.trailing : trailing;
		}
		function invokeFunc(time$3) {
			var args = lastArgs, thisArg = lastThis;
			lastArgs = lastThis = void 0;
			lastInvokeTime = time$3;
			result = func.apply(thisArg, args);
			return result;
		}
		function leadingEdge(time$3) {
			lastInvokeTime = time$3;
			timerId = setTimeout(timerExpired, wait);
			return leading ? invokeFunc(time$3) : result;
		}
		function remainingWait(time$3) {
			var timeSinceLastCall = time$3 - lastCallTime, timeSinceLastInvoke = time$3 - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
			return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
		}
		function shouldInvoke(time$3) {
			var timeSinceLastCall = time$3 - lastCallTime, timeSinceLastInvoke = time$3 - lastInvokeTime;
			return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
		}
		function timerExpired() {
			var time$3 = now();
			if (shouldInvoke(time$3)) return trailingEdge(time$3);
			timerId = setTimeout(timerExpired, remainingWait(time$3));
		}
		function trailingEdge(time$3) {
			timerId = void 0;
			if (trailing && lastArgs) return invokeFunc(time$3);
			lastArgs = lastThis = void 0;
			return result;
		}
		function cancel() {
			if (timerId !== void 0) clearTimeout(timerId);
			lastInvokeTime = 0;
			lastArgs = lastCallTime = lastThis = timerId = void 0;
		}
		function flush() {
			return timerId === void 0 ? result : trailingEdge(now());
		}
		function debounced() {
			var time$3 = now(), isInvoking = shouldInvoke(time$3);
			lastArgs = arguments;
			lastThis = this;
			lastCallTime = time$3;
			if (isInvoking) {
				if (timerId === void 0) return leadingEdge(lastCallTime);
				if (maxing) {
					clearTimeout(timerId);
					timerId = setTimeout(timerExpired, wait);
					return invokeFunc(lastCallTime);
				}
			}
			if (timerId === void 0) timerId = setTimeout(timerExpired, wait);
			return result;
		}
		debounced.cancel = cancel;
		debounced.flush = flush;
		return debounced;
	}
	module.exports = debounce$1;
}));
var require_throttle = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var debounce = require_debounce(), isObject$2 = require_isObject();
	var FUNC_ERROR_TEXT = "Expected a function";
	function throttle$2(func, wait, options) {
		var leading = true, trailing = true;
		if (typeof func != "function") throw new TypeError(FUNC_ERROR_TEXT);
		if (isObject$2(options)) {
			leading = "leading" in options ? !!options.leading : leading;
			trailing = "trailing" in options ? !!options.trailing : trailing;
		}
		return debounce(func, wait, {
			"leading": leading,
			"maxWait": wait,
			"trailing": trailing
		});
	}
	module.exports = throttle$2;
}));
var import_throttle$1 = /* @__PURE__ */ __toESM(require_throttle());
function _typeof$37(o$1) {
	"@babel/helpers - typeof";
	return _typeof$37 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$2) {
		return typeof o$2;
	} : function(o$2) {
		return o$2 && "function" == typeof Symbol && o$2.constructor === Symbol && o$2 !== Symbol.prototype ? "symbol" : typeof o$2;
	}, _typeof$37(o$1);
}
function ownKeys$30(e, r$1) {
	var t$1 = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o$1 = Object.getOwnPropertySymbols(e);
		r$1 && (o$1 = o$1.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t$1.push.apply(t$1, o$1);
	}
	return t$1;
}
function _objectSpread$30(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t$1 = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$30(Object(t$1), !0).forEach(function(r$2) {
			_defineProperty$34(e, r$2, t$1[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t$1)) : ownKeys$30(Object(t$1)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t$1, r$2));
		});
	}
	return e;
}
function _defineProperty$34(obj, key, value) {
	key = _toPropertyKey$35(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$35(t$1) {
	var i$2 = _toPrimitive$35(t$1, "string");
	return "symbol" == _typeof$37(i$2) ? i$2 : i$2 + "";
}
function _toPrimitive$35(t$1, r$1) {
	if ("object" != _typeof$37(t$1) || !t$1) return t$1;
	var e = t$1[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i$2 = e.call(t$1, r$1 || "default");
		if ("object" != _typeof$37(i$2)) return i$2;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t$1);
}
function _slicedToArray$10(arr, i$2) {
	return _arrayWithHoles$11(arr) || _iterableToArrayLimit$10(arr, i$2) || _unsupportedIterableToArray$18(arr, i$2) || _nonIterableRest$11();
}
function _nonIterableRest$11() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$18(o$1, minLen) {
	if (!o$1) return;
	if (typeof o$1 === "string") return _arrayLikeToArray$18(o$1, minLen);
	var n$1 = Object.prototype.toString.call(o$1).slice(8, -1);
	if (n$1 === "Object" && o$1.constructor) n$1 = o$1.constructor.name;
	if (n$1 === "Map" || n$1 === "Set") return Array.from(o$1);
	if (n$1 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n$1)) return _arrayLikeToArray$18(o$1, minLen);
}
function _arrayLikeToArray$18(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i$2 = 0, arr2 = new Array(len); i$2 < len; i$2++) arr2[i$2] = arr[i$2];
	return arr2;
}
function _iterableToArrayLimit$10(r$1, l) {
	var t$1 = null == r$1 ? null : "undefined" != typeof Symbol && r$1[Symbol.iterator] || r$1["@@iterator"];
	if (null != t$1) {
		var e, n$1, i$2, u, a$2 = [], f = !0, o$1 = !1;
		try {
			if (i$2 = (t$1 = t$1.call(r$1)).next, 0 === l) {
				if (Object(t$1) !== t$1) return;
				f = !1;
			} else for (; !(f = (e = i$2.call(t$1)).done) && (a$2.push(e.value), a$2.length !== l); f = !0);
		} catch (r$2) {
			o$1 = !0, n$1 = r$2;
		} finally {
			try {
				if (!f && null != t$1["return"] && (u = t$1["return"](), Object(u) !== u)) return;
			} finally {
				if (o$1) throw n$1;
			}
		}
		return a$2;
	}
}
function _arrayWithHoles$11(arr) {
	if (Array.isArray(arr)) return arr;
}
var ResponsiveContainer = /* @__PURE__ */ (0, import_react.forwardRef)(function(_ref, ref) {
	var aspect = _ref.aspect, _ref$initialDimension = _ref.initialDimension, initialDimension = _ref$initialDimension === void 0 ? {
		width: -1,
		height: -1
	} : _ref$initialDimension, _ref$width = _ref.width, width = _ref$width === void 0 ? "100%" : _ref$width, _ref$height = _ref.height, height = _ref$height === void 0 ? "100%" : _ref$height, _ref$minWidth = _ref.minWidth, minWidth = _ref$minWidth === void 0 ? 0 : _ref$minWidth, minHeight = _ref.minHeight, maxHeight = _ref.maxHeight, children = _ref.children, _ref$debounce = _ref.debounce, debounce$2 = _ref$debounce === void 0 ? 0 : _ref$debounce, id = _ref.id, className = _ref.className, onResize = _ref.onResize, _ref$style = _ref.style, style = _ref$style === void 0 ? {} : _ref$style;
	var containerRef = (0, import_react.useRef)(null);
	var onResizeRef = (0, import_react.useRef)();
	onResizeRef.current = onResize;
	(0, import_react.useImperativeHandle)(ref, function() {
		return Object.defineProperty(containerRef.current, "current", {
			get: function get$8() {
				console.warn("The usage of ref.current.current is deprecated and will no longer be supported.");
				return containerRef.current;
			},
			configurable: true
		});
	});
	var _useState2 = _slicedToArray$10((0, import_react.useState)({
		containerWidth: initialDimension.width,
		containerHeight: initialDimension.height
	}), 2), sizes = _useState2[0], setSizes = _useState2[1];
	var setContainerSize = (0, import_react.useCallback)(function(newWidth, newHeight) {
		setSizes(function(prevState) {
			var roundedWidth = Math.round(newWidth);
			var roundedHeight = Math.round(newHeight);
			if (prevState.containerWidth === roundedWidth && prevState.containerHeight === roundedHeight) return prevState;
			return {
				containerWidth: roundedWidth,
				containerHeight: roundedHeight
			};
		});
	}, []);
	(0, import_react.useEffect)(function() {
		var callback = function callback$1(entries) {
			var _onResizeRef$current;
			var _entries$0$contentRec = entries[0].contentRect, containerWidth$1 = _entries$0$contentRec.width, containerHeight$1 = _entries$0$contentRec.height;
			setContainerSize(containerWidth$1, containerHeight$1);
			(_onResizeRef$current = onResizeRef.current) === null || _onResizeRef$current === void 0 || _onResizeRef$current.call(onResizeRef, containerWidth$1, containerHeight$1);
		};
		if (debounce$2 > 0) callback = (0, import_throttle$1.default)(callback, debounce$2, {
			trailing: true,
			leading: false
		});
		var observer = new ResizeObserver(callback);
		var _containerRef$current = containerRef.current.getBoundingClientRect(), containerWidth = _containerRef$current.width, containerHeight = _containerRef$current.height;
		setContainerSize(containerWidth, containerHeight);
		observer.observe(containerRef.current);
		return function() {
			observer.disconnect();
		};
	}, [setContainerSize, debounce$2]);
	var chartContent = (0, import_react.useMemo)(function() {
		var containerWidth = sizes.containerWidth, containerHeight = sizes.containerHeight;
		if (containerWidth < 0 || containerHeight < 0) return null;
		warn(isPercent(width) || isPercent(height), "The width(%s) and height(%s) are both fixed numbers,\n       maybe you don't need to use a ResponsiveContainer.", width, height);
		warn(!aspect || aspect > 0, "The aspect(%s) must be greater than zero.", aspect);
		var calculatedWidth = isPercent(width) ? containerWidth : width;
		var calculatedHeight = isPercent(height) ? containerHeight : height;
		if (aspect && aspect > 0) {
			if (calculatedWidth) calculatedHeight = calculatedWidth / aspect;
			else if (calculatedHeight) calculatedWidth = calculatedHeight * aspect;
			if (maxHeight && calculatedHeight > maxHeight) calculatedHeight = maxHeight;
		}
		warn(calculatedWidth > 0 || calculatedHeight > 0, "The width(%s) and height(%s) of chart should be greater than 0,\n       please check the style of container, or the props width(%s) and height(%s),\n       or add a minWidth(%s) or minHeight(%s) or use aspect(%s) to control the\n       height and width.", calculatedWidth, calculatedHeight, width, height, minWidth, minHeight, aspect);
		var isCharts = !Array.isArray(children) && getDisplayName(children.type).endsWith("Chart");
		return import_react.Children.map(children, function(child) {
			if (/* @__PURE__ */ import_react.isValidElement(child)) return /* @__PURE__ */ (0, import_react.cloneElement)(child, _objectSpread$30({
				width: calculatedWidth,
				height: calculatedHeight
			}, isCharts ? { style: _objectSpread$30({
				height: "100%",
				width: "100%",
				maxHeight: calculatedHeight,
				maxWidth: calculatedWidth
			}, child.props.style) } : {}));
			return child;
		});
	}, [
		aspect,
		children,
		height,
		maxHeight,
		minHeight,
		minWidth,
		sizes,
		width
	]);
	return /* @__PURE__ */ import_react.createElement("div", {
		id: id ? "".concat(id) : void 0,
		className: clsx_default("recharts-responsive-container", className),
		style: _objectSpread$30(_objectSpread$30({}, style), {}, {
			width,
			height,
			minWidth,
			minHeight,
			maxHeight
		}),
		ref: containerRef
	}, chartContent);
});
var Cell = function Cell$1(_props) {
	return null;
};
Cell.displayName = "Cell";
function _typeof$36(o$1) {
	"@babel/helpers - typeof";
	return _typeof$36 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$2) {
		return typeof o$2;
	} : function(o$2) {
		return o$2 && "function" == typeof Symbol && o$2.constructor === Symbol && o$2 !== Symbol.prototype ? "symbol" : typeof o$2;
	}, _typeof$36(o$1);
}
function ownKeys$29(e, r$1) {
	var t$1 = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o$1 = Object.getOwnPropertySymbols(e);
		r$1 && (o$1 = o$1.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t$1.push.apply(t$1, o$1);
	}
	return t$1;
}
function _objectSpread$29(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t$1 = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$29(Object(t$1), !0).forEach(function(r$2) {
			_defineProperty$33(e, r$2, t$1[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t$1)) : ownKeys$29(Object(t$1)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t$1, r$2));
		});
	}
	return e;
}
function _defineProperty$33(obj, key, value) {
	key = _toPropertyKey$34(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$34(t$1) {
	var i$2 = _toPrimitive$34(t$1, "string");
	return "symbol" == _typeof$36(i$2) ? i$2 : i$2 + "";
}
function _toPrimitive$34(t$1, r$1) {
	if ("object" != _typeof$36(t$1) || !t$1) return t$1;
	var e = t$1[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i$2 = e.call(t$1, r$1 || "default");
		if ("object" != _typeof$36(i$2)) return i$2;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t$1);
}
var stringCache = {
	widthCache: {},
	cacheCount: 0
};
var MAX_CACHE_NUM = 2e3;
var SPAN_STYLE = {
	position: "absolute",
	top: "-20000px",
	left: 0,
	padding: 0,
	margin: 0,
	border: "none",
	whiteSpace: "pre"
};
var MEASUREMENT_SPAN_ID = "recharts_measurement_span";
function removeInvalidKeys(obj) {
	var copyObj = _objectSpread$29({}, obj);
	Object.keys(copyObj).forEach(function(key) {
		if (!copyObj[key]) delete copyObj[key];
	});
	return copyObj;
}
var getStringSize = function getStringSize$1(text) {
	var style = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
	if (text === void 0 || text === null || Global.isSsr) return {
		width: 0,
		height: 0
	};
	var copyStyle = removeInvalidKeys(style);
	var cacheKey = JSON.stringify({
		text,
		copyStyle
	});
	if (stringCache.widthCache[cacheKey]) return stringCache.widthCache[cacheKey];
	try {
		var measurementSpan = document.getElementById(MEASUREMENT_SPAN_ID);
		if (!measurementSpan) {
			measurementSpan = document.createElement("span");
			measurementSpan.setAttribute("id", MEASUREMENT_SPAN_ID);
			measurementSpan.setAttribute("aria-hidden", "true");
			document.body.appendChild(measurementSpan);
		}
		var measurementSpanStyle = _objectSpread$29(_objectSpread$29({}, SPAN_STYLE), copyStyle);
		Object.assign(measurementSpan.style, measurementSpanStyle);
		measurementSpan.textContent = "".concat(text);
		var rect = measurementSpan.getBoundingClientRect();
		var result = {
			width: rect.width,
			height: rect.height
		};
		stringCache.widthCache[cacheKey] = result;
		if (++stringCache.cacheCount > MAX_CACHE_NUM) {
			stringCache.cacheCount = 0;
			stringCache.widthCache = {};
		}
		return result;
	} catch (e) {
		return {
			width: 0,
			height: 0
		};
	}
};
var getOffset = function getOffset$1(rect) {
	return {
		top: rect.top + window.scrollY - document.documentElement.clientTop,
		left: rect.left + window.scrollX - document.documentElement.clientLeft
	};
};
function _typeof$35(o$1) {
	"@babel/helpers - typeof";
	return _typeof$35 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$2) {
		return typeof o$2;
	} : function(o$2) {
		return o$2 && "function" == typeof Symbol && o$2.constructor === Symbol && o$2 !== Symbol.prototype ? "symbol" : typeof o$2;
	}, _typeof$35(o$1);
}
function _slicedToArray$9(arr, i$2) {
	return _arrayWithHoles$10(arr) || _iterableToArrayLimit$9(arr, i$2) || _unsupportedIterableToArray$17(arr, i$2) || _nonIterableRest$10();
}
function _nonIterableRest$10() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$17(o$1, minLen) {
	if (!o$1) return;
	if (typeof o$1 === "string") return _arrayLikeToArray$17(o$1, minLen);
	var n$1 = Object.prototype.toString.call(o$1).slice(8, -1);
	if (n$1 === "Object" && o$1.constructor) n$1 = o$1.constructor.name;
	if (n$1 === "Map" || n$1 === "Set") return Array.from(o$1);
	if (n$1 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n$1)) return _arrayLikeToArray$17(o$1, minLen);
}
function _arrayLikeToArray$17(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i$2 = 0, arr2 = new Array(len); i$2 < len; i$2++) arr2[i$2] = arr[i$2];
	return arr2;
}
function _iterableToArrayLimit$9(r$1, l) {
	var t$1 = null == r$1 ? null : "undefined" != typeof Symbol && r$1[Symbol.iterator] || r$1["@@iterator"];
	if (null != t$1) {
		var e, n$1, i$2, u, a$2 = [], f = !0, o$1 = !1;
		try {
			if (i$2 = (t$1 = t$1.call(r$1)).next, 0 === l) {
				if (Object(t$1) !== t$1) return;
				f = !1;
			} else for (; !(f = (e = i$2.call(t$1)).done) && (a$2.push(e.value), a$2.length !== l); f = !0);
		} catch (r$2) {
			o$1 = !0, n$1 = r$2;
		} finally {
			try {
				if (!f && null != t$1["return"] && (u = t$1["return"](), Object(u) !== u)) return;
			} finally {
				if (o$1) throw n$1;
			}
		}
		return a$2;
	}
}
function _arrayWithHoles$10(arr) {
	if (Array.isArray(arr)) return arr;
}
function _classCallCheck$15(instance, Constructor) {
	if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties$15(target, props) {
	for (var i$2 = 0; i$2 < props.length; i$2++) {
		var descriptor = props[i$2];
		descriptor.enumerable = descriptor.enumerable || false;
		descriptor.configurable = true;
		if ("value" in descriptor) descriptor.writable = true;
		Object.defineProperty(target, _toPropertyKey$33(descriptor.key), descriptor);
	}
}
function _createClass$15(Constructor, protoProps, staticProps) {
	if (protoProps) _defineProperties$15(Constructor.prototype, protoProps);
	if (staticProps) _defineProperties$15(Constructor, staticProps);
	Object.defineProperty(Constructor, "prototype", { writable: false });
	return Constructor;
}
function _toPropertyKey$33(t$1) {
	var i$2 = _toPrimitive$33(t$1, "string");
	return "symbol" == _typeof$35(i$2) ? i$2 : i$2 + "";
}
function _toPrimitive$33(t$1, r$1) {
	if ("object" != _typeof$35(t$1) || !t$1) return t$1;
	var e = t$1[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i$2 = e.call(t$1, r$1 || "default");
		if ("object" != _typeof$35(i$2)) return i$2;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t$1);
}
var MULTIPLY_OR_DIVIDE_REGEX = /(-?\d+(?:\.\d+)?[a-zA-Z%]*)([*/])(-?\d+(?:\.\d+)?[a-zA-Z%]*)/;
var ADD_OR_SUBTRACT_REGEX = /(-?\d+(?:\.\d+)?[a-zA-Z%]*)([+-])(-?\d+(?:\.\d+)?[a-zA-Z%]*)/;
var CSS_LENGTH_UNIT_REGEX = /^px|cm|vh|vw|em|rem|%|mm|in|pt|pc|ex|ch|vmin|vmax|Q$/;
var NUM_SPLIT_REGEX = /(-?\d+(?:\.\d+)?)([a-zA-Z%]+)?/;
var CONVERSION_RATES = {
	cm: 96 / 2.54,
	mm: 96 / 25.4,
	pt: 96 / 72,
	pc: 96 / 6,
	"in": 96,
	Q: 96 / (2.54 * 40),
	px: 1
};
var FIXED_CSS_LENGTH_UNITS = Object.keys(CONVERSION_RATES);
var STR_NAN = "NaN";
function convertToPx(value, unit$1) {
	return value * CONVERSION_RATES[unit$1];
}
var DecimalCSS = /* @__PURE__ */ function() {
	function DecimalCSS$1(num, unit$1) {
		_classCallCheck$15(this, DecimalCSS$1);
		this.num = num;
		this.unit = unit$1;
		this.num = num;
		this.unit = unit$1;
		if (Number.isNaN(num)) this.unit = "";
		if (unit$1 !== "" && !CSS_LENGTH_UNIT_REGEX.test(unit$1)) {
			this.num = NaN;
			this.unit = "";
		}
		if (FIXED_CSS_LENGTH_UNITS.includes(unit$1)) {
			this.num = convertToPx(num, unit$1);
			this.unit = "px";
		}
	}
	return _createClass$15(DecimalCSS$1, [
		{
			key: "add",
			value: function add(other) {
				if (this.unit !== other.unit) return new DecimalCSS$1(NaN, "");
				return new DecimalCSS$1(this.num + other.num, this.unit);
			}
		},
		{
			key: "subtract",
			value: function subtract(other) {
				if (this.unit !== other.unit) return new DecimalCSS$1(NaN, "");
				return new DecimalCSS$1(this.num - other.num, this.unit);
			}
		},
		{
			key: "multiply",
			value: function multiply(other) {
				if (this.unit !== "" && other.unit !== "" && this.unit !== other.unit) return new DecimalCSS$1(NaN, "");
				return new DecimalCSS$1(this.num * other.num, this.unit || other.unit);
			}
		},
		{
			key: "divide",
			value: function divide(other) {
				if (this.unit !== "" && other.unit !== "" && this.unit !== other.unit) return new DecimalCSS$1(NaN, "");
				return new DecimalCSS$1(this.num / other.num, this.unit || other.unit);
			}
		},
		{
			key: "toString",
			value: function toString$4() {
				return "".concat(this.num).concat(this.unit);
			}
		},
		{
			key: "isNaN",
			value: function isNaN$2() {
				return Number.isNaN(this.num);
			}
		}
	], [{
		key: "parse",
		value: function parse$2(str) {
			var _NUM_SPLIT_REGEX$exec;
			var _ref2 = _slicedToArray$9((_NUM_SPLIT_REGEX$exec = NUM_SPLIT_REGEX.exec(str)) !== null && _NUM_SPLIT_REGEX$exec !== void 0 ? _NUM_SPLIT_REGEX$exec : [], 3), numStr = _ref2[1], unit$1 = _ref2[2];
			return new DecimalCSS$1(parseFloat(numStr), unit$1 !== null && unit$1 !== void 0 ? unit$1 : "");
		}
	}]);
}();
function calculateArithmetic(expr) {
	if (expr.includes(STR_NAN)) return STR_NAN;
	var newExpr = expr;
	while (newExpr.includes("*") || newExpr.includes("/")) {
		var _MULTIPLY_OR_DIVIDE_R;
		var _ref4 = _slicedToArray$9((_MULTIPLY_OR_DIVIDE_R = MULTIPLY_OR_DIVIDE_REGEX.exec(newExpr)) !== null && _MULTIPLY_OR_DIVIDE_R !== void 0 ? _MULTIPLY_OR_DIVIDE_R : [], 4), leftOperand = _ref4[1], operator = _ref4[2], rightOperand = _ref4[3];
		var lTs = DecimalCSS.parse(leftOperand !== null && leftOperand !== void 0 ? leftOperand : "");
		var rTs = DecimalCSS.parse(rightOperand !== null && rightOperand !== void 0 ? rightOperand : "");
		var result = operator === "*" ? lTs.multiply(rTs) : lTs.divide(rTs);
		if (result.isNaN()) return STR_NAN;
		newExpr = newExpr.replace(MULTIPLY_OR_DIVIDE_REGEX, result.toString());
	}
	while (newExpr.includes("+") || /.-\d+(?:\.\d+)?/.test(newExpr)) {
		var _ADD_OR_SUBTRACT_REGE;
		var _ref6 = _slicedToArray$9((_ADD_OR_SUBTRACT_REGE = ADD_OR_SUBTRACT_REGEX.exec(newExpr)) !== null && _ADD_OR_SUBTRACT_REGE !== void 0 ? _ADD_OR_SUBTRACT_REGE : [], 4), _leftOperand = _ref6[1], _operator = _ref6[2], _rightOperand = _ref6[3];
		var _lTs = DecimalCSS.parse(_leftOperand !== null && _leftOperand !== void 0 ? _leftOperand : "");
		var _rTs = DecimalCSS.parse(_rightOperand !== null && _rightOperand !== void 0 ? _rightOperand : "");
		var _result = _operator === "+" ? _lTs.add(_rTs) : _lTs.subtract(_rTs);
		if (_result.isNaN()) return STR_NAN;
		newExpr = newExpr.replace(ADD_OR_SUBTRACT_REGEX, _result.toString());
	}
	return newExpr;
}
var PARENTHESES_REGEX = /\(([^()]*)\)/;
function calculateParentheses(expr) {
	var newExpr = expr;
	while (newExpr.includes("(")) {
		var parentheticalExpression = _slicedToArray$9(PARENTHESES_REGEX.exec(newExpr), 2)[1];
		newExpr = newExpr.replace(PARENTHESES_REGEX, calculateArithmetic(parentheticalExpression));
	}
	return newExpr;
}
function evaluateExpression(expression) {
	var newExpr = expression.replace(/\s+/g, "");
	newExpr = calculateParentheses(newExpr);
	newExpr = calculateArithmetic(newExpr);
	return newExpr;
}
function safeEvaluateExpression(expression) {
	try {
		return evaluateExpression(expression);
	} catch (e) {
		/* istanbul ignore next */
		return STR_NAN;
	}
}
function reduceCSSCalc(expression) {
	var result = safeEvaluateExpression(expression.slice(5, -1));
	if (result === STR_NAN) return "";
	return result;
}
var import_isNil$8 = /* @__PURE__ */ __toESM(require_isNil());
var _excluded$13 = [
	"x",
	"y",
	"lineHeight",
	"capHeight",
	"scaleToFit",
	"textAnchor",
	"verticalAnchor",
	"fill"
], _excluded2$6 = [
	"dx",
	"dy",
	"angle",
	"className",
	"breakAll"
];
function _extends$22() {
	_extends$22 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i$2 = 1; i$2 < arguments.length; i$2++) {
			var source = arguments[i$2];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$22.apply(this, arguments);
}
function _objectWithoutProperties$13(source, excluded) {
	if (source == null) return {};
	var target = _objectWithoutPropertiesLoose$13(source, excluded);
	var key, i$2;
	if (Object.getOwnPropertySymbols) {
		var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
		for (i$2 = 0; i$2 < sourceSymbolKeys.length; i$2++) {
			key = sourceSymbolKeys[i$2];
			if (excluded.indexOf(key) >= 0) continue;
			if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
			target[key] = source[key];
		}
	}
	return target;
}
function _objectWithoutPropertiesLoose$13(source, excluded) {
	if (source == null) return {};
	var target = {};
	for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) {
		if (excluded.indexOf(key) >= 0) continue;
		target[key] = source[key];
	}
	return target;
}
function _slicedToArray$8(arr, i$2) {
	return _arrayWithHoles$9(arr) || _iterableToArrayLimit$8(arr, i$2) || _unsupportedIterableToArray$16(arr, i$2) || _nonIterableRest$9();
}
function _nonIterableRest$9() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$16(o$1, minLen) {
	if (!o$1) return;
	if (typeof o$1 === "string") return _arrayLikeToArray$16(o$1, minLen);
	var n$1 = Object.prototype.toString.call(o$1).slice(8, -1);
	if (n$1 === "Object" && o$1.constructor) n$1 = o$1.constructor.name;
	if (n$1 === "Map" || n$1 === "Set") return Array.from(o$1);
	if (n$1 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n$1)) return _arrayLikeToArray$16(o$1, minLen);
}
function _arrayLikeToArray$16(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i$2 = 0, arr2 = new Array(len); i$2 < len; i$2++) arr2[i$2] = arr[i$2];
	return arr2;
}
function _iterableToArrayLimit$8(r$1, l) {
	var t$1 = null == r$1 ? null : "undefined" != typeof Symbol && r$1[Symbol.iterator] || r$1["@@iterator"];
	if (null != t$1) {
		var e, n$1, i$2, u, a$2 = [], f = !0, o$1 = !1;
		try {
			if (i$2 = (t$1 = t$1.call(r$1)).next, 0 === l) {
				if (Object(t$1) !== t$1) return;
				f = !1;
			} else for (; !(f = (e = i$2.call(t$1)).done) && (a$2.push(e.value), a$2.length !== l); f = !0);
		} catch (r$2) {
			o$1 = !0, n$1 = r$2;
		} finally {
			try {
				if (!f && null != t$1["return"] && (u = t$1["return"](), Object(u) !== u)) return;
			} finally {
				if (o$1) throw n$1;
			}
		}
		return a$2;
	}
}
function _arrayWithHoles$9(arr) {
	if (Array.isArray(arr)) return arr;
}
var BREAKING_SPACES = /[ \f\n\r\t\v\u2028\u2029]+/;
var calculateWordWidths = function calculateWordWidths$1(_ref) {
	var children = _ref.children, breakAll = _ref.breakAll, style = _ref.style;
	try {
		var words = [];
		if (!(0, import_isNil$8.default)(children)) if (breakAll) words = children.toString().split("");
		else words = children.toString().split(BREAKING_SPACES);
		return {
			wordsWithComputedWidth: words.map(function(word) {
				return {
					word,
					width: getStringSize(word, style).width
				};
			}),
			spaceWidth: breakAll ? 0 : getStringSize("\xA0", style).width
		};
	} catch (e) {
		return null;
	}
};
var calculateWordsByLines = function calculateWordsByLines$1(_ref2, initialWordsWithComputedWith, spaceWidth, lineWidth, scaleToFit) {
	var maxLines = _ref2.maxLines, children = _ref2.children, style = _ref2.style, breakAll = _ref2.breakAll;
	var shouldLimitLines = isNumber(maxLines);
	var text = children;
	var calculate = function calculate$1() {
		return (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : []).reduce(function(result$1, _ref3) {
			var word = _ref3.word, width = _ref3.width;
			var currentLine = result$1[result$1.length - 1];
			if (currentLine && (lineWidth == null || scaleToFit || currentLine.width + width + spaceWidth < Number(lineWidth))) {
				currentLine.words.push(word);
				currentLine.width += width + spaceWidth;
			} else {
				var newLine = {
					words: [word],
					width
				};
				result$1.push(newLine);
			}
			return result$1;
		}, []);
	};
	var originalResult = calculate(initialWordsWithComputedWith);
	var findLongestLine = function findLongestLine$1(words) {
		return words.reduce(function(a$2, b) {
			return a$2.width > b.width ? a$2 : b;
		});
	};
	if (!shouldLimitLines) return originalResult;
	var suffix = "";
	var checkOverflow = function checkOverflow$1(index) {
		var words = calculateWordWidths({
			breakAll,
			style,
			children: text.slice(0, index) + suffix
		}).wordsWithComputedWidth;
		var result$1 = calculate(words);
		return [result$1.length > maxLines || findLongestLine(result$1).width > Number(lineWidth), result$1];
	};
	var start = 0;
	var end = text.length - 1;
	var iterations = 0;
	var trimmedResult;
	while (start <= end && iterations <= text.length - 1) {
		var middle = Math.floor((start + end) / 2);
		var _checkOverflow2 = _slicedToArray$8(checkOverflow(middle - 1), 2), doesPrevOverflow = _checkOverflow2[0], result = _checkOverflow2[1];
		var doesMiddleOverflow = _slicedToArray$8(checkOverflow(middle), 1)[0];
		if (!doesPrevOverflow && !doesMiddleOverflow) start = middle + 1;
		if (doesPrevOverflow && doesMiddleOverflow) end = middle - 1;
		if (!doesPrevOverflow && doesMiddleOverflow) {
			trimmedResult = result;
			break;
		}
		iterations++;
	}
	return trimmedResult || originalResult;
};
var getWordsWithoutCalculate = function getWordsWithoutCalculate$1(children) {
	return [{ words: !(0, import_isNil$8.default)(children) ? children.toString().split(BREAKING_SPACES) : [] }];
};
var getWordsByLines = function getWordsByLines$1(_ref4) {
	var width = _ref4.width, scaleToFit = _ref4.scaleToFit, children = _ref4.children, style = _ref4.style, breakAll = _ref4.breakAll, maxLines = _ref4.maxLines;
	if ((width || scaleToFit) && !Global.isSsr) {
		var wordsWithComputedWidth, spaceWidth;
		var wordWidths = calculateWordWidths({
			breakAll,
			children,
			style
		});
		if (wordWidths) {
			var wcw = wordWidths.wordsWithComputedWidth, sw = wordWidths.spaceWidth;
			wordsWithComputedWidth = wcw;
			spaceWidth = sw;
		} else return getWordsWithoutCalculate(children);
		return calculateWordsByLines({
			breakAll,
			children,
			maxLines,
			style
		}, wordsWithComputedWidth, spaceWidth, width, scaleToFit);
	}
	return getWordsWithoutCalculate(children);
};
var DEFAULT_FILL = "#808080";
var Text = function Text$1(_ref5) {
	var _ref5$x = _ref5.x, propsX = _ref5$x === void 0 ? 0 : _ref5$x, _ref5$y = _ref5.y, propsY = _ref5$y === void 0 ? 0 : _ref5$y, _ref5$lineHeight = _ref5.lineHeight, lineHeight = _ref5$lineHeight === void 0 ? "1em" : _ref5$lineHeight, _ref5$capHeight = _ref5.capHeight, capHeight = _ref5$capHeight === void 0 ? "0.71em" : _ref5$capHeight, _ref5$scaleToFit = _ref5.scaleToFit, scaleToFit = _ref5$scaleToFit === void 0 ? false : _ref5$scaleToFit, _ref5$textAnchor = _ref5.textAnchor, textAnchor = _ref5$textAnchor === void 0 ? "start" : _ref5$textAnchor, _ref5$verticalAnchor = _ref5.verticalAnchor, verticalAnchor = _ref5$verticalAnchor === void 0 ? "end" : _ref5$verticalAnchor, _ref5$fill = _ref5.fill, fill = _ref5$fill === void 0 ? DEFAULT_FILL : _ref5$fill, props = _objectWithoutProperties$13(_ref5, _excluded$13);
	var wordsByLines = (0, import_react.useMemo)(function() {
		return getWordsByLines({
			breakAll: props.breakAll,
			children: props.children,
			maxLines: props.maxLines,
			scaleToFit,
			style: props.style,
			width: props.width
		});
	}, [
		props.breakAll,
		props.children,
		props.maxLines,
		scaleToFit,
		props.style,
		props.width
	]);
	var dx = props.dx, dy = props.dy, angle = props.angle, className = props.className, breakAll = props.breakAll, textProps = _objectWithoutProperties$13(props, _excluded2$6);
	if (!isNumOrStr(propsX) || !isNumOrStr(propsY)) return null;
	var x$1 = propsX + (isNumber(dx) ? dx : 0);
	var y$1 = propsY + (isNumber(dy) ? dy : 0);
	var startDy;
	switch (verticalAnchor) {
		case "start":
			startDy = reduceCSSCalc("calc(".concat(capHeight, ")"));
			break;
		case "middle":
			startDy = reduceCSSCalc("calc(".concat((wordsByLines.length - 1) / 2, " * -").concat(lineHeight, " + (").concat(capHeight, " / 2))"));
			break;
		default:
			startDy = reduceCSSCalc("calc(".concat(wordsByLines.length - 1, " * -").concat(lineHeight, ")"));
			break;
	}
	var transforms = [];
	if (scaleToFit) {
		var lineWidth = wordsByLines[0].width;
		var width = props.width;
		transforms.push("scale(".concat((isNumber(width) ? width / lineWidth : 1) / lineWidth, ")"));
	}
	if (angle) transforms.push("rotate(".concat(angle, ", ").concat(x$1, ", ").concat(y$1, ")"));
	if (transforms.length) textProps.transform = transforms.join(" ");
	return /* @__PURE__ */ import_react.createElement("text", _extends$22({}, filterProps(textProps, true), {
		x: x$1,
		y: y$1,
		className: clsx_default("recharts-text", className),
		textAnchor,
		fill: fill.includes("url") ? DEFAULT_FILL : fill
	}), wordsByLines.map(function(line, index) {
		var words = line.words.join(breakAll ? "" : " ");
		return /* @__PURE__ */ import_react.createElement("tspan", {
			x: x$1,
			dy: index === 0 ? startDy : lineHeight,
			key: "".concat(words, "-").concat(index)
		}, words);
	}));
};
function ascending(a$2, b) {
	return a$2 == null || b == null ? NaN : a$2 < b ? -1 : a$2 > b ? 1 : a$2 >= b ? 0 : NaN;
}
function descending(a$2, b) {
	return a$2 == null || b == null ? NaN : b < a$2 ? -1 : b > a$2 ? 1 : b >= a$2 ? 0 : NaN;
}
function bisector(f) {
	let compare1, compare2, delta;
	if (f.length !== 2) {
		compare1 = ascending;
		compare2 = (d, x$1) => ascending(f(d), x$1);
		delta = (d, x$1) => f(d) - x$1;
	} else {
		compare1 = f === ascending || f === descending ? f : zero$1;
		compare2 = f;
		delta = f;
	}
	function left(a$2, x$1, lo = 0, hi = a$2.length) {
		if (lo < hi) {
			if (compare1(x$1, x$1) !== 0) return hi;
			do {
				const mid = lo + hi >>> 1;
				if (compare2(a$2[mid], x$1) < 0) lo = mid + 1;
				else hi = mid;
			} while (lo < hi);
		}
		return lo;
	}
	function right(a$2, x$1, lo = 0, hi = a$2.length) {
		if (lo < hi) {
			if (compare1(x$1, x$1) !== 0) return hi;
			do {
				const mid = lo + hi >>> 1;
				if (compare2(a$2[mid], x$1) <= 0) lo = mid + 1;
				else hi = mid;
			} while (lo < hi);
		}
		return lo;
	}
	function center(a$2, x$1, lo = 0, hi = a$2.length) {
		const i$2 = left(a$2, x$1, lo, hi - 1);
		return i$2 > lo && delta(a$2[i$2 - 1], x$1) > -delta(a$2[i$2], x$1) ? i$2 - 1 : i$2;
	}
	return {
		left,
		center,
		right
	};
}
function zero$1() {
	return 0;
}
function number$2(x$1) {
	return x$1 === null ? NaN : +x$1;
}
function* numbers(values, valueof) {
	if (valueof === void 0) {
		for (let value of values) if (value != null && (value = +value) >= value) yield value;
	} else {
		let index = -1;
		for (let value of values) if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) yield value;
	}
}
var ascendingBisect = bisector(ascending);
const bisectRight = ascendingBisect.right;
ascendingBisect.left;
bisector(number$2).center;
var bisect_default = bisectRight;
var InternMap = class extends Map {
	constructor(entries, key = keyof) {
		super();
		Object.defineProperties(this, {
			_intern: { value: /* @__PURE__ */ new Map() },
			_key: { value: key }
		});
		if (entries != null) for (const [key$1, value] of entries) this.set(key$1, value);
	}
	get(key) {
		return super.get(intern_get(this, key));
	}
	has(key) {
		return super.has(intern_get(this, key));
	}
	set(key, value) {
		return super.set(intern_set(this, key), value);
	}
	delete(key) {
		return super.delete(intern_delete(this, key));
	}
};
function intern_get({ _intern, _key }, value) {
	const key = _key(value);
	return _intern.has(key) ? _intern.get(key) : value;
}
function intern_set({ _intern, _key }, value) {
	const key = _key(value);
	if (_intern.has(key)) return _intern.get(key);
	_intern.set(key, value);
	return value;
}
function intern_delete({ _intern, _key }, value) {
	const key = _key(value);
	if (_intern.has(key)) {
		value = _intern.get(key);
		_intern.delete(key);
	}
	return value;
}
function keyof(value) {
	return value !== null && typeof value === "object" ? value.valueOf() : value;
}
function compareDefined(compare = ascending) {
	if (compare === ascending) return ascendingDefined;
	if (typeof compare !== "function") throw new TypeError("compare is not a function");
	return (a$2, b) => {
		const x$1 = compare(a$2, b);
		if (x$1 || x$1 === 0) return x$1;
		return (compare(b, b) === 0) - (compare(a$2, a$2) === 0);
	};
}
function ascendingDefined(a$2, b) {
	return (a$2 == null || !(a$2 >= a$2)) - (b == null || !(b >= b)) || (a$2 < b ? -1 : a$2 > b ? 1 : 0);
}
var e10 = Math.sqrt(50), e5 = Math.sqrt(10), e2 = Math.sqrt(2);
function tickSpec(start, stop, count) {
	const step = (stop - start) / Math.max(0, count), power = Math.floor(Math.log10(step)), error = step / Math.pow(10, power), factor = error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1;
	let i1, i2, inc;
	if (power < 0) {
		inc = Math.pow(10, -power) / factor;
		i1 = Math.round(start * inc);
		i2 = Math.round(stop * inc);
		if (i1 / inc < start) ++i1;
		if (i2 / inc > stop) --i2;
		inc = -inc;
	} else {
		inc = Math.pow(10, power) * factor;
		i1 = Math.round(start / inc);
		i2 = Math.round(stop / inc);
		if (i1 * inc < start) ++i1;
		if (i2 * inc > stop) --i2;
	}
	if (i2 < i1 && .5 <= count && count < 2) return tickSpec(start, stop, count * 2);
	return [
		i1,
		i2,
		inc
	];
}
function ticks(start, stop, count) {
	stop = +stop, start = +start, count = +count;
	if (!(count > 0)) return [];
	if (start === stop) return [start];
	const reverse$1 = stop < start, [i1, i2, inc] = reverse$1 ? tickSpec(stop, start, count) : tickSpec(start, stop, count);
	if (!(i2 >= i1)) return [];
	const n$1 = i2 - i1 + 1, ticks$1 = new Array(n$1);
	if (reverse$1) if (inc < 0) for (let i$2 = 0; i$2 < n$1; ++i$2) ticks$1[i$2] = (i2 - i$2) / -inc;
	else for (let i$2 = 0; i$2 < n$1; ++i$2) ticks$1[i$2] = (i2 - i$2) * inc;
	else if (inc < 0) for (let i$2 = 0; i$2 < n$1; ++i$2) ticks$1[i$2] = (i1 + i$2) / -inc;
	else for (let i$2 = 0; i$2 < n$1; ++i$2) ticks$1[i$2] = (i1 + i$2) * inc;
	return ticks$1;
}
function tickIncrement(start, stop, count) {
	stop = +stop, start = +start, count = +count;
	return tickSpec(start, stop, count)[2];
}
function tickStep(start, stop, count) {
	stop = +stop, start = +start, count = +count;
	const reverse$1 = stop < start, inc = reverse$1 ? tickIncrement(stop, start, count) : tickIncrement(start, stop, count);
	return (reverse$1 ? -1 : 1) * (inc < 0 ? 1 / -inc : inc);
}
function max$3(values, valueof) {
	let max$4;
	if (valueof === void 0) {
		for (const value of values) if (value != null && (max$4 < value || max$4 === void 0 && value >= value)) max$4 = value;
	} else {
		let index = -1;
		for (let value of values) if ((value = valueof(value, ++index, values)) != null && (max$4 < value || max$4 === void 0 && value >= value)) max$4 = value;
	}
	return max$4;
}
function min$2(values, valueof) {
	let min$3;
	if (valueof === void 0) {
		for (const value of values) if (value != null && (min$3 > value || min$3 === void 0 && value >= value)) min$3 = value;
	} else {
		let index = -1;
		for (let value of values) if ((value = valueof(value, ++index, values)) != null && (min$3 > value || min$3 === void 0 && value >= value)) min$3 = value;
	}
	return min$3;
}
function quickselect(array$1, k$1, left = 0, right = Infinity, compare) {
	k$1 = Math.floor(k$1);
	left = Math.floor(Math.max(0, left));
	right = Math.floor(Math.min(array$1.length - 1, right));
	if (!(left <= k$1 && k$1 <= right)) return array$1;
	compare = compare === void 0 ? ascendingDefined : compareDefined(compare);
	while (right > left) {
		if (right - left > 600) {
			const n$1 = right - left + 1;
			const m = k$1 - left + 1;
			const z = Math.log(n$1);
			const s$3 = .5 * Math.exp(2 * z / 3);
			const sd = .5 * Math.sqrt(z * s$3 * (n$1 - s$3) / n$1) * (m - n$1 / 2 < 0 ? -1 : 1);
			const newLeft = Math.max(left, Math.floor(k$1 - m * s$3 / n$1 + sd));
			const newRight = Math.min(right, Math.floor(k$1 + (n$1 - m) * s$3 / n$1 + sd));
			quickselect(array$1, k$1, newLeft, newRight, compare);
		}
		const t$1 = array$1[k$1];
		let i$2 = left;
		let j = right;
		swap(array$1, left, k$1);
		if (compare(array$1[right], t$1) > 0) swap(array$1, left, right);
		while (i$2 < j) {
			swap(array$1, i$2, j), ++i$2, --j;
			while (compare(array$1[i$2], t$1) < 0) ++i$2;
			while (compare(array$1[j], t$1) > 0) --j;
		}
		if (compare(array$1[left], t$1) === 0) swap(array$1, left, j);
		else ++j, swap(array$1, j, right);
		if (j <= k$1) left = j + 1;
		if (k$1 <= j) right = j - 1;
	}
	return array$1;
}
function swap(array$1, i$2, j) {
	const t$1 = array$1[i$2];
	array$1[i$2] = array$1[j];
	array$1[j] = t$1;
}
function quantile(values, p, valueof) {
	values = Float64Array.from(numbers(values, valueof));
	if (!(n$1 = values.length) || isNaN(p = +p)) return;
	if (p <= 0 || n$1 < 2) return min$2(values);
	if (p >= 1) return max$3(values);
	var n$1, i$2 = (n$1 - 1) * p, i0 = Math.floor(i$2), value0 = max$3(quickselect(values, i0).subarray(0, i0 + 1));
	return value0 + (min$2(values.subarray(i0 + 1)) - value0) * (i$2 - i0);
}
function quantileSorted(values, p, valueof = number$2) {
	if (!(n$1 = values.length) || isNaN(p = +p)) return;
	if (p <= 0 || n$1 < 2) return +valueof(values[0], 0, values);
	if (p >= 1) return +valueof(values[n$1 - 1], n$1 - 1, values);
	var n$1, i$2 = (n$1 - 1) * p, i0 = Math.floor(i$2), value0 = +valueof(values[i0], i0, values);
	return value0 + (+valueof(values[i0 + 1], i0 + 1, values) - value0) * (i$2 - i0);
}
function range$4(start, stop, step) {
	start = +start, stop = +stop, step = (n$1 = arguments.length) < 2 ? (stop = start, start = 0, 1) : n$1 < 3 ? 1 : +step;
	var i$2 = -1, n$1 = Math.max(0, Math.ceil((stop - start) / step)) | 0, range$5 = new Array(n$1);
	while (++i$2 < n$1) range$5[i$2] = start + i$2 * step;
	return range$5;
}
function initRange(domain, range$5) {
	switch (arguments.length) {
		case 0: break;
		case 1:
			this.range(domain);
			break;
		default:
			this.range(range$5).domain(domain);
			break;
	}
	return this;
}
function initInterpolator(domain, interpolator) {
	switch (arguments.length) {
		case 0: break;
		case 1:
			if (typeof domain === "function") this.interpolator(domain);
			else this.range(domain);
			break;
		default:
			this.domain(domain);
			if (typeof interpolator === "function") this.interpolator(interpolator);
			else this.range(interpolator);
			break;
	}
	return this;
}
const implicit = Symbol("implicit");
function ordinal() {
	var index = new InternMap(), domain = [], range$5 = [], unknown$1 = implicit;
	function scale(d) {
		let i$2 = index.get(d);
		if (i$2 === void 0) {
			if (unknown$1 !== implicit) return unknown$1;
			index.set(d, i$2 = domain.push(d) - 1);
		}
		return range$5[i$2 % range$5.length];
	}
	scale.domain = function(_) {
		if (!arguments.length) return domain.slice();
		domain = [], index = new InternMap();
		for (const value of _) {
			if (index.has(value)) continue;
			index.set(value, domain.push(value) - 1);
		}
		return scale;
	};
	scale.range = function(_) {
		return arguments.length ? (range$5 = Array.from(_), scale) : range$5.slice();
	};
	scale.unknown = function(_) {
		return arguments.length ? (unknown$1 = _, scale) : unknown$1;
	};
	scale.copy = function() {
		return ordinal(domain, range$5).unknown(unknown$1);
	};
	initRange.apply(scale, arguments);
	return scale;
}
function band() {
	var scale = ordinal().unknown(void 0), domain = scale.domain, ordinalRange = scale.range, r0 = 0, r1 = 1, step, bandwidth, round = false, paddingInner = 0, paddingOuter = 0, align = .5;
	delete scale.unknown;
	function rescale() {
		var n$1 = domain().length, reverse$1 = r1 < r0, start = reverse$1 ? r1 : r0, stop = reverse$1 ? r0 : r1;
		step = (stop - start) / Math.max(1, n$1 - paddingInner + paddingOuter * 2);
		if (round) step = Math.floor(step);
		start += (stop - start - step * (n$1 - paddingInner)) * align;
		bandwidth = step * (1 - paddingInner);
		if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);
		var values = range$4(n$1).map(function(i$2) {
			return start + step * i$2;
		});
		return ordinalRange(reverse$1 ? values.reverse() : values);
	}
	scale.domain = function(_) {
		return arguments.length ? (domain(_), rescale()) : domain();
	};
	scale.range = function(_) {
		return arguments.length ? ([r0, r1] = _, r0 = +r0, r1 = +r1, rescale()) : [r0, r1];
	};
	scale.rangeRound = function(_) {
		return [r0, r1] = _, r0 = +r0, r1 = +r1, round = true, rescale();
	};
	scale.bandwidth = function() {
		return bandwidth;
	};
	scale.step = function() {
		return step;
	};
	scale.round = function(_) {
		return arguments.length ? (round = !!_, rescale()) : round;
	};
	scale.padding = function(_) {
		return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;
	};
	scale.paddingInner = function(_) {
		return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;
	};
	scale.paddingOuter = function(_) {
		return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;
	};
	scale.align = function(_) {
		return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
	};
	scale.copy = function() {
		return band(domain(), [r0, r1]).round(round).paddingInner(paddingInner).paddingOuter(paddingOuter).align(align);
	};
	return initRange.apply(rescale(), arguments);
}
function pointish(scale) {
	var copy$2 = scale.copy;
	scale.padding = scale.paddingOuter;
	delete scale.paddingInner;
	delete scale.paddingOuter;
	scale.copy = function() {
		return pointish(copy$2());
	};
	return scale;
}
function point() {
	return pointish(band.apply(null, arguments).paddingInner(1));
}
function define_default(constructor, factory, prototype) {
	constructor.prototype = factory.prototype = prototype;
	prototype.constructor = constructor;
}
function extend(parent, definition) {
	var prototype = Object.create(parent.prototype);
	for (var key in definition) prototype[key] = definition[key];
	return prototype;
}
function Color() {}
var darker = .7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*", reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", reHex = /^#([0-9a-f]{3,8})$/, reRgbInteger = /* @__PURE__ */ new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`), reRgbPercent = /* @__PURE__ */ new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`), reRgbaInteger = /* @__PURE__ */ new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`), reRgbaPercent = /* @__PURE__ */ new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`), reHslPercent = /* @__PURE__ */ new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`), reHslaPercent = /* @__PURE__ */ new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
var named = {
	aliceblue: 15792383,
	antiquewhite: 16444375,
	aqua: 65535,
	aquamarine: 8388564,
	azure: 15794175,
	beige: 16119260,
	bisque: 16770244,
	black: 0,
	blanchedalmond: 16772045,
	blue: 255,
	blueviolet: 9055202,
	brown: 10824234,
	burlywood: 14596231,
	cadetblue: 6266528,
	chartreuse: 8388352,
	chocolate: 13789470,
	coral: 16744272,
	cornflowerblue: 6591981,
	cornsilk: 16775388,
	crimson: 14423100,
	cyan: 65535,
	darkblue: 139,
	darkcyan: 35723,
	darkgoldenrod: 12092939,
	darkgray: 11119017,
	darkgreen: 25600,
	darkgrey: 11119017,
	darkkhaki: 12433259,
	darkmagenta: 9109643,
	darkolivegreen: 5597999,
	darkorange: 16747520,
	darkorchid: 10040012,
	darkred: 9109504,
	darksalmon: 15308410,
	darkseagreen: 9419919,
	darkslateblue: 4734347,
	darkslategray: 3100495,
	darkslategrey: 3100495,
	darkturquoise: 52945,
	darkviolet: 9699539,
	deeppink: 16716947,
	deepskyblue: 49151,
	dimgray: 6908265,
	dimgrey: 6908265,
	dodgerblue: 2003199,
	firebrick: 11674146,
	floralwhite: 16775920,
	forestgreen: 2263842,
	fuchsia: 16711935,
	gainsboro: 14474460,
	ghostwhite: 16316671,
	gold: 16766720,
	goldenrod: 14329120,
	gray: 8421504,
	green: 32768,
	greenyellow: 11403055,
	grey: 8421504,
	honeydew: 15794160,
	hotpink: 16738740,
	indianred: 13458524,
	indigo: 4915330,
	ivory: 16777200,
	khaki: 15787660,
	lavender: 15132410,
	lavenderblush: 16773365,
	lawngreen: 8190976,
	lemonchiffon: 16775885,
	lightblue: 11393254,
	lightcoral: 15761536,
	lightcyan: 14745599,
	lightgoldenrodyellow: 16448210,
	lightgray: 13882323,
	lightgreen: 9498256,
	lightgrey: 13882323,
	lightpink: 16758465,
	lightsalmon: 16752762,
	lightseagreen: 2142890,
	lightskyblue: 8900346,
	lightslategray: 7833753,
	lightslategrey: 7833753,
	lightsteelblue: 11584734,
	lightyellow: 16777184,
	lime: 65280,
	limegreen: 3329330,
	linen: 16445670,
	magenta: 16711935,
	maroon: 8388608,
	mediumaquamarine: 6737322,
	mediumblue: 205,
	mediumorchid: 12211667,
	mediumpurple: 9662683,
	mediumseagreen: 3978097,
	mediumslateblue: 8087790,
	mediumspringgreen: 64154,
	mediumturquoise: 4772300,
	mediumvioletred: 13047173,
	midnightblue: 1644912,
	mintcream: 16121850,
	mistyrose: 16770273,
	moccasin: 16770229,
	navajowhite: 16768685,
	navy: 128,
	oldlace: 16643558,
	olive: 8421376,
	olivedrab: 7048739,
	orange: 16753920,
	orangered: 16729344,
	orchid: 14315734,
	palegoldenrod: 15657130,
	palegreen: 10025880,
	paleturquoise: 11529966,
	palevioletred: 14381203,
	papayawhip: 16773077,
	peachpuff: 16767673,
	peru: 13468991,
	pink: 16761035,
	plum: 14524637,
	powderblue: 11591910,
	purple: 8388736,
	rebeccapurple: 6697881,
	red: 16711680,
	rosybrown: 12357519,
	royalblue: 4286945,
	saddlebrown: 9127187,
	salmon: 16416882,
	sandybrown: 16032864,
	seagreen: 3050327,
	seashell: 16774638,
	sienna: 10506797,
	silver: 12632256,
	skyblue: 8900331,
	slateblue: 6970061,
	slategray: 7372944,
	slategrey: 7372944,
	snow: 16775930,
	springgreen: 65407,
	steelblue: 4620980,
	tan: 13808780,
	teal: 32896,
	thistle: 14204888,
	tomato: 16737095,
	turquoise: 4251856,
	violet: 15631086,
	wheat: 16113331,
	white: 16777215,
	whitesmoke: 16119285,
	yellow: 16776960,
	yellowgreen: 10145074
};
define_default(Color, color, {
	copy(channels) {
		return Object.assign(new this.constructor(), this, channels);
	},
	displayable() {
		return this.rgb().displayable();
	},
	hex: color_formatHex,
	formatHex: color_formatHex,
	formatHex8: color_formatHex8,
	formatHsl: color_formatHsl,
	formatRgb: color_formatRgb,
	toString: color_formatRgb
});
function color_formatHex() {
	return this.rgb().formatHex();
}
function color_formatHex8() {
	return this.rgb().formatHex8();
}
function color_formatHsl() {
	return hslConvert(this).formatHsl();
}
function color_formatRgb() {
	return this.rgb().formatRgb();
}
function color(format$2) {
	var m, l;
	format$2 = (format$2 + "").trim().toLowerCase();
	return (m = reHex.exec(format$2)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) : l === 3 ? new Rgb(m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, (m & 15) << 4 | m & 15, 1) : l === 8 ? rgba(m >> 24 & 255, m >> 16 & 255, m >> 8 & 255, (m & 255) / 255) : l === 4 ? rgba(m >> 12 & 15 | m >> 8 & 240, m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, ((m & 15) << 4 | m & 15) / 255) : null) : (m = reRgbInteger.exec(format$2)) ? new Rgb(m[1], m[2], m[3], 1) : (m = reRgbPercent.exec(format$2)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) : (m = reRgbaInteger.exec(format$2)) ? rgba(m[1], m[2], m[3], m[4]) : (m = reRgbaPercent.exec(format$2)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) : (m = reHslPercent.exec(format$2)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) : (m = reHslaPercent.exec(format$2)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) : named.hasOwnProperty(format$2) ? rgbn(named[format$2]) : format$2 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n$1) {
	return new Rgb(n$1 >> 16 & 255, n$1 >> 8 & 255, n$1 & 255, 1);
}
function rgba(r$1, g, b, a$2) {
	if (a$2 <= 0) r$1 = g = b = NaN;
	return new Rgb(r$1, g, b, a$2);
}
function rgbConvert(o$1) {
	if (!(o$1 instanceof Color)) o$1 = color(o$1);
	if (!o$1) return new Rgb();
	o$1 = o$1.rgb();
	return new Rgb(o$1.r, o$1.g, o$1.b, o$1.opacity);
}
function rgb(r$1, g, b, opacity) {
	return arguments.length === 1 ? rgbConvert(r$1) : new Rgb(r$1, g, b, opacity == null ? 1 : opacity);
}
function Rgb(r$1, g, b, opacity) {
	this.r = +r$1;
	this.g = +g;
	this.b = +b;
	this.opacity = +opacity;
}
define_default(Rgb, rgb, extend(Color, {
	brighter(k$1) {
		k$1 = k$1 == null ? brighter : Math.pow(brighter, k$1);
		return new Rgb(this.r * k$1, this.g * k$1, this.b * k$1, this.opacity);
	},
	darker(k$1) {
		k$1 = k$1 == null ? darker : Math.pow(darker, k$1);
		return new Rgb(this.r * k$1, this.g * k$1, this.b * k$1, this.opacity);
	},
	rgb() {
		return this;
	},
	clamp() {
		return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
	},
	displayable() {
		return -.5 <= this.r && this.r < 255.5 && -.5 <= this.g && this.g < 255.5 && -.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
	},
	hex: rgb_formatHex,
	formatHex: rgb_formatHex,
	formatHex8: rgb_formatHex8,
	formatRgb: rgb_formatRgb,
	toString: rgb_formatRgb
}));
function rgb_formatHex() {
	return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
}
function rgb_formatHex8() {
	return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function rgb_formatRgb() {
	const a$2 = clampa(this.opacity);
	return `${a$2 === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a$2 === 1 ? ")" : `, ${a$2})`}`;
}
function clampa(opacity) {
	return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}
function clampi(value) {
	return Math.max(0, Math.min(255, Math.round(value) || 0));
}
function hex(value) {
	value = clampi(value);
	return (value < 16 ? "0" : "") + value.toString(16);
}
function hsla(h, s$3, l, a$2) {
	if (a$2 <= 0) h = s$3 = l = NaN;
	else if (l <= 0 || l >= 1) h = s$3 = NaN;
	else if (s$3 <= 0) h = NaN;
	return new Hsl(h, s$3, l, a$2);
}
function hslConvert(o$1) {
	if (o$1 instanceof Hsl) return new Hsl(o$1.h, o$1.s, o$1.l, o$1.opacity);
	if (!(o$1 instanceof Color)) o$1 = color(o$1);
	if (!o$1) return new Hsl();
	if (o$1 instanceof Hsl) return o$1;
	o$1 = o$1.rgb();
	var r$1 = o$1.r / 255, g = o$1.g / 255, b = o$1.b / 255, min$3 = Math.min(r$1, g, b), max$4 = Math.max(r$1, g, b), h = NaN, s$3 = max$4 - min$3, l = (max$4 + min$3) / 2;
	if (s$3) {
		if (r$1 === max$4) h = (g - b) / s$3 + (g < b) * 6;
		else if (g === max$4) h = (b - r$1) / s$3 + 2;
		else h = (r$1 - g) / s$3 + 4;
		s$3 /= l < .5 ? max$4 + min$3 : 2 - max$4 - min$3;
		h *= 60;
	} else s$3 = l > 0 && l < 1 ? 0 : h;
	return new Hsl(h, s$3, l, o$1.opacity);
}
function hsl(h, s$3, l, opacity) {
	return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s$3, l, opacity == null ? 1 : opacity);
}
function Hsl(h, s$3, l, opacity) {
	this.h = +h;
	this.s = +s$3;
	this.l = +l;
	this.opacity = +opacity;
}
define_default(Hsl, hsl, extend(Color, {
	brighter(k$1) {
		k$1 = k$1 == null ? brighter : Math.pow(brighter, k$1);
		return new Hsl(this.h, this.s, this.l * k$1, this.opacity);
	},
	darker(k$1) {
		k$1 = k$1 == null ? darker : Math.pow(darker, k$1);
		return new Hsl(this.h, this.s, this.l * k$1, this.opacity);
	},
	rgb() {
		var h = this.h % 360 + (this.h < 0) * 360, s$3 = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < .5 ? l : 1 - l) * s$3, m1 = 2 * l - m2;
		return new Rgb(hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2), hsl2rgb(h, m1, m2), hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2), this.opacity);
	},
	clamp() {
		return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
	},
	displayable() {
		return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
	},
	formatHsl() {
		const a$2 = clampa(this.opacity);
		return `${a$2 === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a$2 === 1 ? ")" : `, ${a$2})`}`;
	}
}));
function clamph(value) {
	value = (value || 0) % 360;
	return value < 0 ? value + 360 : value;
}
function clampt(value) {
	return Math.max(0, Math.min(1, value || 0));
}
function hsl2rgb(h, m1, m2) {
	return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
}
function basis(t1$1, v0, v1, v2, v3) {
	var t2 = t1$1 * t1$1, t3 = t2 * t1$1;
	return ((1 - 3 * t1$1 + 3 * t2 - t3) * v0 + (4 - 6 * t2 + 3 * t3) * v1 + (1 + 3 * t1$1 + 3 * t2 - 3 * t3) * v2 + t3 * v3) / 6;
}
function basis_default$1(values) {
	var n$1 = values.length - 1;
	return function(t$1) {
		var i$2 = t$1 <= 0 ? t$1 = 0 : t$1 >= 1 ? (t$1 = 1, n$1 - 1) : Math.floor(t$1 * n$1), v1 = values[i$2], v2 = values[i$2 + 1], v0 = i$2 > 0 ? values[i$2 - 1] : 2 * v1 - v2, v3 = i$2 < n$1 - 1 ? values[i$2 + 2] : 2 * v2 - v1;
		return basis((t$1 - i$2 / n$1) * n$1, v0, v1, v2, v3);
	};
}
function basisClosed_default$1(values) {
	var n$1 = values.length;
	return function(t$1) {
		var i$2 = Math.floor(((t$1 %= 1) < 0 ? ++t$1 : t$1) * n$1), v0 = values[(i$2 + n$1 - 1) % n$1], v1 = values[i$2 % n$1], v2 = values[(i$2 + 1) % n$1], v3 = values[(i$2 + 2) % n$1];
		return basis((t$1 - i$2 / n$1) * n$1, v0, v1, v2, v3);
	};
}
var constant_default = (x$1) => () => x$1;
function linear$1(a$2, d) {
	return function(t$1) {
		return a$2 + t$1 * d;
	};
}
function exponential(a$2, b, y$1) {
	return a$2 = Math.pow(a$2, y$1), b = Math.pow(b, y$1) - a$2, y$1 = 1 / y$1, function(t$1) {
		return Math.pow(a$2 + t$1 * b, y$1);
	};
}
function gamma(y$1) {
	return (y$1 = +y$1) === 1 ? nogamma : function(a$2, b) {
		return b - a$2 ? exponential(a$2, b, y$1) : constant_default(isNaN(a$2) ? b : a$2);
	};
}
function nogamma(a$2, b) {
	var d = b - a$2;
	return d ? linear$1(a$2, d) : constant_default(isNaN(a$2) ? b : a$2);
}
var rgb_default = (function rgbGamma(y$1) {
	var color$1 = gamma(y$1);
	function rgb$1(start, end) {
		var r$1 = color$1((start = rgb(start)).r, (end = rgb(end)).r), g = color$1(start.g, end.g), b = color$1(start.b, end.b), opacity = nogamma(start.opacity, end.opacity);
		return function(t$1) {
			start.r = r$1(t$1);
			start.g = g(t$1);
			start.b = b(t$1);
			start.opacity = opacity(t$1);
			return start + "";
		};
	}
	rgb$1.gamma = rgbGamma;
	return rgb$1;
})(1);
function rgbSpline(spline) {
	return function(colors) {
		var n$1 = colors.length, r$1 = new Array(n$1), g = new Array(n$1), b = new Array(n$1), i$2, color$1;
		for (i$2 = 0; i$2 < n$1; ++i$2) {
			color$1 = rgb(colors[i$2]);
			r$1[i$2] = color$1.r || 0;
			g[i$2] = color$1.g || 0;
			b[i$2] = color$1.b || 0;
		}
		r$1 = spline(r$1);
		g = spline(g);
		b = spline(b);
		color$1.opacity = 1;
		return function(t$1) {
			color$1.r = r$1(t$1);
			color$1.g = g(t$1);
			color$1.b = b(t$1);
			return color$1 + "";
		};
	};
}
rgbSpline(basis_default$1);
rgbSpline(basisClosed_default$1);
function numberArray_default(a$2, b) {
	if (!b) b = [];
	var n$1 = a$2 ? Math.min(b.length, a$2.length) : 0, c$1 = b.slice(), i$2;
	return function(t$1) {
		for (i$2 = 0; i$2 < n$1; ++i$2) c$1[i$2] = a$2[i$2] * (1 - t$1) + b[i$2] * t$1;
		return c$1;
	};
}
function isNumberArray(x$1) {
	return ArrayBuffer.isView(x$1) && !(x$1 instanceof DataView);
}
function genericArray(a$2, b) {
	var nb = b ? b.length : 0, na = a$2 ? Math.min(nb, a$2.length) : 0, x$1 = new Array(na), c$1 = new Array(nb), i$2;
	for (i$2 = 0; i$2 < na; ++i$2) x$1[i$2] = value_default(a$2[i$2], b[i$2]);
	for (; i$2 < nb; ++i$2) c$1[i$2] = b[i$2];
	return function(t$1) {
		for (i$2 = 0; i$2 < na; ++i$2) c$1[i$2] = x$1[i$2](t$1);
		return c$1;
	};
}
function date_default(a$2, b) {
	var d = /* @__PURE__ */ new Date();
	return a$2 = +a$2, b = +b, function(t$1) {
		return d.setTime(a$2 * (1 - t$1) + b * t$1), d;
	};
}
function number_default(a$2, b) {
	return a$2 = +a$2, b = +b, function(t$1) {
		return a$2 * (1 - t$1) + b * t$1;
	};
}
function object_default(a$2, b) {
	var i$2 = {}, c$1 = {}, k$1;
	if (a$2 === null || typeof a$2 !== "object") a$2 = {};
	if (b === null || typeof b !== "object") b = {};
	for (k$1 in b) if (k$1 in a$2) i$2[k$1] = value_default(a$2[k$1], b[k$1]);
	else c$1[k$1] = b[k$1];
	return function(t$1) {
		for (k$1 in i$2) c$1[k$1] = i$2[k$1](t$1);
		return c$1;
	};
}
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, reB = new RegExp(reA.source, "g");
function zero(b) {
	return function() {
		return b;
	};
}
function one(b) {
	return function(t$1) {
		return b(t$1) + "";
	};
}
function string_default(a$2, b) {
	var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i$2 = -1, s$3 = [], q = [];
	a$2 = a$2 + "", b = b + "";
	while ((am = reA.exec(a$2)) && (bm = reB.exec(b))) {
		if ((bs = bm.index) > bi) {
			bs = b.slice(bi, bs);
			if (s$3[i$2]) s$3[i$2] += bs;
			else s$3[++i$2] = bs;
		}
		if ((am = am[0]) === (bm = bm[0])) if (s$3[i$2]) s$3[i$2] += bm;
		else s$3[++i$2] = bm;
		else {
			s$3[++i$2] = null;
			q.push({
				i: i$2,
				x: number_default(am, bm)
			});
		}
		bi = reB.lastIndex;
	}
	if (bi < b.length) {
		bs = b.slice(bi);
		if (s$3[i$2]) s$3[i$2] += bs;
		else s$3[++i$2] = bs;
	}
	return s$3.length < 2 ? q[0] ? one(q[0].x) : zero(b) : (b = q.length, function(t$1) {
		for (var i$3 = 0, o$1; i$3 < b; ++i$3) s$3[(o$1 = q[i$3]).i] = o$1.x(t$1);
		return s$3.join("");
	});
}
function value_default(a$2, b) {
	var t$1 = typeof b, c$1;
	return b == null || t$1 === "boolean" ? constant_default(b) : (t$1 === "number" ? number_default : t$1 === "string" ? (c$1 = color(b)) ? (b = c$1, rgb_default) : string_default : b instanceof color ? rgb_default : b instanceof Date ? date_default : isNumberArray(b) ? numberArray_default : Array.isArray(b) ? genericArray : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object_default : number_default)(a$2, b);
}
function round_default(a$2, b) {
	return a$2 = +a$2, b = +b, function(t$1) {
		return Math.round(a$2 * (1 - t$1) + b * t$1);
	};
}
function piecewise(interpolate, values) {
	if (values === void 0) values = interpolate, interpolate = value_default;
	var i$2 = 0, n$1 = values.length - 1, v = values[0], I = new Array(n$1 < 0 ? 0 : n$1);
	while (i$2 < n$1) I[i$2] = interpolate(v, v = values[++i$2]);
	return function(t$1) {
		var i$3 = Math.max(0, Math.min(n$1 - 1, Math.floor(t$1 *= n$1)));
		return I[i$3](t$1 - i$3);
	};
}
function constants(x$1) {
	return function() {
		return x$1;
	};
}
function number$1(x$1) {
	return +x$1;
}
var unit = [0, 1];
function identity$4(x$1) {
	return x$1;
}
function normalize(a$2, b) {
	return (b -= a$2 = +a$2) ? function(x$1) {
		return (x$1 - a$2) / b;
	} : constants(isNaN(b) ? NaN : .5);
}
function clamper(a$2, b) {
	var t$1;
	if (a$2 > b) t$1 = a$2, a$2 = b, b = t$1;
	return function(x$1) {
		return Math.max(a$2, Math.min(b, x$1));
	};
}
function bimap(domain, range$5, interpolate) {
	var d0 = domain[0], d1 = domain[1], r0 = range$5[0], r1 = range$5[1];
	if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate(r1, r0);
	else d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
	return function(x$1) {
		return r0(d0(x$1));
	};
}
function polymap(domain, range$5, interpolate) {
	var j = Math.min(domain.length, range$5.length) - 1, d = new Array(j), r$1 = new Array(j), i$2 = -1;
	if (domain[j] < domain[0]) {
		domain = domain.slice().reverse();
		range$5 = range$5.slice().reverse();
	}
	while (++i$2 < j) {
		d[i$2] = normalize(domain[i$2], domain[i$2 + 1]);
		r$1[i$2] = interpolate(range$5[i$2], range$5[i$2 + 1]);
	}
	return function(x$1) {
		var i$3 = bisect_default(domain, x$1, 1, j) - 1;
		return r$1[i$3](d[i$3](x$1));
	};
}
function copy$1(source, target) {
	return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());
}
function transformer$2() {
	var domain = unit, range$5 = unit, interpolate = value_default, transform$1, untransform, unknown$1, clamp = identity$4, piecewise$1, output, input;
	function rescale() {
		var n$1 = Math.min(domain.length, range$5.length);
		if (clamp !== identity$4) clamp = clamper(domain[0], domain[n$1 - 1]);
		piecewise$1 = n$1 > 2 ? polymap : bimap;
		output = input = null;
		return scale;
	}
	function scale(x$1) {
		return x$1 == null || isNaN(x$1 = +x$1) ? unknown$1 : (output || (output = piecewise$1(domain.map(transform$1), range$5, interpolate)))(transform$1(clamp(x$1)));
	}
	scale.invert = function(y$1) {
		return clamp(untransform((input || (input = piecewise$1(range$5, domain.map(transform$1), number_default)))(y$1)));
	};
	scale.domain = function(_) {
		return arguments.length ? (domain = Array.from(_, number$1), rescale()) : domain.slice();
	};
	scale.range = function(_) {
		return arguments.length ? (range$5 = Array.from(_), rescale()) : range$5.slice();
	};
	scale.rangeRound = function(_) {
		return range$5 = Array.from(_), interpolate = round_default, rescale();
	};
	scale.clamp = function(_) {
		return arguments.length ? (clamp = _ ? true : identity$4, rescale()) : clamp !== identity$4;
	};
	scale.interpolate = function(_) {
		return arguments.length ? (interpolate = _, rescale()) : interpolate;
	};
	scale.unknown = function(_) {
		return arguments.length ? (unknown$1 = _, scale) : unknown$1;
	};
	return function(t$1, u) {
		transform$1 = t$1, untransform = u;
		return rescale();
	};
}
function continuous() {
	return transformer$2()(identity$4, identity$4);
}
function formatDecimal_default(x$1) {
	return Math.abs(x$1 = Math.round(x$1)) >= 1e21 ? x$1.toLocaleString("en").replace(/,/g, "") : x$1.toString(10);
}
function formatDecimalParts(x$1, p) {
	if ((i$2 = (x$1 = p ? x$1.toExponential(p - 1) : x$1.toExponential()).indexOf("e")) < 0) return null;
	var i$2, coefficient = x$1.slice(0, i$2);
	return [coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient, +x$1.slice(i$2 + 1)];
}
function exponent_default(x$1) {
	return x$1 = formatDecimalParts(Math.abs(x$1)), x$1 ? x$1[1] : NaN;
}
function formatGroup_default(grouping, thousands) {
	return function(value, width) {
		var i$2 = value.length, t$1 = [], j = 0, g = grouping[0], length = 0;
		while (i$2 > 0 && g > 0) {
			if (length + g + 1 > width) g = Math.max(1, width - length);
			t$1.push(value.substring(i$2 -= g, i$2 + g));
			if ((length += g + 1) > width) break;
			g = grouping[j = (j + 1) % grouping.length];
		}
		return t$1.reverse().join(thousands);
	};
}
function formatNumerals_default(numerals) {
	return function(value) {
		return value.replace(/[0-9]/g, function(i$2) {
			return numerals[+i$2];
		});
	};
}
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function formatSpecifier(specifier) {
	if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
	var match;
	return new FormatSpecifier({
		fill: match[1],
		align: match[2],
		sign: match[3],
		symbol: match[4],
		zero: match[5],
		width: match[6],
		comma: match[7],
		precision: match[8] && match[8].slice(1),
		trim: match[9],
		type: match[10]
	});
}
formatSpecifier.prototype = FormatSpecifier.prototype;
function FormatSpecifier(specifier) {
	this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
	this.align = specifier.align === void 0 ? ">" : specifier.align + "";
	this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
	this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
	this.zero = !!specifier.zero;
	this.width = specifier.width === void 0 ? void 0 : +specifier.width;
	this.comma = !!specifier.comma;
	this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
	this.trim = !!specifier.trim;
	this.type = specifier.type === void 0 ? "" : specifier.type + "";
}
FormatSpecifier.prototype.toString = function() {
	return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};
function formatTrim_default(s$3) {
	out: for (var n$1 = s$3.length, i$2 = 1, i0 = -1, i1; i$2 < n$1; ++i$2) switch (s$3[i$2]) {
		case ".":
			i0 = i1 = i$2;
			break;
		case "0":
			if (i0 === 0) i0 = i$2;
			i1 = i$2;
			break;
		default:
			if (!+s$3[i$2]) break out;
			if (i0 > 0) i0 = 0;
			break;
	}
	return i0 > 0 ? s$3.slice(0, i0) + s$3.slice(i1 + 1) : s$3;
}
var prefixExponent;
function formatPrefixAuto_default(x$1, p) {
	var d = formatDecimalParts(x$1, p);
	if (!d) return x$1 + "";
	var coefficient = d[0], exponent = d[1], i$2 = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1, n$1 = coefficient.length;
	return i$2 === n$1 ? coefficient : i$2 > n$1 ? coefficient + new Array(i$2 - n$1 + 1).join("0") : i$2 > 0 ? coefficient.slice(0, i$2) + "." + coefficient.slice(i$2) : "0." + new Array(1 - i$2).join("0") + formatDecimalParts(x$1, Math.max(0, p + i$2 - 1))[0];
}
function formatRounded_default(x$1, p) {
	var d = formatDecimalParts(x$1, p);
	if (!d) return x$1 + "";
	var coefficient = d[0], exponent = d[1];
	return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1) : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}
var formatTypes_default = {
	"%": (x$1, p) => (x$1 * 100).toFixed(p),
	"b": (x$1) => Math.round(x$1).toString(2),
	"c": (x$1) => x$1 + "",
	"d": formatDecimal_default,
	"e": (x$1, p) => x$1.toExponential(p),
	"f": (x$1, p) => x$1.toFixed(p),
	"g": (x$1, p) => x$1.toPrecision(p),
	"o": (x$1) => Math.round(x$1).toString(8),
	"p": (x$1, p) => formatRounded_default(x$1 * 100, p),
	"r": formatRounded_default,
	"s": formatPrefixAuto_default,
	"X": (x$1) => Math.round(x$1).toString(16).toUpperCase(),
	"x": (x$1) => Math.round(x$1).toString(16)
};
function identity_default(x$1) {
	return x$1;
}
var map$3 = Array.prototype.map, prefixes = [
	"y",
	"z",
	"a",
	"f",
	"p",
	"n",
	"",
	"m",
	"",
	"k",
	"M",
	"G",
	"T",
	"P",
	"E",
	"Z",
	"Y"
];
function locale_default(locale$2) {
	var group = locale$2.grouping === void 0 || locale$2.thousands === void 0 ? identity_default : formatGroup_default(map$3.call(locale$2.grouping, Number), locale$2.thousands + ""), currencyPrefix = locale$2.currency === void 0 ? "" : locale$2.currency[0] + "", currencySuffix = locale$2.currency === void 0 ? "" : locale$2.currency[1] + "", decimal = locale$2.decimal === void 0 ? "." : locale$2.decimal + "", numerals = locale$2.numerals === void 0 ? identity_default : formatNumerals_default(map$3.call(locale$2.numerals, String)), percent = locale$2.percent === void 0 ? "%" : locale$2.percent + "", minus = locale$2.minus === void 0 ? "" : locale$2.minus + "", nan = locale$2.nan === void 0 ? "NaN" : locale$2.nan + "";
	function newFormat(specifier) {
		specifier = formatSpecifier(specifier);
		var fill = specifier.fill, align = specifier.align, sign$1 = specifier.sign, symbol = specifier.symbol, zero$2 = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, trim = specifier.trim, type = specifier.type;
		if (type === "n") comma = true, type = "g";
		else if (!formatTypes_default[type]) precision === void 0 && (precision = 12), trim = true, type = "g";
		if (zero$2 || fill === "0" && align === "=") zero$2 = true, fill = "0", align = "=";
		var prefix$2 = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "", suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";
		var formatType = formatTypes_default[type], maybeSuffix = /[defgprs%]/.test(type);
		precision = precision === void 0 ? 6 : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
		function format$2(value) {
			var valuePrefix = prefix$2, valueSuffix = suffix, i$2, n$1, c$1;
			if (type === "c") {
				valueSuffix = formatType(value) + valueSuffix;
				value = "";
			} else {
				value = +value;
				var valueNegative = value < 0 || 1 / value < 0;
				value = isNaN(value) ? nan : formatType(Math.abs(value), precision);
				if (trim) value = formatTrim_default(value);
				if (valueNegative && +value === 0 && sign$1 !== "+") valueNegative = false;
				valuePrefix = (valueNegative ? sign$1 === "(" ? sign$1 : minus : sign$1 === "-" || sign$1 === "(" ? "" : sign$1) + valuePrefix;
				valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign$1 === "(" ? ")" : "");
				if (maybeSuffix) {
					i$2 = -1, n$1 = value.length;
					while (++i$2 < n$1) if (c$1 = value.charCodeAt(i$2), 48 > c$1 || c$1 > 57) {
						valueSuffix = (c$1 === 46 ? decimal + value.slice(i$2 + 1) : value.slice(i$2)) + valueSuffix;
						value = value.slice(0, i$2);
						break;
					}
				}
			}
			if (comma && !zero$2) value = group(value, Infinity);
			var length = valuePrefix.length + value.length + valueSuffix.length, padding = length < width ? new Array(width - length + 1).join(fill) : "";
			if (comma && zero$2) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";
			switch (align) {
				case "<":
					value = valuePrefix + value + valueSuffix + padding;
					break;
				case "=":
					value = valuePrefix + padding + value + valueSuffix;
					break;
				case "^":
					value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);
					break;
				default:
					value = padding + valuePrefix + value + valueSuffix;
					break;
			}
			return numerals(value);
		}
		format$2.toString = function() {
			return specifier + "";
		};
		return format$2;
	}
	function formatPrefix$1(specifier, value) {
		var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e = Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3, k$1 = Math.pow(10, -e), prefix$2 = prefixes[8 + e / 3];
		return function(value$1) {
			return f(k$1 * value$1) + prefix$2;
		};
	}
	return {
		format: newFormat,
		formatPrefix: formatPrefix$1
	};
}
var locale$1;
var format$1;
var formatPrefix;
defaultLocale$1({
	thousands: ",",
	grouping: [3],
	currency: ["$", ""]
});
function defaultLocale$1(definition) {
	locale$1 = locale_default(definition);
	format$1 = locale$1.format;
	formatPrefix = locale$1.formatPrefix;
	return locale$1;
}
function precisionFixed_default(step) {
	return Math.max(0, -exponent_default(Math.abs(step)));
}
function precisionPrefix_default(step, value) {
	return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3 - exponent_default(Math.abs(step)));
}
function precisionRound_default(step, max$4) {
	step = Math.abs(step), max$4 = Math.abs(max$4) - step;
	return Math.max(0, exponent_default(max$4) - exponent_default(step)) + 1;
}
function tickFormat(start, stop, count, specifier) {
	var step = tickStep(start, stop, count), precision;
	specifier = formatSpecifier(specifier == null ? ",f" : specifier);
	switch (specifier.type) {
		case "s":
			var value = Math.max(Math.abs(start), Math.abs(stop));
			if (specifier.precision == null && !isNaN(precision = precisionPrefix_default(step, value))) specifier.precision = precision;
			return formatPrefix(specifier, value);
		case "":
		case "e":
		case "g":
		case "p":
		case "r":
			if (specifier.precision == null && !isNaN(precision = precisionRound_default(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
			break;
		case "f":
		case "%":
			if (specifier.precision == null && !isNaN(precision = precisionFixed_default(step))) specifier.precision = precision - (specifier.type === "%") * 2;
			break;
	}
	return format$1(specifier);
}
function linearish(scale) {
	var domain = scale.domain;
	scale.ticks = function(count) {
		var d = domain();
		return ticks(d[0], d[d.length - 1], count == null ? 10 : count);
	};
	scale.tickFormat = function(count, specifier) {
		var d = domain();
		return tickFormat(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
	};
	scale.nice = function(count) {
		if (count == null) count = 10;
		var d = domain();
		var i0 = 0;
		var i1 = d.length - 1;
		var start = d[i0];
		var stop = d[i1];
		var prestep;
		var step;
		var maxIter = 10;
		if (stop < start) {
			step = start, start = stop, stop = step;
			step = i0, i0 = i1, i1 = step;
		}
		while (maxIter-- > 0) {
			step = tickIncrement(start, stop, count);
			if (step === prestep) {
				d[i0] = start;
				d[i1] = stop;
				return domain(d);
			} else if (step > 0) {
				start = Math.floor(start / step) * step;
				stop = Math.ceil(stop / step) * step;
			} else if (step < 0) {
				start = Math.ceil(start * step) / step;
				stop = Math.floor(stop * step) / step;
			} else break;
			prestep = step;
		}
		return scale;
	};
	return scale;
}
function linear() {
	var scale = continuous();
	scale.copy = function() {
		return copy$1(scale, linear());
	};
	initRange.apply(scale, arguments);
	return linearish(scale);
}
function identity$5(domain) {
	var unknown$1;
	function scale(x$1) {
		return x$1 == null || isNaN(x$1 = +x$1) ? unknown$1 : x$1;
	}
	scale.invert = scale;
	scale.domain = scale.range = function(_) {
		return arguments.length ? (domain = Array.from(_, number$1), scale) : domain.slice();
	};
	scale.unknown = function(_) {
		return arguments.length ? (unknown$1 = _, scale) : unknown$1;
	};
	scale.copy = function() {
		return identity$5(domain).unknown(unknown$1);
	};
	domain = arguments.length ? Array.from(domain, number$1) : [0, 1];
	return linearish(scale);
}
function nice(domain, interval) {
	domain = domain.slice();
	var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], t$1;
	if (x1 < x0) {
		t$1 = i0, i0 = i1, i1 = t$1;
		t$1 = x0, x0 = x1, x1 = t$1;
	}
	domain[i0] = interval.floor(x0);
	domain[i1] = interval.ceil(x1);
	return domain;
}
function transformLog(x$1) {
	return Math.log(x$1);
}
function transformExp(x$1) {
	return Math.exp(x$1);
}
function transformLogn(x$1) {
	return -Math.log(-x$1);
}
function transformExpn(x$1) {
	return -Math.exp(-x$1);
}
function pow10(x$1) {
	return isFinite(x$1) ? +("1e" + x$1) : x$1 < 0 ? 0 : x$1;
}
function powp(base) {
	return base === 10 ? pow10 : base === Math.E ? Math.exp : (x$1) => Math.pow(base, x$1);
}
function logp(base) {
	return base === Math.E ? Math.log : base === 10 && Math.log10 || base === 2 && Math.log2 || (base = Math.log(base), (x$1) => Math.log(x$1) / base);
}
function reflect(f) {
	return (x$1, k$1) => -f(-x$1, k$1);
}
function loggish(transform$1) {
	const scale = transform$1(transformLog, transformExp);
	const domain = scale.domain;
	let base = 10;
	let logs;
	let pows;
	function rescale() {
		logs = logp(base), pows = powp(base);
		if (domain()[0] < 0) {
			logs = reflect(logs), pows = reflect(pows);
			transform$1(transformLogn, transformExpn);
		} else transform$1(transformLog, transformExp);
		return scale;
	}
	scale.base = function(_) {
		return arguments.length ? (base = +_, rescale()) : base;
	};
	scale.domain = function(_) {
		return arguments.length ? (domain(_), rescale()) : domain();
	};
	scale.ticks = (count) => {
		const d = domain();
		let u = d[0];
		let v = d[d.length - 1];
		const r$1 = v < u;
		if (r$1) [u, v] = [v, u];
		let i$2 = logs(u);
		let j = logs(v);
		let k$1;
		let t$1;
		const n$1 = count == null ? 10 : +count;
		let z = [];
		if (!(base % 1) && j - i$2 < n$1) {
			i$2 = Math.floor(i$2), j = Math.ceil(j);
			if (u > 0) for (; i$2 <= j; ++i$2) for (k$1 = 1; k$1 < base; ++k$1) {
				t$1 = i$2 < 0 ? k$1 / pows(-i$2) : k$1 * pows(i$2);
				if (t$1 < u) continue;
				if (t$1 > v) break;
				z.push(t$1);
			}
			else for (; i$2 <= j; ++i$2) for (k$1 = base - 1; k$1 >= 1; --k$1) {
				t$1 = i$2 > 0 ? k$1 / pows(-i$2) : k$1 * pows(i$2);
				if (t$1 < u) continue;
				if (t$1 > v) break;
				z.push(t$1);
			}
			if (z.length * 2 < n$1) z = ticks(u, v, n$1);
		} else z = ticks(i$2, j, Math.min(j - i$2, n$1)).map(pows);
		return r$1 ? z.reverse() : z;
	};
	scale.tickFormat = (count, specifier) => {
		if (count == null) count = 10;
		if (specifier == null) specifier = base === 10 ? "s" : ",";
		if (typeof specifier !== "function") {
			if (!(base % 1) && (specifier = formatSpecifier(specifier)).precision == null) specifier.trim = true;
			specifier = format$1(specifier);
		}
		if (count === Infinity) return specifier;
		const k$1 = Math.max(1, base * count / scale.ticks().length);
		return (d) => {
			let i$2 = d / pows(Math.round(logs(d)));
			if (i$2 * base < base - .5) i$2 *= base;
			return i$2 <= k$1 ? specifier(d) : "";
		};
	};
	scale.nice = () => {
		return domain(nice(domain(), {
			floor: (x$1) => pows(Math.floor(logs(x$1))),
			ceil: (x$1) => pows(Math.ceil(logs(x$1)))
		}));
	};
	return scale;
}
function log() {
	const scale = loggish(transformer$2()).domain([1, 10]);
	scale.copy = () => copy$1(scale, log()).base(scale.base());
	initRange.apply(scale, arguments);
	return scale;
}
function transformSymlog(c$1) {
	return function(x$1) {
		return Math.sign(x$1) * Math.log1p(Math.abs(x$1 / c$1));
	};
}
function transformSymexp(c$1) {
	return function(x$1) {
		return Math.sign(x$1) * Math.expm1(Math.abs(x$1)) * c$1;
	};
}
function symlogish(transform$1) {
	var c$1 = 1, scale = transform$1(transformSymlog(c$1), transformSymexp(c$1));
	scale.constant = function(_) {
		return arguments.length ? transform$1(transformSymlog(c$1 = +_), transformSymexp(c$1)) : c$1;
	};
	return linearish(scale);
}
function symlog() {
	var scale = symlogish(transformer$2());
	scale.copy = function() {
		return copy$1(scale, symlog()).constant(scale.constant());
	};
	return initRange.apply(scale, arguments);
}
function transformPow(exponent) {
	return function(x$1) {
		return x$1 < 0 ? -Math.pow(-x$1, exponent) : Math.pow(x$1, exponent);
	};
}
function transformSqrt(x$1) {
	return x$1 < 0 ? -Math.sqrt(-x$1) : Math.sqrt(x$1);
}
function transformSquare(x$1) {
	return x$1 < 0 ? -x$1 * x$1 : x$1 * x$1;
}
function powish(transform$1) {
	var scale = transform$1(identity$4, identity$4), exponent = 1;
	function rescale() {
		return exponent === 1 ? transform$1(identity$4, identity$4) : exponent === .5 ? transform$1(transformSqrt, transformSquare) : transform$1(transformPow(exponent), transformPow(1 / exponent));
	}
	scale.exponent = function(_) {
		return arguments.length ? (exponent = +_, rescale()) : exponent;
	};
	return linearish(scale);
}
function pow() {
	var scale = powish(transformer$2());
	scale.copy = function() {
		return copy$1(scale, pow()).exponent(scale.exponent());
	};
	initRange.apply(scale, arguments);
	return scale;
}
function sqrt() {
	return pow.apply(null, arguments).exponent(.5);
}
function square(x$1) {
	return Math.sign(x$1) * x$1 * x$1;
}
function unsquare(x$1) {
	return Math.sign(x$1) * Math.sqrt(Math.abs(x$1));
}
function radial() {
	var squared = continuous(), range$5 = [0, 1], round = false, unknown$1;
	function scale(x$1) {
		var y$1 = unsquare(squared(x$1));
		return isNaN(y$1) ? unknown$1 : round ? Math.round(y$1) : y$1;
	}
	scale.invert = function(y$1) {
		return squared.invert(square(y$1));
	};
	scale.domain = function(_) {
		return arguments.length ? (squared.domain(_), scale) : squared.domain();
	};
	scale.range = function(_) {
		return arguments.length ? (squared.range((range$5 = Array.from(_, number$1)).map(square)), scale) : range$5.slice();
	};
	scale.rangeRound = function(_) {
		return scale.range(_).round(true);
	};
	scale.round = function(_) {
		return arguments.length ? (round = !!_, scale) : round;
	};
	scale.clamp = function(_) {
		return arguments.length ? (squared.clamp(_), scale) : squared.clamp();
	};
	scale.unknown = function(_) {
		return arguments.length ? (unknown$1 = _, scale) : unknown$1;
	};
	scale.copy = function() {
		return radial(squared.domain(), range$5).round(round).clamp(squared.clamp()).unknown(unknown$1);
	};
	initRange.apply(scale, arguments);
	return linearish(scale);
}
function quantile$1() {
	var domain = [], range$5 = [], thresholds = [], unknown$1;
	function rescale() {
		var i$2 = 0, n$1 = Math.max(1, range$5.length);
		thresholds = new Array(n$1 - 1);
		while (++i$2 < n$1) thresholds[i$2 - 1] = quantileSorted(domain, i$2 / n$1);
		return scale;
	}
	function scale(x$1) {
		return x$1 == null || isNaN(x$1 = +x$1) ? unknown$1 : range$5[bisect_default(thresholds, x$1)];
	}
	scale.invertExtent = function(y$1) {
		var i$2 = range$5.indexOf(y$1);
		return i$2 < 0 ? [NaN, NaN] : [i$2 > 0 ? thresholds[i$2 - 1] : domain[0], i$2 < thresholds.length ? thresholds[i$2] : domain[domain.length - 1]];
	};
	scale.domain = function(_) {
		if (!arguments.length) return domain.slice();
		domain = [];
		for (let d of _) if (d != null && !isNaN(d = +d)) domain.push(d);
		domain.sort(ascending);
		return rescale();
	};
	scale.range = function(_) {
		return arguments.length ? (range$5 = Array.from(_), rescale()) : range$5.slice();
	};
	scale.unknown = function(_) {
		return arguments.length ? (unknown$1 = _, scale) : unknown$1;
	};
	scale.quantiles = function() {
		return thresholds.slice();
	};
	scale.copy = function() {
		return quantile$1().domain(domain).range(range$5).unknown(unknown$1);
	};
	return initRange.apply(scale, arguments);
}
function quantize() {
	var x0 = 0, x1 = 1, n$1 = 1, domain = [.5], range$5 = [0, 1], unknown$1;
	function scale(x$1) {
		return x$1 != null && x$1 <= x$1 ? range$5[bisect_default(domain, x$1, 0, n$1)] : unknown$1;
	}
	function rescale() {
		var i$2 = -1;
		domain = new Array(n$1);
		while (++i$2 < n$1) domain[i$2] = ((i$2 + 1) * x1 - (i$2 - n$1) * x0) / (n$1 + 1);
		return scale;
	}
	scale.domain = function(_) {
		return arguments.length ? ([x0, x1] = _, x0 = +x0, x1 = +x1, rescale()) : [x0, x1];
	};
	scale.range = function(_) {
		return arguments.length ? (n$1 = (range$5 = Array.from(_)).length - 1, rescale()) : range$5.slice();
	};
	scale.invertExtent = function(y$1) {
		var i$2 = range$5.indexOf(y$1);
		return i$2 < 0 ? [NaN, NaN] : i$2 < 1 ? [x0, domain[0]] : i$2 >= n$1 ? [domain[n$1 - 1], x1] : [domain[i$2 - 1], domain[i$2]];
	};
	scale.unknown = function(_) {
		return arguments.length ? (unknown$1 = _, scale) : scale;
	};
	scale.thresholds = function() {
		return domain.slice();
	};
	scale.copy = function() {
		return quantize().domain([x0, x1]).range(range$5).unknown(unknown$1);
	};
	return initRange.apply(linearish(scale), arguments);
}
function threshold() {
	var domain = [.5], range$5 = [0, 1], unknown$1, n$1 = 1;
	function scale(x$1) {
		return x$1 != null && x$1 <= x$1 ? range$5[bisect_default(domain, x$1, 0, n$1)] : unknown$1;
	}
	scale.domain = function(_) {
		return arguments.length ? (domain = Array.from(_), n$1 = Math.min(domain.length, range$5.length - 1), scale) : domain.slice();
	};
	scale.range = function(_) {
		return arguments.length ? (range$5 = Array.from(_), n$1 = Math.min(domain.length, range$5.length - 1), scale) : range$5.slice();
	};
	scale.invertExtent = function(y$1) {
		var i$2 = range$5.indexOf(y$1);
		return [domain[i$2 - 1], domain[i$2]];
	};
	scale.unknown = function(_) {
		return arguments.length ? (unknown$1 = _, scale) : unknown$1;
	};
	scale.copy = function() {
		return threshold().domain(domain).range(range$5).unknown(unknown$1);
	};
	return initRange.apply(scale, arguments);
}
var t0 = /* @__PURE__ */ new Date(), t1 = /* @__PURE__ */ new Date();
function timeInterval(floori, offseti, count, field) {
	function interval(date$4) {
		return floori(date$4 = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+date$4)), date$4;
	}
	interval.floor = (date$4) => {
		return floori(date$4 = /* @__PURE__ */ new Date(+date$4)), date$4;
	};
	interval.ceil = (date$4) => {
		return floori(date$4 = /* @__PURE__ */ new Date(date$4 - 1)), offseti(date$4, 1), floori(date$4), date$4;
	};
	interval.round = (date$4) => {
		const d0 = interval(date$4), d1 = interval.ceil(date$4);
		return date$4 - d0 < d1 - date$4 ? d0 : d1;
	};
	interval.offset = (date$4, step) => {
		return offseti(date$4 = /* @__PURE__ */ new Date(+date$4), step == null ? 1 : Math.floor(step)), date$4;
	};
	interval.range = (start, stop, step) => {
		const range$5 = [];
		start = interval.ceil(start);
		step = step == null ? 1 : Math.floor(step);
		if (!(start < stop) || !(step > 0)) return range$5;
		let previous;
		do
			range$5.push(previous = /* @__PURE__ */ new Date(+start)), offseti(start, step), floori(start);
		while (previous < start && start < stop);
		return range$5;
	};
	interval.filter = (test) => {
		return timeInterval((date$4) => {
			if (date$4 >= date$4) while (floori(date$4), !test(date$4)) date$4.setTime(date$4 - 1);
		}, (date$4, step) => {
			if (date$4 >= date$4) if (step < 0) while (++step <= 0) while (offseti(date$4, -1), !test(date$4));
			else while (--step >= 0) while (offseti(date$4, 1), !test(date$4));
		});
	};
	if (count) {
		interval.count = (start, end) => {
			t0.setTime(+start), t1.setTime(+end);
			floori(t0), floori(t1);
			return Math.floor(count(t0, t1));
		};
		interval.every = (step) => {
			step = Math.floor(step);
			return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval : interval.filter(field ? (d) => field(d) % step === 0 : (d) => interval.count(0, d) % step === 0);
		};
	}
	return interval;
}
const millisecond = timeInterval(() => {}, (date$4, step) => {
	date$4.setTime(+date$4 + step);
}, (start, end) => {
	return end - start;
});
millisecond.every = (k$1) => {
	k$1 = Math.floor(k$1);
	if (!isFinite(k$1) || !(k$1 > 0)) return null;
	if (!(k$1 > 1)) return millisecond;
	return timeInterval((date$4) => {
		date$4.setTime(Math.floor(date$4 / k$1) * k$1);
	}, (date$4, step) => {
		date$4.setTime(+date$4 + step * k$1);
	}, (start, end) => {
		return (end - start) / k$1;
	});
};
millisecond.range;
const durationSecond = 1e3;
const durationMinute = durationSecond * 60;
const durationHour = durationMinute * 60;
const durationDay = durationHour * 24;
const durationWeek = durationDay * 7;
const durationMonth = durationDay * 30;
const durationYear = durationDay * 365;
const second = timeInterval((date$4) => {
	date$4.setTime(date$4 - date$4.getMilliseconds());
}, (date$4, step) => {
	date$4.setTime(+date$4 + step * durationSecond);
}, (start, end) => {
	return (end - start) / durationSecond;
}, (date$4) => {
	return date$4.getUTCSeconds();
});
second.range;
const timeMinute = timeInterval((date$4) => {
	date$4.setTime(date$4 - date$4.getMilliseconds() - date$4.getSeconds() * durationSecond);
}, (date$4, step) => {
	date$4.setTime(+date$4 + step * durationMinute);
}, (start, end) => {
	return (end - start) / durationMinute;
}, (date$4) => {
	return date$4.getMinutes();
});
timeMinute.range;
const utcMinute = timeInterval((date$4) => {
	date$4.setUTCSeconds(0, 0);
}, (date$4, step) => {
	date$4.setTime(+date$4 + step * durationMinute);
}, (start, end) => {
	return (end - start) / durationMinute;
}, (date$4) => {
	return date$4.getUTCMinutes();
});
utcMinute.range;
const timeHour = timeInterval((date$4) => {
	date$4.setTime(date$4 - date$4.getMilliseconds() - date$4.getSeconds() * durationSecond - date$4.getMinutes() * durationMinute);
}, (date$4, step) => {
	date$4.setTime(+date$4 + step * durationHour);
}, (start, end) => {
	return (end - start) / durationHour;
}, (date$4) => {
	return date$4.getHours();
});
timeHour.range;
const utcHour = timeInterval((date$4) => {
	date$4.setUTCMinutes(0, 0, 0);
}, (date$4, step) => {
	date$4.setTime(+date$4 + step * durationHour);
}, (start, end) => {
	return (end - start) / durationHour;
}, (date$4) => {
	return date$4.getUTCHours();
});
utcHour.range;
const timeDay = timeInterval((date$4) => date$4.setHours(0, 0, 0, 0), (date$4, step) => date$4.setDate(date$4.getDate() + step), (start, end) => (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay, (date$4) => date$4.getDate() - 1);
timeDay.range;
const utcDay = timeInterval((date$4) => {
	date$4.setUTCHours(0, 0, 0, 0);
}, (date$4, step) => {
	date$4.setUTCDate(date$4.getUTCDate() + step);
}, (start, end) => {
	return (end - start) / durationDay;
}, (date$4) => {
	return date$4.getUTCDate() - 1;
});
utcDay.range;
const unixDay = timeInterval((date$4) => {
	date$4.setUTCHours(0, 0, 0, 0);
}, (date$4, step) => {
	date$4.setUTCDate(date$4.getUTCDate() + step);
}, (start, end) => {
	return (end - start) / durationDay;
}, (date$4) => {
	return Math.floor(date$4 / durationDay);
});
unixDay.range;
function timeWeekday(i$2) {
	return timeInterval((date$4) => {
		date$4.setDate(date$4.getDate() - (date$4.getDay() + 7 - i$2) % 7);
		date$4.setHours(0, 0, 0, 0);
	}, (date$4, step) => {
		date$4.setDate(date$4.getDate() + step * 7);
	}, (start, end) => {
		return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
	});
}
const timeSunday = timeWeekday(0);
const timeMonday = timeWeekday(1);
const timeTuesday = timeWeekday(2);
const timeWednesday = timeWeekday(3);
const timeThursday = timeWeekday(4);
const timeFriday = timeWeekday(5);
const timeSaturday = timeWeekday(6);
timeSunday.range;
timeMonday.range;
timeTuesday.range;
timeWednesday.range;
timeThursday.range;
timeFriday.range;
timeSaturday.range;
function utcWeekday(i$2) {
	return timeInterval((date$4) => {
		date$4.setUTCDate(date$4.getUTCDate() - (date$4.getUTCDay() + 7 - i$2) % 7);
		date$4.setUTCHours(0, 0, 0, 0);
	}, (date$4, step) => {
		date$4.setUTCDate(date$4.getUTCDate() + step * 7);
	}, (start, end) => {
		return (end - start) / durationWeek;
	});
}
const utcSunday = utcWeekday(0);
const utcMonday = utcWeekday(1);
const utcTuesday = utcWeekday(2);
const utcWednesday = utcWeekday(3);
const utcThursday = utcWeekday(4);
const utcFriday = utcWeekday(5);
const utcSaturday = utcWeekday(6);
utcSunday.range;
utcMonday.range;
utcTuesday.range;
utcWednesday.range;
utcThursday.range;
utcFriday.range;
utcSaturday.range;
const timeMonth = timeInterval((date$4) => {
	date$4.setDate(1);
	date$4.setHours(0, 0, 0, 0);
}, (date$4, step) => {
	date$4.setMonth(date$4.getMonth() + step);
}, (start, end) => {
	return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
}, (date$4) => {
	return date$4.getMonth();
});
timeMonth.range;
const utcMonth = timeInterval((date$4) => {
	date$4.setUTCDate(1);
	date$4.setUTCHours(0, 0, 0, 0);
}, (date$4, step) => {
	date$4.setUTCMonth(date$4.getUTCMonth() + step);
}, (start, end) => {
	return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
}, (date$4) => {
	return date$4.getUTCMonth();
});
utcMonth.range;
const timeYear = timeInterval((date$4) => {
	date$4.setMonth(0, 1);
	date$4.setHours(0, 0, 0, 0);
}, (date$4, step) => {
	date$4.setFullYear(date$4.getFullYear() + step);
}, (start, end) => {
	return end.getFullYear() - start.getFullYear();
}, (date$4) => {
	return date$4.getFullYear();
});
timeYear.every = (k$1) => {
	return !isFinite(k$1 = Math.floor(k$1)) || !(k$1 > 0) ? null : timeInterval((date$4) => {
		date$4.setFullYear(Math.floor(date$4.getFullYear() / k$1) * k$1);
		date$4.setMonth(0, 1);
		date$4.setHours(0, 0, 0, 0);
	}, (date$4, step) => {
		date$4.setFullYear(date$4.getFullYear() + step * k$1);
	});
};
timeYear.range;
const utcYear = timeInterval((date$4) => {
	date$4.setUTCMonth(0, 1);
	date$4.setUTCHours(0, 0, 0, 0);
}, (date$4, step) => {
	date$4.setUTCFullYear(date$4.getUTCFullYear() + step);
}, (start, end) => {
	return end.getUTCFullYear() - start.getUTCFullYear();
}, (date$4) => {
	return date$4.getUTCFullYear();
});
utcYear.every = (k$1) => {
	return !isFinite(k$1 = Math.floor(k$1)) || !(k$1 > 0) ? null : timeInterval((date$4) => {
		date$4.setUTCFullYear(Math.floor(date$4.getUTCFullYear() / k$1) * k$1);
		date$4.setUTCMonth(0, 1);
		date$4.setUTCHours(0, 0, 0, 0);
	}, (date$4, step) => {
		date$4.setUTCFullYear(date$4.getUTCFullYear() + step * k$1);
	});
};
utcYear.range;
function ticker(year, month, week, day, hour, minute) {
	const tickIntervals = [
		[
			second,
			1,
			durationSecond
		],
		[
			second,
			5,
			5 * durationSecond
		],
		[
			second,
			15,
			15 * durationSecond
		],
		[
			second,
			30,
			30 * durationSecond
		],
		[
			minute,
			1,
			durationMinute
		],
		[
			minute,
			5,
			5 * durationMinute
		],
		[
			minute,
			15,
			15 * durationMinute
		],
		[
			minute,
			30,
			30 * durationMinute
		],
		[
			hour,
			1,
			durationHour
		],
		[
			hour,
			3,
			3 * durationHour
		],
		[
			hour,
			6,
			6 * durationHour
		],
		[
			hour,
			12,
			12 * durationHour
		],
		[
			day,
			1,
			durationDay
		],
		[
			day,
			2,
			2 * durationDay
		],
		[
			week,
			1,
			durationWeek
		],
		[
			month,
			1,
			durationMonth
		],
		[
			month,
			3,
			3 * durationMonth
		],
		[
			year,
			1,
			durationYear
		]
	];
	function ticks$1(start, stop, count) {
		const reverse$1 = stop < start;
		if (reverse$1) [start, stop] = [stop, start];
		const interval = count && typeof count.range === "function" ? count : tickInterval(start, stop, count);
		const ticks$2 = interval ? interval.range(start, +stop + 1) : [];
		return reverse$1 ? ticks$2.reverse() : ticks$2;
	}
	function tickInterval(start, stop, count) {
		const target = Math.abs(stop - start) / count;
		const i$2 = bisector(([, , step$1]) => step$1).right(tickIntervals, target);
		if (i$2 === tickIntervals.length) return year.every(tickStep(start / durationYear, stop / durationYear, count));
		if (i$2 === 0) return millisecond.every(Math.max(tickStep(start, stop, count), 1));
		const [t$1, step] = tickIntervals[target / tickIntervals[i$2 - 1][2] < tickIntervals[i$2][2] / target ? i$2 - 1 : i$2];
		return t$1.every(step);
	}
	return [ticks$1, tickInterval];
}
var [utcTicks, utcTickInterval] = ticker(utcYear, utcMonth, utcSunday, unixDay, utcHour, utcMinute);
var [timeTicks, timeTickInterval] = ticker(timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute);
function localDate(d) {
	if (0 <= d.y && d.y < 100) {
		var date$4 = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
		date$4.setFullYear(d.y);
		return date$4;
	}
	return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}
function utcDate(d) {
	if (0 <= d.y && d.y < 100) {
		var date$4 = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
		date$4.setUTCFullYear(d.y);
		return date$4;
	}
	return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}
function newDate(y$1, m, d) {
	return {
		y: y$1,
		m,
		d,
		H: 0,
		M: 0,
		S: 0,
		L: 0
	};
}
function formatLocale(locale$2) {
	var locale_dateTime = locale$2.dateTime, locale_date = locale$2.date, locale_time = locale$2.time, locale_periods = locale$2.periods, locale_weekdays = locale$2.days, locale_shortWeekdays = locale$2.shortDays, locale_months = locale$2.months, locale_shortMonths = locale$2.shortMonths;
	var periodRe = formatRe(locale_periods), periodLookup = formatLookup(locale_periods), weekdayRe = formatRe(locale_weekdays), weekdayLookup = formatLookup(locale_weekdays), shortWeekdayRe = formatRe(locale_shortWeekdays), shortWeekdayLookup = formatLookup(locale_shortWeekdays), monthRe = formatRe(locale_months), monthLookup = formatLookup(locale_months), shortMonthRe = formatRe(locale_shortMonths), shortMonthLookup = formatLookup(locale_shortMonths);
	var formats = {
		"a": formatShortWeekday,
		"A": formatWeekday,
		"b": formatShortMonth,
		"B": formatMonth,
		"c": null,
		"d": formatDayOfMonth,
		"e": formatDayOfMonth,
		"f": formatMicroseconds,
		"g": formatYearISO,
		"G": formatFullYearISO,
		"H": formatHour24,
		"I": formatHour12,
		"j": formatDayOfYear,
		"L": formatMilliseconds,
		"m": formatMonthNumber,
		"M": formatMinutes,
		"p": formatPeriod,
		"q": formatQuarter,
		"Q": formatUnixTimestamp,
		"s": formatUnixTimestampSeconds,
		"S": formatSeconds,
		"u": formatWeekdayNumberMonday,
		"U": formatWeekNumberSunday,
		"V": formatWeekNumberISO,
		"w": formatWeekdayNumberSunday,
		"W": formatWeekNumberMonday,
		"x": null,
		"X": null,
		"y": formatYear,
		"Y": formatFullYear,
		"Z": formatZone,
		"%": formatLiteralPercent
	};
	var utcFormats = {
		"a": formatUTCShortWeekday,
		"A": formatUTCWeekday,
		"b": formatUTCShortMonth,
		"B": formatUTCMonth,
		"c": null,
		"d": formatUTCDayOfMonth,
		"e": formatUTCDayOfMonth,
		"f": formatUTCMicroseconds,
		"g": formatUTCYearISO,
		"G": formatUTCFullYearISO,
		"H": formatUTCHour24,
		"I": formatUTCHour12,
		"j": formatUTCDayOfYear,
		"L": formatUTCMilliseconds,
		"m": formatUTCMonthNumber,
		"M": formatUTCMinutes,
		"p": formatUTCPeriod,
		"q": formatUTCQuarter,
		"Q": formatUnixTimestamp,
		"s": formatUnixTimestampSeconds,
		"S": formatUTCSeconds,
		"u": formatUTCWeekdayNumberMonday,
		"U": formatUTCWeekNumberSunday,
		"V": formatUTCWeekNumberISO,
		"w": formatUTCWeekdayNumberSunday,
		"W": formatUTCWeekNumberMonday,
		"x": null,
		"X": null,
		"y": formatUTCYear,
		"Y": formatUTCFullYear,
		"Z": formatUTCZone,
		"%": formatLiteralPercent
	};
	var parses = {
		"a": parseShortWeekday,
		"A": parseWeekday,
		"b": parseShortMonth,
		"B": parseMonth,
		"c": parseLocaleDateTime,
		"d": parseDayOfMonth,
		"e": parseDayOfMonth,
		"f": parseMicroseconds,
		"g": parseYear,
		"G": parseFullYear,
		"H": parseHour24,
		"I": parseHour24,
		"j": parseDayOfYear,
		"L": parseMilliseconds,
		"m": parseMonthNumber,
		"M": parseMinutes,
		"p": parsePeriod,
		"q": parseQuarter,
		"Q": parseUnixTimestamp,
		"s": parseUnixTimestampSeconds,
		"S": parseSeconds,
		"u": parseWeekdayNumberMonday,
		"U": parseWeekNumberSunday,
		"V": parseWeekNumberISO,
		"w": parseWeekdayNumberSunday,
		"W": parseWeekNumberMonday,
		"x": parseLocaleDate,
		"X": parseLocaleTime,
		"y": parseYear,
		"Y": parseFullYear,
		"Z": parseZone,
		"%": parseLiteralPercent
	};
	formats.x = newFormat(locale_date, formats);
	formats.X = newFormat(locale_time, formats);
	formats.c = newFormat(locale_dateTime, formats);
	utcFormats.x = newFormat(locale_date, utcFormats);
	utcFormats.X = newFormat(locale_time, utcFormats);
	utcFormats.c = newFormat(locale_dateTime, utcFormats);
	function newFormat(specifier, formats$1) {
		return function(date$4) {
			var string$2 = [], i$2 = -1, j = 0, n$1 = specifier.length, c$1, pad$1, format$2;
			if (!(date$4 instanceof Date)) date$4 = /* @__PURE__ */ new Date(+date$4);
			while (++i$2 < n$1) if (specifier.charCodeAt(i$2) === 37) {
				string$2.push(specifier.slice(j, i$2));
				if ((pad$1 = pads[c$1 = specifier.charAt(++i$2)]) != null) c$1 = specifier.charAt(++i$2);
				else pad$1 = c$1 === "e" ? " " : "0";
				if (format$2 = formats$1[c$1]) c$1 = format$2(date$4, pad$1);
				string$2.push(c$1);
				j = i$2 + 1;
			}
			string$2.push(specifier.slice(j, i$2));
			return string$2.join("");
		};
	}
	function newParse(specifier, Z) {
		return function(string$2) {
			var d = newDate(1900, void 0, 1), i$2 = parseSpecifier(d, specifier, string$2 += "", 0), week, day;
			if (i$2 != string$2.length) return null;
			if ("Q" in d) return new Date(d.Q);
			if ("s" in d) return new Date(d.s * 1e3 + ("L" in d ? d.L : 0));
			if (Z && !("Z" in d)) d.Z = 0;
			if ("p" in d) d.H = d.H % 12 + d.p * 12;
			if (d.m === void 0) d.m = "q" in d ? d.q : 0;
			if ("V" in d) {
				if (d.V < 1 || d.V > 53) return null;
				if (!("w" in d)) d.w = 1;
				if ("Z" in d) {
					week = utcDate(newDate(d.y, 0, 1)), day = week.getUTCDay();
					week = day > 4 || day === 0 ? utcMonday.ceil(week) : utcMonday(week);
					week = utcDay.offset(week, (d.V - 1) * 7);
					d.y = week.getUTCFullYear();
					d.m = week.getUTCMonth();
					d.d = week.getUTCDate() + (d.w + 6) % 7;
				} else {
					week = localDate(newDate(d.y, 0, 1)), day = week.getDay();
					week = day > 4 || day === 0 ? timeMonday.ceil(week) : timeMonday(week);
					week = timeDay.offset(week, (d.V - 1) * 7);
					d.y = week.getFullYear();
					d.m = week.getMonth();
					d.d = week.getDate() + (d.w + 6) % 7;
				}
			} else if ("W" in d || "U" in d) {
				if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
				day = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
				d.m = 0;
				d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
			}
			if ("Z" in d) {
				d.H += d.Z / 100 | 0;
				d.M += d.Z % 100;
				return utcDate(d);
			}
			return localDate(d);
		};
	}
	function parseSpecifier(d, specifier, string$2, j) {
		var i$2 = 0, n$1 = specifier.length, m = string$2.length, c$1, parse$2;
		while (i$2 < n$1) {
			if (j >= m) return -1;
			c$1 = specifier.charCodeAt(i$2++);
			if (c$1 === 37) {
				c$1 = specifier.charAt(i$2++);
				parse$2 = parses[c$1 in pads ? specifier.charAt(i$2++) : c$1];
				if (!parse$2 || (j = parse$2(d, string$2, j)) < 0) return -1;
			} else if (c$1 != string$2.charCodeAt(j++)) return -1;
		}
		return j;
	}
	function parsePeriod(d, string$2, i$2) {
		var n$1 = periodRe.exec(string$2.slice(i$2));
		return n$1 ? (d.p = periodLookup.get(n$1[0].toLowerCase()), i$2 + n$1[0].length) : -1;
	}
	function parseShortWeekday(d, string$2, i$2) {
		var n$1 = shortWeekdayRe.exec(string$2.slice(i$2));
		return n$1 ? (d.w = shortWeekdayLookup.get(n$1[0].toLowerCase()), i$2 + n$1[0].length) : -1;
	}
	function parseWeekday(d, string$2, i$2) {
		var n$1 = weekdayRe.exec(string$2.slice(i$2));
		return n$1 ? (d.w = weekdayLookup.get(n$1[0].toLowerCase()), i$2 + n$1[0].length) : -1;
	}
	function parseShortMonth(d, string$2, i$2) {
		var n$1 = shortMonthRe.exec(string$2.slice(i$2));
		return n$1 ? (d.m = shortMonthLookup.get(n$1[0].toLowerCase()), i$2 + n$1[0].length) : -1;
	}
	function parseMonth(d, string$2, i$2) {
		var n$1 = monthRe.exec(string$2.slice(i$2));
		return n$1 ? (d.m = monthLookup.get(n$1[0].toLowerCase()), i$2 + n$1[0].length) : -1;
	}
	function parseLocaleDateTime(d, string$2, i$2) {
		return parseSpecifier(d, locale_dateTime, string$2, i$2);
	}
	function parseLocaleDate(d, string$2, i$2) {
		return parseSpecifier(d, locale_date, string$2, i$2);
	}
	function parseLocaleTime(d, string$2, i$2) {
		return parseSpecifier(d, locale_time, string$2, i$2);
	}
	function formatShortWeekday(d) {
		return locale_shortWeekdays[d.getDay()];
	}
	function formatWeekday(d) {
		return locale_weekdays[d.getDay()];
	}
	function formatShortMonth(d) {
		return locale_shortMonths[d.getMonth()];
	}
	function formatMonth(d) {
		return locale_months[d.getMonth()];
	}
	function formatPeriod(d) {
		return locale_periods[+(d.getHours() >= 12)];
	}
	function formatQuarter(d) {
		return 1 + ~~(d.getMonth() / 3);
	}
	function formatUTCShortWeekday(d) {
		return locale_shortWeekdays[d.getUTCDay()];
	}
	function formatUTCWeekday(d) {
		return locale_weekdays[d.getUTCDay()];
	}
	function formatUTCShortMonth(d) {
		return locale_shortMonths[d.getUTCMonth()];
	}
	function formatUTCMonth(d) {
		return locale_months[d.getUTCMonth()];
	}
	function formatUTCPeriod(d) {
		return locale_periods[+(d.getUTCHours() >= 12)];
	}
	function formatUTCQuarter(d) {
		return 1 + ~~(d.getUTCMonth() / 3);
	}
	return {
		format: function(specifier) {
			var f = newFormat(specifier += "", formats);
			f.toString = function() {
				return specifier;
			};
			return f;
		},
		parse: function(specifier) {
			var p = newParse(specifier += "", false);
			p.toString = function() {
				return specifier;
			};
			return p;
		},
		utcFormat: function(specifier) {
			var f = newFormat(specifier += "", utcFormats);
			f.toString = function() {
				return specifier;
			};
			return f;
		},
		utcParse: function(specifier) {
			var p = newParse(specifier += "", true);
			p.toString = function() {
				return specifier;
			};
			return p;
		}
	};
}
var pads = {
	"-": "",
	"_": " ",
	"0": "0"
}, numberRe = /^\s*\d+/, percentRe = /^%/, requoteRe = /[\\^$*+?|[\]().{}]/g;
function pad(value, fill, width) {
	var sign$1 = value < 0 ? "-" : "", string$2 = (sign$1 ? -value : value) + "", length = string$2.length;
	return sign$1 + (length < width ? new Array(width - length + 1).join(fill) + string$2 : string$2);
}
function requote(s$3) {
	return s$3.replace(requoteRe, "\\$&");
}
function formatRe(names) {
	return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}
function formatLookup(names) {
	return new Map(names.map((name, i$2) => [name.toLowerCase(), i$2]));
}
function parseWeekdayNumberSunday(d, string$2, i$2) {
	var n$1 = numberRe.exec(string$2.slice(i$2, i$2 + 1));
	return n$1 ? (d.w = +n$1[0], i$2 + n$1[0].length) : -1;
}
function parseWeekdayNumberMonday(d, string$2, i$2) {
	var n$1 = numberRe.exec(string$2.slice(i$2, i$2 + 1));
	return n$1 ? (d.u = +n$1[0], i$2 + n$1[0].length) : -1;
}
function parseWeekNumberSunday(d, string$2, i$2) {
	var n$1 = numberRe.exec(string$2.slice(i$2, i$2 + 2));
	return n$1 ? (d.U = +n$1[0], i$2 + n$1[0].length) : -1;
}
function parseWeekNumberISO(d, string$2, i$2) {
	var n$1 = numberRe.exec(string$2.slice(i$2, i$2 + 2));
	return n$1 ? (d.V = +n$1[0], i$2 + n$1[0].length) : -1;
}
function parseWeekNumberMonday(d, string$2, i$2) {
	var n$1 = numberRe.exec(string$2.slice(i$2, i$2 + 2));
	return n$1 ? (d.W = +n$1[0], i$2 + n$1[0].length) : -1;
}
function parseFullYear(d, string$2, i$2) {
	var n$1 = numberRe.exec(string$2.slice(i$2, i$2 + 4));
	return n$1 ? (d.y = +n$1[0], i$2 + n$1[0].length) : -1;
}
function parseYear(d, string$2, i$2) {
	var n$1 = numberRe.exec(string$2.slice(i$2, i$2 + 2));
	return n$1 ? (d.y = +n$1[0] + (+n$1[0] > 68 ? 1900 : 2e3), i$2 + n$1[0].length) : -1;
}
function parseZone(d, string$2, i$2) {
	var n$1 = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string$2.slice(i$2, i$2 + 6));
	return n$1 ? (d.Z = n$1[1] ? 0 : -(n$1[2] + (n$1[3] || "00")), i$2 + n$1[0].length) : -1;
}
function parseQuarter(d, string$2, i$2) {
	var n$1 = numberRe.exec(string$2.slice(i$2, i$2 + 1));
	return n$1 ? (d.q = n$1[0] * 3 - 3, i$2 + n$1[0].length) : -1;
}
function parseMonthNumber(d, string$2, i$2) {
	var n$1 = numberRe.exec(string$2.slice(i$2, i$2 + 2));
	return n$1 ? (d.m = n$1[0] - 1, i$2 + n$1[0].length) : -1;
}
function parseDayOfMonth(d, string$2, i$2) {
	var n$1 = numberRe.exec(string$2.slice(i$2, i$2 + 2));
	return n$1 ? (d.d = +n$1[0], i$2 + n$1[0].length) : -1;
}
function parseDayOfYear(d, string$2, i$2) {
	var n$1 = numberRe.exec(string$2.slice(i$2, i$2 + 3));
	return n$1 ? (d.m = 0, d.d = +n$1[0], i$2 + n$1[0].length) : -1;
}
function parseHour24(d, string$2, i$2) {
	var n$1 = numberRe.exec(string$2.slice(i$2, i$2 + 2));
	return n$1 ? (d.H = +n$1[0], i$2 + n$1[0].length) : -1;
}
function parseMinutes(d, string$2, i$2) {
	var n$1 = numberRe.exec(string$2.slice(i$2, i$2 + 2));
	return n$1 ? (d.M = +n$1[0], i$2 + n$1[0].length) : -1;
}
function parseSeconds(d, string$2, i$2) {
	var n$1 = numberRe.exec(string$2.slice(i$2, i$2 + 2));
	return n$1 ? (d.S = +n$1[0], i$2 + n$1[0].length) : -1;
}
function parseMilliseconds(d, string$2, i$2) {
	var n$1 = numberRe.exec(string$2.slice(i$2, i$2 + 3));
	return n$1 ? (d.L = +n$1[0], i$2 + n$1[0].length) : -1;
}
function parseMicroseconds(d, string$2, i$2) {
	var n$1 = numberRe.exec(string$2.slice(i$2, i$2 + 6));
	return n$1 ? (d.L = Math.floor(n$1[0] / 1e3), i$2 + n$1[0].length) : -1;
}
function parseLiteralPercent(d, string$2, i$2) {
	var n$1 = percentRe.exec(string$2.slice(i$2, i$2 + 1));
	return n$1 ? i$2 + n$1[0].length : -1;
}
function parseUnixTimestamp(d, string$2, i$2) {
	var n$1 = numberRe.exec(string$2.slice(i$2));
	return n$1 ? (d.Q = +n$1[0], i$2 + n$1[0].length) : -1;
}
function parseUnixTimestampSeconds(d, string$2, i$2) {
	var n$1 = numberRe.exec(string$2.slice(i$2));
	return n$1 ? (d.s = +n$1[0], i$2 + n$1[0].length) : -1;
}
function formatDayOfMonth(d, p) {
	return pad(d.getDate(), p, 2);
}
function formatHour24(d, p) {
	return pad(d.getHours(), p, 2);
}
function formatHour12(d, p) {
	return pad(d.getHours() % 12 || 12, p, 2);
}
function formatDayOfYear(d, p) {
	return pad(1 + timeDay.count(timeYear(d), d), p, 3);
}
function formatMilliseconds(d, p) {
	return pad(d.getMilliseconds(), p, 3);
}
function formatMicroseconds(d, p) {
	return formatMilliseconds(d, p) + "000";
}
function formatMonthNumber(d, p) {
	return pad(d.getMonth() + 1, p, 2);
}
function formatMinutes(d, p) {
	return pad(d.getMinutes(), p, 2);
}
function formatSeconds(d, p) {
	return pad(d.getSeconds(), p, 2);
}
function formatWeekdayNumberMonday(d) {
	var day = d.getDay();
	return day === 0 ? 7 : day;
}
function formatWeekNumberSunday(d, p) {
	return pad(timeSunday.count(timeYear(d) - 1, d), p, 2);
}
function dISO(d) {
	var day = d.getDay();
	return day >= 4 || day === 0 ? timeThursday(d) : timeThursday.ceil(d);
}
function formatWeekNumberISO(d, p) {
	d = dISO(d);
	return pad(timeThursday.count(timeYear(d), d) + (timeYear(d).getDay() === 4), p, 2);
}
function formatWeekdayNumberSunday(d) {
	return d.getDay();
}
function formatWeekNumberMonday(d, p) {
	return pad(timeMonday.count(timeYear(d) - 1, d), p, 2);
}
function formatYear(d, p) {
	return pad(d.getFullYear() % 100, p, 2);
}
function formatYearISO(d, p) {
	d = dISO(d);
	return pad(d.getFullYear() % 100, p, 2);
}
function formatFullYear(d, p) {
	return pad(d.getFullYear() % 1e4, p, 4);
}
function formatFullYearISO(d, p) {
	var day = d.getDay();
	d = day >= 4 || day === 0 ? timeThursday(d) : timeThursday.ceil(d);
	return pad(d.getFullYear() % 1e4, p, 4);
}
function formatZone(d) {
	var z = d.getTimezoneOffset();
	return (z > 0 ? "-" : (z *= -1, "+")) + pad(z / 60 | 0, "0", 2) + pad(z % 60, "0", 2);
}
function formatUTCDayOfMonth(d, p) {
	return pad(d.getUTCDate(), p, 2);
}
function formatUTCHour24(d, p) {
	return pad(d.getUTCHours(), p, 2);
}
function formatUTCHour12(d, p) {
	return pad(d.getUTCHours() % 12 || 12, p, 2);
}
function formatUTCDayOfYear(d, p) {
	return pad(1 + utcDay.count(utcYear(d), d), p, 3);
}
function formatUTCMilliseconds(d, p) {
	return pad(d.getUTCMilliseconds(), p, 3);
}
function formatUTCMicroseconds(d, p) {
	return formatUTCMilliseconds(d, p) + "000";
}
function formatUTCMonthNumber(d, p) {
	return pad(d.getUTCMonth() + 1, p, 2);
}
function formatUTCMinutes(d, p) {
	return pad(d.getUTCMinutes(), p, 2);
}
function formatUTCSeconds(d, p) {
	return pad(d.getUTCSeconds(), p, 2);
}
function formatUTCWeekdayNumberMonday(d) {
	var dow = d.getUTCDay();
	return dow === 0 ? 7 : dow;
}
function formatUTCWeekNumberSunday(d, p) {
	return pad(utcSunday.count(utcYear(d) - 1, d), p, 2);
}
function UTCdISO(d) {
	var day = d.getUTCDay();
	return day >= 4 || day === 0 ? utcThursday(d) : utcThursday.ceil(d);
}
function formatUTCWeekNumberISO(d, p) {
	d = UTCdISO(d);
	return pad(utcThursday.count(utcYear(d), d) + (utcYear(d).getUTCDay() === 4), p, 2);
}
function formatUTCWeekdayNumberSunday(d) {
	return d.getUTCDay();
}
function formatUTCWeekNumberMonday(d, p) {
	return pad(utcMonday.count(utcYear(d) - 1, d), p, 2);
}
function formatUTCYear(d, p) {
	return pad(d.getUTCFullYear() % 100, p, 2);
}
function formatUTCYearISO(d, p) {
	d = UTCdISO(d);
	return pad(d.getUTCFullYear() % 100, p, 2);
}
function formatUTCFullYear(d, p) {
	return pad(d.getUTCFullYear() % 1e4, p, 4);
}
function formatUTCFullYearISO(d, p) {
	var day = d.getUTCDay();
	d = day >= 4 || day === 0 ? utcThursday(d) : utcThursday.ceil(d);
	return pad(d.getUTCFullYear() % 1e4, p, 4);
}
function formatUTCZone() {
	return "+0000";
}
function formatLiteralPercent() {
	return "%";
}
function formatUnixTimestamp(d) {
	return +d;
}
function formatUnixTimestampSeconds(d) {
	return Math.floor(+d / 1e3);
}
var locale;
var timeFormat;
var utcFormat;
defaultLocale({
	dateTime: "%x, %X",
	date: "%-m/%-d/%Y",
	time: "%-I:%M:%S %p",
	periods: ["AM", "PM"],
	days: [
		"Sunday",
		"Monday",
		"Tuesday",
		"Wednesday",
		"Thursday",
		"Friday",
		"Saturday"
	],
	shortDays: [
		"Sun",
		"Mon",
		"Tue",
		"Wed",
		"Thu",
		"Fri",
		"Sat"
	],
	months: [
		"January",
		"February",
		"March",
		"April",
		"May",
		"June",
		"July",
		"August",
		"September",
		"October",
		"November",
		"December"
	],
	shortMonths: [
		"Jan",
		"Feb",
		"Mar",
		"Apr",
		"May",
		"Jun",
		"Jul",
		"Aug",
		"Sep",
		"Oct",
		"Nov",
		"Dec"
	]
});
function defaultLocale(definition) {
	locale = formatLocale(definition);
	timeFormat = locale.format;
	locale.parse;
	utcFormat = locale.utcFormat;
	locale.utcParse;
	return locale;
}
function date(t$1) {
	return new Date(t$1);
}
function number(t$1) {
	return t$1 instanceof Date ? +t$1 : +/* @__PURE__ */ new Date(+t$1);
}
function calendar(ticks$1, tickInterval, year, month, week, day, hour, minute, second$1, format$2) {
	var scale = continuous(), invert = scale.invert, domain = scale.domain;
	var formatMillisecond = format$2(".%L"), formatSecond = format$2(":%S"), formatMinute = format$2("%I:%M"), formatHour = format$2("%I %p"), formatDay = format$2("%a %d"), formatWeek = format$2("%b %d"), formatMonth = format$2("%B"), formatYear$1 = format$2("%Y");
	function tickFormat$1(date$4) {
		return (second$1(date$4) < date$4 ? formatMillisecond : minute(date$4) < date$4 ? formatSecond : hour(date$4) < date$4 ? formatMinute : day(date$4) < date$4 ? formatHour : month(date$4) < date$4 ? week(date$4) < date$4 ? formatDay : formatWeek : year(date$4) < date$4 ? formatMonth : formatYear$1)(date$4);
	}
	scale.invert = function(y$1) {
		return new Date(invert(y$1));
	};
	scale.domain = function(_) {
		return arguments.length ? domain(Array.from(_, number)) : domain().map(date);
	};
	scale.ticks = function(interval) {
		var d = domain();
		return ticks$1(d[0], d[d.length - 1], interval == null ? 10 : interval);
	};
	scale.tickFormat = function(count, specifier) {
		return specifier == null ? tickFormat$1 : format$2(specifier);
	};
	scale.nice = function(interval) {
		var d = domain();
		if (!interval || typeof interval.range !== "function") interval = tickInterval(d[0], d[d.length - 1], interval == null ? 10 : interval);
		return interval ? domain(nice(d, interval)) : scale;
	};
	scale.copy = function() {
		return copy$1(scale, calendar(ticks$1, tickInterval, year, month, week, day, hour, minute, second$1, format$2));
	};
	return scale;
}
function time() {
	return initRange.apply(calendar(timeTicks, timeTickInterval, timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute, second, timeFormat).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
}
function utcTime() {
	return initRange.apply(calendar(utcTicks, utcTickInterval, utcYear, utcMonth, utcSunday, utcDay, utcHour, utcMinute, second, utcFormat).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments);
}
function transformer$1() {
	var x0 = 0, x1 = 1, t0$1, t1$1, k10, transform$1, interpolator = identity$4, clamp = false, unknown$1;
	function scale(x$1) {
		return x$1 == null || isNaN(x$1 = +x$1) ? unknown$1 : interpolator(k10 === 0 ? .5 : (x$1 = (transform$1(x$1) - t0$1) * k10, clamp ? Math.max(0, Math.min(1, x$1)) : x$1));
	}
	scale.domain = function(_) {
		return arguments.length ? ([x0, x1] = _, t0$1 = transform$1(x0 = +x0), t1$1 = transform$1(x1 = +x1), k10 = t0$1 === t1$1 ? 0 : 1 / (t1$1 - t0$1), scale) : [x0, x1];
	};
	scale.clamp = function(_) {
		return arguments.length ? (clamp = !!_, scale) : clamp;
	};
	scale.interpolator = function(_) {
		return arguments.length ? (interpolator = _, scale) : interpolator;
	};
	function range$5(interpolate) {
		return function(_) {
			var r0, r1;
			return arguments.length ? ([r0, r1] = _, interpolator = interpolate(r0, r1), scale) : [interpolator(0), interpolator(1)];
		};
	}
	scale.range = range$5(value_default);
	scale.rangeRound = range$5(round_default);
	scale.unknown = function(_) {
		return arguments.length ? (unknown$1 = _, scale) : unknown$1;
	};
	return function(t$1) {
		transform$1 = t$1, t0$1 = t$1(x0), t1$1 = t$1(x1), k10 = t0$1 === t1$1 ? 0 : 1 / (t1$1 - t0$1);
		return scale;
	};
}
function copy(source, target) {
	return target.domain(source.domain()).interpolator(source.interpolator()).clamp(source.clamp()).unknown(source.unknown());
}
function sequential() {
	var scale = linearish(transformer$1()(identity$4));
	scale.copy = function() {
		return copy(scale, sequential());
	};
	return initInterpolator.apply(scale, arguments);
}
function sequentialLog() {
	var scale = loggish(transformer$1()).domain([1, 10]);
	scale.copy = function() {
		return copy(scale, sequentialLog()).base(scale.base());
	};
	return initInterpolator.apply(scale, arguments);
}
function sequentialSymlog() {
	var scale = symlogish(transformer$1());
	scale.copy = function() {
		return copy(scale, sequentialSymlog()).constant(scale.constant());
	};
	return initInterpolator.apply(scale, arguments);
}
function sequentialPow() {
	var scale = powish(transformer$1());
	scale.copy = function() {
		return copy(scale, sequentialPow()).exponent(scale.exponent());
	};
	return initInterpolator.apply(scale, arguments);
}
function sequentialSqrt() {
	return sequentialPow.apply(null, arguments).exponent(.5);
}
function sequentialQuantile() {
	var domain = [], interpolator = identity$4;
	function scale(x$1) {
		if (x$1 != null && !isNaN(x$1 = +x$1)) return interpolator((bisect_default(domain, x$1, 1) - 1) / (domain.length - 1));
	}
	scale.domain = function(_) {
		if (!arguments.length) return domain.slice();
		domain = [];
		for (let d of _) if (d != null && !isNaN(d = +d)) domain.push(d);
		domain.sort(ascending);
		return scale;
	};
	scale.interpolator = function(_) {
		return arguments.length ? (interpolator = _, scale) : interpolator;
	};
	scale.range = function() {
		return domain.map((d, i$2) => interpolator(i$2 / (domain.length - 1)));
	};
	scale.quantiles = function(n$1) {
		return Array.from({ length: n$1 + 1 }, (_, i$2) => quantile(domain, i$2 / n$1));
	};
	scale.copy = function() {
		return sequentialQuantile(interpolator).domain(domain);
	};
	return initInterpolator.apply(scale, arguments);
}
function transformer() {
	var x0 = 0, x1 = .5, x2 = 1, s$3 = 1, t0$1, t1$1, t2, k10, k21, interpolator = identity$4, transform$1, clamp = false, unknown$1;
	function scale(x$1) {
		return isNaN(x$1 = +x$1) ? unknown$1 : (x$1 = .5 + ((x$1 = +transform$1(x$1)) - t1$1) * (s$3 * x$1 < s$3 * t1$1 ? k10 : k21), interpolator(clamp ? Math.max(0, Math.min(1, x$1)) : x$1));
	}
	scale.domain = function(_) {
		return arguments.length ? ([x0, x1, x2] = _, t0$1 = transform$1(x0 = +x0), t1$1 = transform$1(x1 = +x1), t2 = transform$1(x2 = +x2), k10 = t0$1 === t1$1 ? 0 : .5 / (t1$1 - t0$1), k21 = t1$1 === t2 ? 0 : .5 / (t2 - t1$1), s$3 = t1$1 < t0$1 ? -1 : 1, scale) : [
			x0,
			x1,
			x2
		];
	};
	scale.clamp = function(_) {
		return arguments.length ? (clamp = !!_, scale) : clamp;
	};
	scale.interpolator = function(_) {
		return arguments.length ? (interpolator = _, scale) : interpolator;
	};
	function range$5(interpolate) {
		return function(_) {
			var r0, r1, r2;
			return arguments.length ? ([r0, r1, r2] = _, interpolator = piecewise(interpolate, [
				r0,
				r1,
				r2
			]), scale) : [
				interpolator(0),
				interpolator(.5),
				interpolator(1)
			];
		};
	}
	scale.range = range$5(value_default);
	scale.rangeRound = range$5(round_default);
	scale.unknown = function(_) {
		return arguments.length ? (unknown$1 = _, scale) : unknown$1;
	};
	return function(t$1) {
		transform$1 = t$1, t0$1 = t$1(x0), t1$1 = t$1(x1), t2 = t$1(x2), k10 = t0$1 === t1$1 ? 0 : .5 / (t1$1 - t0$1), k21 = t1$1 === t2 ? 0 : .5 / (t2 - t1$1), s$3 = t1$1 < t0$1 ? -1 : 1;
		return scale;
	};
}
function diverging() {
	var scale = linearish(transformer()(identity$4));
	scale.copy = function() {
		return copy(scale, diverging());
	};
	return initInterpolator.apply(scale, arguments);
}
function divergingLog() {
	var scale = loggish(transformer()).domain([
		.1,
		1,
		10
	]);
	scale.copy = function() {
		return copy(scale, divergingLog()).base(scale.base());
	};
	return initInterpolator.apply(scale, arguments);
}
function divergingSymlog() {
	var scale = symlogish(transformer());
	scale.copy = function() {
		return copy(scale, divergingSymlog()).constant(scale.constant());
	};
	return initInterpolator.apply(scale, arguments);
}
function divergingPow() {
	var scale = powish(transformer());
	scale.copy = function() {
		return copy(scale, divergingPow()).exponent(scale.exponent());
	};
	return initInterpolator.apply(scale, arguments);
}
function divergingSqrt() {
	return divergingPow.apply(null, arguments).exponent(.5);
}
var d3_scale_exports = /* @__PURE__ */ __export({
	scaleBand: () => band,
	scaleDiverging: () => diverging,
	scaleDivergingLog: () => divergingLog,
	scaleDivergingPow: () => divergingPow,
	scaleDivergingSqrt: () => divergingSqrt,
	scaleDivergingSymlog: () => divergingSymlog,
	scaleIdentity: () => identity$5,
	scaleImplicit: () => implicit,
	scaleLinear: () => linear,
	scaleLog: () => log,
	scaleOrdinal: () => ordinal,
	scalePoint: () => point,
	scalePow: () => pow,
	scaleQuantile: () => quantile$1,
	scaleQuantize: () => quantize,
	scaleRadial: () => radial,
	scaleSequential: () => sequential,
	scaleSequentialLog: () => sequentialLog,
	scaleSequentialPow: () => sequentialPow,
	scaleSequentialQuantile: () => sequentialQuantile,
	scaleSequentialSqrt: () => sequentialSqrt,
	scaleSequentialSymlog: () => sequentialSymlog,
	scaleSqrt: () => sqrt,
	scaleSymlog: () => symlog,
	scaleThreshold: () => threshold,
	scaleTime: () => time,
	scaleUtc: () => utcTime,
	tickFormat: () => tickFormat
}, 1);
var require__baseExtremum = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var isSymbol = require_isSymbol();
	function baseExtremum$2(array$1, iteratee, comparator) {
		var index = -1, length = array$1.length;
		while (++index < length) {
			var value = array$1[index], current = iteratee(value);
			if (current != null && (computed === void 0 ? current === current && !isSymbol(current) : comparator(current, computed))) var computed = current, result = value;
		}
		return result;
	}
	module.exports = baseExtremum$2;
}));
var require__baseGt = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function baseGt$1(value, other) {
		return value > other;
	}
	module.exports = baseGt$1;
}));
var require_max = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseExtremum$1 = require__baseExtremum(), baseGt = require__baseGt(), identity$3 = require_identity();
	function max$2(array$1) {
		return array$1 && array$1.length ? baseExtremum$1(array$1, identity$3, baseGt) : void 0;
	}
	module.exports = max$2;
}));
var require__baseLt = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function baseLt$1(value, other) {
		return value < other;
	}
	module.exports = baseLt$1;
}));
var require_min = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseExtremum = require__baseExtremum(), baseLt = require__baseLt(), identity$2 = require_identity();
	function min$1(array$1) {
		return array$1 && array$1.length ? baseExtremum(array$1, identity$2, baseLt) : void 0;
	}
	module.exports = min$1;
}));
var require_map = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var arrayMap = require__arrayMap(), baseIteratee$5 = require__baseIteratee(), baseMap = require__baseMap(), isArray$2 = require_isArray();
	function map$2(collection, iteratee) {
		return (isArray$2(collection) ? arrayMap : baseMap)(collection, baseIteratee$5(iteratee, 3));
	}
	module.exports = map$2;
}));
var require_flatMap = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseFlatten = require__baseFlatten(), map$1 = require_map();
	function flatMap$1(collection, iteratee) {
		return baseFlatten(map$1(collection, iteratee), 1);
	}
	module.exports = flatMap$1;
}));
var require_isEqual = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseIsEqual = require__baseIsEqual();
	function isEqual$5(value, other) {
		return baseIsEqual(value, other);
	}
	module.exports = isEqual$5;
}));
var require_decimal = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	(function(globalScope) {
		"use strict";
		var MAX_DIGITS = 1e9, Decimal$2 = {
			precision: 20,
			rounding: 4,
			toExpNeg: -7,
			toExpPos: 21,
			LN10: "2.302585092994045684017991454684364207601101488628772976033327900967572609677352480235997205089598298341967784042286"
		}, external = true, decimalError = "[DecimalError] ", invalidArgument = decimalError + "Invalid argument: ", exponentOutOfRange = decimalError + "Exponent out of range: ", mathfloor = Math.floor, mathpow = Math.pow, isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, ONE, BASE = 1e7, LOG_BASE = 7, MAX_SAFE_INTEGER$2 = 9007199254740991, MAX_E = mathfloor(MAX_SAFE_INTEGER$2 / LOG_BASE), P = {};
		P.absoluteValue = P.abs = function() {
			var x$1 = new this.constructor(this);
			if (x$1.s) x$1.s = 1;
			return x$1;
		};
		P.comparedTo = P.cmp = function(y$1) {
			var i$2, j, xdL, ydL, x$1 = this;
			y$1 = new x$1.constructor(y$1);
			if (x$1.s !== y$1.s) return x$1.s || -y$1.s;
			if (x$1.e !== y$1.e) return x$1.e > y$1.e ^ x$1.s < 0 ? 1 : -1;
			xdL = x$1.d.length;
			ydL = y$1.d.length;
			for (i$2 = 0, j = xdL < ydL ? xdL : ydL; i$2 < j; ++i$2) if (x$1.d[i$2] !== y$1.d[i$2]) return x$1.d[i$2] > y$1.d[i$2] ^ x$1.s < 0 ? 1 : -1;
			return xdL === ydL ? 0 : xdL > ydL ^ x$1.s < 0 ? 1 : -1;
		};
		P.decimalPlaces = P.dp = function() {
			var x$1 = this, w = x$1.d.length - 1, dp = (w - x$1.e) * LOG_BASE;
			w = x$1.d[w];
			if (w) for (; w % 10 == 0; w /= 10) dp--;
			return dp < 0 ? 0 : dp;
		};
		P.dividedBy = P.div = function(y$1) {
			return divide(this, new this.constructor(y$1));
		};
		P.dividedToIntegerBy = P.idiv = function(y$1) {
			var x$1 = this, Ctor = x$1.constructor;
			return round(divide(x$1, new Ctor(y$1), 0, 1), Ctor.precision);
		};
		P.equals = P.eq = function(y$1) {
			return !this.cmp(y$1);
		};
		P.exponent = function() {
			return getBase10Exponent(this);
		};
		P.greaterThan = P.gt = function(y$1) {
			return this.cmp(y$1) > 0;
		};
		P.greaterThanOrEqualTo = P.gte = function(y$1) {
			return this.cmp(y$1) >= 0;
		};
		P.isInteger = P.isint = function() {
			return this.e > this.d.length - 2;
		};
		P.isNegative = P.isneg = function() {
			return this.s < 0;
		};
		P.isPositive = P.ispos = function() {
			return this.s > 0;
		};
		P.isZero = function() {
			return this.s === 0;
		};
		P.lessThan = P.lt = function(y$1) {
			return this.cmp(y$1) < 0;
		};
		P.lessThanOrEqualTo = P.lte = function(y$1) {
			return this.cmp(y$1) < 1;
		};
		P.logarithm = P.log = function(base) {
			var r$1, x$1 = this, Ctor = x$1.constructor, pr = Ctor.precision, wpr = pr + 5;
			if (base === void 0) base = new Ctor(10);
			else {
				base = new Ctor(base);
				if (base.s < 1 || base.eq(ONE)) throw Error(decimalError + "NaN");
			}
			if (x$1.s < 1) throw Error(decimalError + (x$1.s ? "NaN" : "-Infinity"));
			if (x$1.eq(ONE)) return new Ctor(0);
			external = false;
			r$1 = divide(ln(x$1, wpr), ln(base, wpr), wpr);
			external = true;
			return round(r$1, pr);
		};
		P.minus = P.sub = function(y$1) {
			var x$1 = this;
			y$1 = new x$1.constructor(y$1);
			return x$1.s == y$1.s ? subtract(x$1, y$1) : add(x$1, (y$1.s = -y$1.s, y$1));
		};
		P.modulo = P.mod = function(y$1) {
			var q, x$1 = this, Ctor = x$1.constructor, pr = Ctor.precision;
			y$1 = new Ctor(y$1);
			if (!y$1.s) throw Error(decimalError + "NaN");
			if (!x$1.s) return round(new Ctor(x$1), pr);
			external = false;
			q = divide(x$1, y$1, 0, 1).times(y$1);
			external = true;
			return x$1.minus(q);
		};
		P.naturalExponential = P.exp = function() {
			return exp(this);
		};
		P.naturalLogarithm = P.ln = function() {
			return ln(this);
		};
		P.negated = P.neg = function() {
			var x$1 = new this.constructor(this);
			x$1.s = -x$1.s || 0;
			return x$1;
		};
		P.plus = P.add = function(y$1) {
			var x$1 = this;
			y$1 = new x$1.constructor(y$1);
			return x$1.s == y$1.s ? add(x$1, y$1) : subtract(x$1, (y$1.s = -y$1.s, y$1));
		};
		P.precision = P.sd = function(z) {
			var e, sd, w, x$1 = this;
			if (z !== void 0 && z !== !!z && z !== 1 && z !== 0) throw Error(invalidArgument + z);
			e = getBase10Exponent(x$1) + 1;
			w = x$1.d.length - 1;
			sd = w * LOG_BASE + 1;
			w = x$1.d[w];
			if (w) {
				for (; w % 10 == 0; w /= 10) sd--;
				for (w = x$1.d[0]; w >= 10; w /= 10) sd++;
			}
			return z && e > sd ? e : sd;
		};
		P.squareRoot = P.sqrt = function() {
			var e, n$1, pr, r$1, s$3, t$1, wpr, x$1 = this, Ctor = x$1.constructor;
			if (x$1.s < 1) {
				if (!x$1.s) return new Ctor(0);
				throw Error(decimalError + "NaN");
			}
			e = getBase10Exponent(x$1);
			external = false;
			s$3 = Math.sqrt(+x$1);
			if (s$3 == 0 || s$3 == Infinity) {
				n$1 = digitsToString(x$1.d);
				if ((n$1.length + e) % 2 == 0) n$1 += "0";
				s$3 = Math.sqrt(n$1);
				e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);
				if (s$3 == Infinity) n$1 = "5e" + e;
				else {
					n$1 = s$3.toExponential();
					n$1 = n$1.slice(0, n$1.indexOf("e") + 1) + e;
				}
				r$1 = new Ctor(n$1);
			} else r$1 = new Ctor(s$3.toString());
			pr = Ctor.precision;
			s$3 = wpr = pr + 3;
			for (;;) {
				t$1 = r$1;
				r$1 = t$1.plus(divide(x$1, t$1, wpr + 2)).times(.5);
				if (digitsToString(t$1.d).slice(0, wpr) === (n$1 = digitsToString(r$1.d)).slice(0, wpr)) {
					n$1 = n$1.slice(wpr - 3, wpr + 1);
					if (s$3 == wpr && n$1 == "4999") {
						round(t$1, pr + 1, 0);
						if (t$1.times(t$1).eq(x$1)) {
							r$1 = t$1;
							break;
						}
					} else if (n$1 != "9999") break;
					wpr += 4;
				}
			}
			external = true;
			return round(r$1, pr);
		};
		P.times = P.mul = function(y$1) {
			var carry, e, i$2, k$1, r$1, rL, t$1, xdL, ydL, x$1 = this, Ctor = x$1.constructor, xd = x$1.d, yd = (y$1 = new Ctor(y$1)).d;
			if (!x$1.s || !y$1.s) return new Ctor(0);
			y$1.s *= x$1.s;
			e = x$1.e + y$1.e;
			xdL = xd.length;
			ydL = yd.length;
			if (xdL < ydL) {
				r$1 = xd;
				xd = yd;
				yd = r$1;
				rL = xdL;
				xdL = ydL;
				ydL = rL;
			}
			r$1 = [];
			rL = xdL + ydL;
			for (i$2 = rL; i$2--;) r$1.push(0);
			for (i$2 = ydL; --i$2 >= 0;) {
				carry = 0;
				for (k$1 = xdL + i$2; k$1 > i$2;) {
					t$1 = r$1[k$1] + yd[i$2] * xd[k$1 - i$2 - 1] + carry;
					r$1[k$1--] = t$1 % BASE | 0;
					carry = t$1 / BASE | 0;
				}
				r$1[k$1] = (r$1[k$1] + carry) % BASE | 0;
			}
			for (; !r$1[--rL];) r$1.pop();
			if (carry) ++e;
			else r$1.shift();
			y$1.d = r$1;
			y$1.e = e;
			return external ? round(y$1, Ctor.precision) : y$1;
		};
		P.toDecimalPlaces = P.todp = function(dp, rm) {
			var x$1 = this, Ctor = x$1.constructor;
			x$1 = new Ctor(x$1);
			if (dp === void 0) return x$1;
			checkInt32(dp, 0, MAX_DIGITS);
			if (rm === void 0) rm = Ctor.rounding;
			else checkInt32(rm, 0, 8);
			return round(x$1, dp + getBase10Exponent(x$1) + 1, rm);
		};
		P.toExponential = function(dp, rm) {
			var str, x$1 = this, Ctor = x$1.constructor;
			if (dp === void 0) str = toString$4(x$1, true);
			else {
				checkInt32(dp, 0, MAX_DIGITS);
				if (rm === void 0) rm = Ctor.rounding;
				else checkInt32(rm, 0, 8);
				x$1 = round(new Ctor(x$1), dp + 1, rm);
				str = toString$4(x$1, true, dp + 1);
			}
			return str;
		};
		P.toFixed = function(dp, rm) {
			var str, y$1, x$1 = this, Ctor = x$1.constructor;
			if (dp === void 0) return toString$4(x$1);
			checkInt32(dp, 0, MAX_DIGITS);
			if (rm === void 0) rm = Ctor.rounding;
			else checkInt32(rm, 0, 8);
			y$1 = round(new Ctor(x$1), dp + getBase10Exponent(x$1) + 1, rm);
			str = toString$4(y$1.abs(), false, dp + getBase10Exponent(y$1) + 1);
			return x$1.isneg() && !x$1.isZero() ? "-" + str : str;
		};
		P.toInteger = P.toint = function() {
			var x$1 = this, Ctor = x$1.constructor;
			return round(new Ctor(x$1), getBase10Exponent(x$1) + 1, Ctor.rounding);
		};
		P.toNumber = function() {
			return +this;
		};
		P.toPower = P.pow = function(y$1) {
			var e, k$1, pr, r$1, sign$1, yIsInt, x$1 = this, Ctor = x$1.constructor, guard = 12, yn = +(y$1 = new Ctor(y$1));
			if (!y$1.s) return new Ctor(ONE);
			x$1 = new Ctor(x$1);
			if (!x$1.s) {
				if (y$1.s < 1) throw Error(decimalError + "Infinity");
				return x$1;
			}
			if (x$1.eq(ONE)) return x$1;
			pr = Ctor.precision;
			if (y$1.eq(ONE)) return round(x$1, pr);
			e = y$1.e;
			k$1 = y$1.d.length - 1;
			yIsInt = e >= k$1;
			sign$1 = x$1.s;
			if (!yIsInt) {
				if (sign$1 < 0) throw Error(decimalError + "NaN");
			} else if ((k$1 = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER$2) {
				r$1 = new Ctor(ONE);
				e = Math.ceil(pr / LOG_BASE + 4);
				external = false;
				for (;;) {
					if (k$1 % 2) {
						r$1 = r$1.times(x$1);
						truncate(r$1.d, e);
					}
					k$1 = mathfloor(k$1 / 2);
					if (k$1 === 0) break;
					x$1 = x$1.times(x$1);
					truncate(x$1.d, e);
				}
				external = true;
				return y$1.s < 0 ? new Ctor(ONE).div(r$1) : round(r$1, pr);
			}
			sign$1 = sign$1 < 0 && y$1.d[Math.max(e, k$1)] & 1 ? -1 : 1;
			x$1.s = 1;
			external = false;
			r$1 = y$1.times(ln(x$1, pr + guard));
			external = true;
			r$1 = exp(r$1);
			r$1.s = sign$1;
			return r$1;
		};
		P.toPrecision = function(sd, rm) {
			var e, str, x$1 = this, Ctor = x$1.constructor;
			if (sd === void 0) {
				e = getBase10Exponent(x$1);
				str = toString$4(x$1, e <= Ctor.toExpNeg || e >= Ctor.toExpPos);
			} else {
				checkInt32(sd, 1, MAX_DIGITS);
				if (rm === void 0) rm = Ctor.rounding;
				else checkInt32(rm, 0, 8);
				x$1 = round(new Ctor(x$1), sd, rm);
				e = getBase10Exponent(x$1);
				str = toString$4(x$1, sd <= e || e <= Ctor.toExpNeg, sd);
			}
			return str;
		};
		P.toSignificantDigits = P.tosd = function(sd, rm) {
			var x$1 = this, Ctor = x$1.constructor;
			if (sd === void 0) {
				sd = Ctor.precision;
				rm = Ctor.rounding;
			} else {
				checkInt32(sd, 1, MAX_DIGITS);
				if (rm === void 0) rm = Ctor.rounding;
				else checkInt32(rm, 0, 8);
			}
			return round(new Ctor(x$1), sd, rm);
		};
		P.toString = P.valueOf = P.val = P.toJSON = function() {
			var x$1 = this, e = getBase10Exponent(x$1), Ctor = x$1.constructor;
			return toString$4(x$1, e <= Ctor.toExpNeg || e >= Ctor.toExpPos);
		};
		function add(x$1, y$1) {
			var carry, d, e, i$2, k$1, len, xd, yd, Ctor = x$1.constructor, pr = Ctor.precision;
			if (!x$1.s || !y$1.s) {
				if (!y$1.s) y$1 = new Ctor(x$1);
				return external ? round(y$1, pr) : y$1;
			}
			xd = x$1.d;
			yd = y$1.d;
			k$1 = x$1.e;
			e = y$1.e;
			xd = xd.slice();
			i$2 = k$1 - e;
			if (i$2) {
				if (i$2 < 0) {
					d = xd;
					i$2 = -i$2;
					len = yd.length;
				} else {
					d = yd;
					e = k$1;
					len = xd.length;
				}
				k$1 = Math.ceil(pr / LOG_BASE);
				len = k$1 > len ? k$1 + 1 : len + 1;
				if (i$2 > len) {
					i$2 = len;
					d.length = 1;
				}
				d.reverse();
				for (; i$2--;) d.push(0);
				d.reverse();
			}
			len = xd.length;
			i$2 = yd.length;
			if (len - i$2 < 0) {
				i$2 = len;
				d = yd;
				yd = xd;
				xd = d;
			}
			for (carry = 0; i$2;) {
				carry = (xd[--i$2] = xd[i$2] + yd[i$2] + carry) / BASE | 0;
				xd[i$2] %= BASE;
			}
			if (carry) {
				xd.unshift(carry);
				++e;
			}
			for (len = xd.length; xd[--len] == 0;) xd.pop();
			y$1.d = xd;
			y$1.e = e;
			return external ? round(y$1, pr) : y$1;
		}
		function checkInt32(i$2, min$3, max$4) {
			if (i$2 !== ~~i$2 || i$2 < min$3 || i$2 > max$4) throw Error(invalidArgument + i$2);
		}
		function digitsToString(d) {
			var i$2, k$1, ws, indexOfLastWord = d.length - 1, str = "", w = d[0];
			if (indexOfLastWord > 0) {
				str += w;
				for (i$2 = 1; i$2 < indexOfLastWord; i$2++) {
					ws = d[i$2] + "";
					k$1 = LOG_BASE - ws.length;
					if (k$1) str += getZeroString(k$1);
					str += ws;
				}
				w = d[i$2];
				ws = w + "";
				k$1 = LOG_BASE - ws.length;
				if (k$1) str += getZeroString(k$1);
			} else if (w === 0) return "0";
			for (; w % 10 === 0;) w /= 10;
			return str + w;
		}
		var divide = (function() {
			function multiplyInteger(x$1, k$1) {
				var temp, carry = 0, i$2 = x$1.length;
				for (x$1 = x$1.slice(); i$2--;) {
					temp = x$1[i$2] * k$1 + carry;
					x$1[i$2] = temp % BASE | 0;
					carry = temp / BASE | 0;
				}
				if (carry) x$1.unshift(carry);
				return x$1;
			}
			function compare(a$2, b, aL, bL) {
				var i$2, r$1;
				if (aL != bL) r$1 = aL > bL ? 1 : -1;
				else for (i$2 = r$1 = 0; i$2 < aL; i$2++) if (a$2[i$2] != b[i$2]) {
					r$1 = a$2[i$2] > b[i$2] ? 1 : -1;
					break;
				}
				return r$1;
			}
			function subtract$1(a$2, b, aL) {
				var i$2 = 0;
				for (; aL--;) {
					a$2[aL] -= i$2;
					i$2 = a$2[aL] < b[aL] ? 1 : 0;
					a$2[aL] = i$2 * BASE + a$2[aL] - b[aL];
				}
				for (; !a$2[0] && a$2.length > 1;) a$2.shift();
			}
			return function(x$1, y$1, pr, dp) {
				var cmp, e, i$2, k$1, prod, prodL, q, qd, rem, remL, rem0, sd, t$1, xi, xL, yd0, yL, yz, Ctor = x$1.constructor, sign$1 = x$1.s == y$1.s ? 1 : -1, xd = x$1.d, yd = y$1.d;
				if (!x$1.s) return new Ctor(x$1);
				if (!y$1.s) throw Error(decimalError + "Division by zero");
				e = x$1.e - y$1.e;
				yL = yd.length;
				xL = xd.length;
				q = new Ctor(sign$1);
				qd = q.d = [];
				for (i$2 = 0; yd[i$2] == (xd[i$2] || 0);) ++i$2;
				if (yd[i$2] > (xd[i$2] || 0)) --e;
				if (pr == null) sd = pr = Ctor.precision;
				else if (dp) sd = pr + (getBase10Exponent(x$1) - getBase10Exponent(y$1)) + 1;
				else sd = pr;
				if (sd < 0) return new Ctor(0);
				sd = sd / LOG_BASE + 2 | 0;
				i$2 = 0;
				if (yL == 1) {
					k$1 = 0;
					yd = yd[0];
					sd++;
					for (; (i$2 < xL || k$1) && sd--; i$2++) {
						t$1 = k$1 * BASE + (xd[i$2] || 0);
						qd[i$2] = t$1 / yd | 0;
						k$1 = t$1 % yd | 0;
					}
				} else {
					k$1 = BASE / (yd[0] + 1) | 0;
					if (k$1 > 1) {
						yd = multiplyInteger(yd, k$1);
						xd = multiplyInteger(xd, k$1);
						yL = yd.length;
						xL = xd.length;
					}
					xi = yL;
					rem = xd.slice(0, yL);
					remL = rem.length;
					for (; remL < yL;) rem[remL++] = 0;
					yz = yd.slice();
					yz.unshift(0);
					yd0 = yd[0];
					if (yd[1] >= BASE / 2) ++yd0;
					do {
						k$1 = 0;
						cmp = compare(yd, rem, yL, remL);
						if (cmp < 0) {
							rem0 = rem[0];
							if (yL != remL) rem0 = rem0 * BASE + (rem[1] || 0);
							k$1 = rem0 / yd0 | 0;
							if (k$1 > 1) {
								if (k$1 >= BASE) k$1 = BASE - 1;
								prod = multiplyInteger(yd, k$1);
								prodL = prod.length;
								remL = rem.length;
								cmp = compare(prod, rem, prodL, remL);
								if (cmp == 1) {
									k$1--;
									subtract$1(prod, yL < prodL ? yz : yd, prodL);
								}
							} else {
								if (k$1 == 0) cmp = k$1 = 1;
								prod = yd.slice();
							}
							prodL = prod.length;
							if (prodL < remL) prod.unshift(0);
							subtract$1(rem, prod, remL);
							if (cmp == -1) {
								remL = rem.length;
								cmp = compare(yd, rem, yL, remL);
								if (cmp < 1) {
									k$1++;
									subtract$1(rem, yL < remL ? yz : yd, remL);
								}
							}
							remL = rem.length;
						} else if (cmp === 0) {
							k$1++;
							rem = [0];
						}
						qd[i$2++] = k$1;
						if (cmp && rem[0]) rem[remL++] = xd[xi] || 0;
						else {
							rem = [xd[xi]];
							remL = 1;
						}
					} while ((xi++ < xL || rem[0] !== void 0) && sd--);
				}
				if (!qd[0]) qd.shift();
				q.e = e;
				return round(q, dp ? pr + getBase10Exponent(q) + 1 : pr);
			};
		})();
		function exp(x$1, sd) {
			var denominator, guard, pow$1, sum, t$1, wpr, i$2 = 0, k$1 = 0, Ctor = x$1.constructor, pr = Ctor.precision;
			if (getBase10Exponent(x$1) > 16) throw Error(exponentOutOfRange + getBase10Exponent(x$1));
			if (!x$1.s) return new Ctor(ONE);
			if (sd == null) {
				external = false;
				wpr = pr;
			} else wpr = sd;
			t$1 = new Ctor(.03125);
			while (x$1.abs().gte(.1)) {
				x$1 = x$1.times(t$1);
				k$1 += 5;
			}
			guard = Math.log(mathpow(2, k$1)) / Math.LN10 * 2 + 5 | 0;
			wpr += guard;
			denominator = pow$1 = sum = new Ctor(ONE);
			Ctor.precision = wpr;
			for (;;) {
				pow$1 = round(pow$1.times(x$1), wpr);
				denominator = denominator.times(++i$2);
				t$1 = sum.plus(divide(pow$1, denominator, wpr));
				if (digitsToString(t$1.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {
					while (k$1--) sum = round(sum.times(sum), wpr);
					Ctor.precision = pr;
					return sd == null ? (external = true, round(sum, pr)) : sum;
				}
				sum = t$1;
			}
		}
		function getBase10Exponent(x$1) {
			var e = x$1.e * LOG_BASE, w = x$1.d[0];
			for (; w >= 10; w /= 10) e++;
			return e;
		}
		function getLn10(Ctor, sd, pr) {
			if (sd > Ctor.LN10.sd()) {
				external = true;
				if (pr) Ctor.precision = pr;
				throw Error(decimalError + "LN10 precision limit exceeded");
			}
			return round(new Ctor(Ctor.LN10), sd);
		}
		function getZeroString(k$1) {
			var zs = "";
			for (; k$1--;) zs += "0";
			return zs;
		}
		function ln(y$1, sd) {
			var c$1, c0, denominator, e, numerator, sum, t$1, wpr, x2, n$1 = 1, guard = 10, x$1 = y$1, xd = x$1.d, Ctor = x$1.constructor, pr = Ctor.precision;
			if (x$1.s < 1) throw Error(decimalError + (x$1.s ? "NaN" : "-Infinity"));
			if (x$1.eq(ONE)) return new Ctor(0);
			if (sd == null) {
				external = false;
				wpr = pr;
			} else wpr = sd;
			if (x$1.eq(10)) {
				if (sd == null) external = true;
				return getLn10(Ctor, wpr);
			}
			wpr += guard;
			Ctor.precision = wpr;
			c$1 = digitsToString(xd);
			c0 = c$1.charAt(0);
			e = getBase10Exponent(x$1);
			if (Math.abs(e) < 0x5543df729c000) {
				while (c0 < 7 && c0 != 1 || c0 == 1 && c$1.charAt(1) > 3) {
					x$1 = x$1.times(y$1);
					c$1 = digitsToString(x$1.d);
					c0 = c$1.charAt(0);
					n$1++;
				}
				e = getBase10Exponent(x$1);
				if (c0 > 1) {
					x$1 = new Ctor("0." + c$1);
					e++;
				} else x$1 = new Ctor(c0 + "." + c$1.slice(1));
			} else {
				t$1 = getLn10(Ctor, wpr + 2, pr).times(e + "");
				x$1 = ln(new Ctor(c0 + "." + c$1.slice(1)), wpr - guard).plus(t$1);
				Ctor.precision = pr;
				return sd == null ? (external = true, round(x$1, pr)) : x$1;
			}
			sum = numerator = x$1 = divide(x$1.minus(ONE), x$1.plus(ONE), wpr);
			x2 = round(x$1.times(x$1), wpr);
			denominator = 3;
			for (;;) {
				numerator = round(numerator.times(x2), wpr);
				t$1 = sum.plus(divide(numerator, new Ctor(denominator), wpr));
				if (digitsToString(t$1.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {
					sum = sum.times(2);
					if (e !== 0) sum = sum.plus(getLn10(Ctor, wpr + 2, pr).times(e + ""));
					sum = divide(sum, new Ctor(n$1), wpr);
					Ctor.precision = pr;
					return sd == null ? (external = true, round(sum, pr)) : sum;
				}
				sum = t$1;
				denominator += 2;
			}
		}
		function parseDecimal(x$1, str) {
			var e, i$2, len;
			if ((e = str.indexOf(".")) > -1) str = str.replace(".", "");
			if ((i$2 = str.search(/e/i)) > 0) {
				if (e < 0) e = i$2;
				e += +str.slice(i$2 + 1);
				str = str.substring(0, i$2);
			} else if (e < 0) e = str.length;
			for (i$2 = 0; str.charCodeAt(i$2) === 48;) ++i$2;
			for (len = str.length; str.charCodeAt(len - 1) === 48;) --len;
			str = str.slice(i$2, len);
			if (str) {
				len -= i$2;
				e = e - i$2 - 1;
				x$1.e = mathfloor(e / LOG_BASE);
				x$1.d = [];
				i$2 = (e + 1) % LOG_BASE;
				if (e < 0) i$2 += LOG_BASE;
				if (i$2 < len) {
					if (i$2) x$1.d.push(+str.slice(0, i$2));
					for (len -= LOG_BASE; i$2 < len;) x$1.d.push(+str.slice(i$2, i$2 += LOG_BASE));
					str = str.slice(i$2);
					i$2 = LOG_BASE - str.length;
				} else i$2 -= len;
				for (; i$2--;) str += "0";
				x$1.d.push(+str);
				if (external && (x$1.e > MAX_E || x$1.e < -MAX_E)) throw Error(exponentOutOfRange + e);
			} else {
				x$1.s = 0;
				x$1.e = 0;
				x$1.d = [0];
			}
			return x$1;
		}
		function round(x$1, sd, rm) {
			var i$2, j, k$1, n$1, rd, doRound, w, xdi, xd = x$1.d;
			for (n$1 = 1, k$1 = xd[0]; k$1 >= 10; k$1 /= 10) n$1++;
			i$2 = sd - n$1;
			if (i$2 < 0) {
				i$2 += LOG_BASE;
				j = sd;
				w = xd[xdi = 0];
			} else {
				xdi = Math.ceil((i$2 + 1) / LOG_BASE);
				k$1 = xd.length;
				if (xdi >= k$1) return x$1;
				w = k$1 = xd[xdi];
				for (n$1 = 1; k$1 >= 10; k$1 /= 10) n$1++;
				i$2 %= LOG_BASE;
				j = i$2 - LOG_BASE + n$1;
			}
			if (rm !== void 0) {
				k$1 = mathpow(10, n$1 - j - 1);
				rd = w / k$1 % 10 | 0;
				doRound = sd < 0 || xd[xdi + 1] !== void 0 || w % k$1;
				doRound = rm < 4 ? (rd || doRound) && (rm == 0 || rm == (x$1.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || doRound || rm == 6 && (i$2 > 0 ? j > 0 ? w / mathpow(10, n$1 - j) : 0 : xd[xdi - 1]) % 10 & 1 || rm == (x$1.s < 0 ? 8 : 7));
			}
			if (sd < 1 || !xd[0]) {
				if (doRound) {
					k$1 = getBase10Exponent(x$1);
					xd.length = 1;
					sd = sd - k$1 - 1;
					xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);
					x$1.e = mathfloor(-sd / LOG_BASE) || 0;
				} else {
					xd.length = 1;
					xd[0] = x$1.e = x$1.s = 0;
				}
				return x$1;
			}
			if (i$2 == 0) {
				xd.length = xdi;
				k$1 = 1;
				xdi--;
			} else {
				xd.length = xdi + 1;
				k$1 = mathpow(10, LOG_BASE - i$2);
				xd[xdi] = j > 0 ? (w / mathpow(10, n$1 - j) % mathpow(10, j) | 0) * k$1 : 0;
			}
			if (doRound) for (;;) if (xdi == 0) {
				if ((xd[0] += k$1) == BASE) {
					xd[0] = 1;
					++x$1.e;
				}
				break;
			} else {
				xd[xdi] += k$1;
				if (xd[xdi] != BASE) break;
				xd[xdi--] = 0;
				k$1 = 1;
			}
			for (i$2 = xd.length; xd[--i$2] === 0;) xd.pop();
			if (external && (x$1.e > MAX_E || x$1.e < -MAX_E)) throw Error(exponentOutOfRange + getBase10Exponent(x$1));
			return x$1;
		}
		function subtract(x$1, y$1) {
			var d, e, i$2, j, k$1, len, xd, xe, xLTy, yd, Ctor = x$1.constructor, pr = Ctor.precision;
			if (!x$1.s || !y$1.s) {
				if (y$1.s) y$1.s = -y$1.s;
				else y$1 = new Ctor(x$1);
				return external ? round(y$1, pr) : y$1;
			}
			xd = x$1.d;
			yd = y$1.d;
			e = y$1.e;
			xe = x$1.e;
			xd = xd.slice();
			k$1 = xe - e;
			if (k$1) {
				xLTy = k$1 < 0;
				if (xLTy) {
					d = xd;
					k$1 = -k$1;
					len = yd.length;
				} else {
					d = yd;
					e = xe;
					len = xd.length;
				}
				i$2 = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;
				if (k$1 > i$2) {
					k$1 = i$2;
					d.length = 1;
				}
				d.reverse();
				for (i$2 = k$1; i$2--;) d.push(0);
				d.reverse();
			} else {
				i$2 = xd.length;
				len = yd.length;
				xLTy = i$2 < len;
				if (xLTy) len = i$2;
				for (i$2 = 0; i$2 < len; i$2++) if (xd[i$2] != yd[i$2]) {
					xLTy = xd[i$2] < yd[i$2];
					break;
				}
				k$1 = 0;
			}
			if (xLTy) {
				d = xd;
				xd = yd;
				yd = d;
				y$1.s = -y$1.s;
			}
			len = xd.length;
			for (i$2 = yd.length - len; i$2 > 0; --i$2) xd[len++] = 0;
			for (i$2 = yd.length; i$2 > k$1;) {
				if (xd[--i$2] < yd[i$2]) {
					for (j = i$2; j && xd[--j] === 0;) xd[j] = BASE - 1;
					--xd[j];
					xd[i$2] += BASE;
				}
				xd[i$2] -= yd[i$2];
			}
			for (; xd[--len] === 0;) xd.pop();
			for (; xd[0] === 0; xd.shift()) --e;
			if (!xd[0]) return new Ctor(0);
			y$1.d = xd;
			y$1.e = e;
			return external ? round(y$1, pr) : y$1;
		}
		function toString$4(x$1, isExp, sd) {
			var k$1, e = getBase10Exponent(x$1), str = digitsToString(x$1.d), len = str.length;
			if (isExp) {
				if (sd && (k$1 = sd - len) > 0) str = str.charAt(0) + "." + str.slice(1) + getZeroString(k$1);
				else if (len > 1) str = str.charAt(0) + "." + str.slice(1);
				str = str + (e < 0 ? "e" : "e+") + e;
			} else if (e < 0) {
				str = "0." + getZeroString(-e - 1) + str;
				if (sd && (k$1 = sd - len) > 0) str += getZeroString(k$1);
			} else if (e >= len) {
				str += getZeroString(e + 1 - len);
				if (sd && (k$1 = sd - e - 1) > 0) str = str + "." + getZeroString(k$1);
			} else {
				if ((k$1 = e + 1) < len) str = str.slice(0, k$1) + "." + str.slice(k$1);
				if (sd && (k$1 = sd - len) > 0) {
					if (e + 1 === len) str += ".";
					str += getZeroString(k$1);
				}
			}
			return x$1.s < 0 ? "-" + str : str;
		}
		function truncate(arr, len) {
			if (arr.length > len) {
				arr.length = len;
				return true;
			}
		}
		function clone$1(obj) {
			var i$2, p, ps;
			function Decimal$3(value) {
				var x$1 = this;
				if (!(x$1 instanceof Decimal$3)) return new Decimal$3(value);
				x$1.constructor = Decimal$3;
				if (value instanceof Decimal$3) {
					x$1.s = value.s;
					x$1.e = value.e;
					x$1.d = (value = value.d) ? value.slice() : value;
					return;
				}
				if (typeof value === "number") {
					if (value * 0 !== 0) throw Error(invalidArgument + value);
					if (value > 0) x$1.s = 1;
					else if (value < 0) {
						value = -value;
						x$1.s = -1;
					} else {
						x$1.s = 0;
						x$1.e = 0;
						x$1.d = [0];
						return;
					}
					if (value === ~~value && value < 1e7) {
						x$1.e = 0;
						x$1.d = [value];
						return;
					}
					return parseDecimal(x$1, value.toString());
				} else if (typeof value !== "string") throw Error(invalidArgument + value);
				if (value.charCodeAt(0) === 45) {
					value = value.slice(1);
					x$1.s = -1;
				} else x$1.s = 1;
				if (isDecimal.test(value)) parseDecimal(x$1, value);
				else throw Error(invalidArgument + value);
			}
			Decimal$3.prototype = P;
			Decimal$3.ROUND_UP = 0;
			Decimal$3.ROUND_DOWN = 1;
			Decimal$3.ROUND_CEIL = 2;
			Decimal$3.ROUND_FLOOR = 3;
			Decimal$3.ROUND_HALF_UP = 4;
			Decimal$3.ROUND_HALF_DOWN = 5;
			Decimal$3.ROUND_HALF_EVEN = 6;
			Decimal$3.ROUND_HALF_CEIL = 7;
			Decimal$3.ROUND_HALF_FLOOR = 8;
			Decimal$3.clone = clone$1;
			Decimal$3.config = Decimal$3.set = config$1;
			if (obj === void 0) obj = {};
			if (obj) {
				ps = [
					"precision",
					"rounding",
					"toExpNeg",
					"toExpPos",
					"LN10"
				];
				for (i$2 = 0; i$2 < ps.length;) if (!obj.hasOwnProperty(p = ps[i$2++])) obj[p] = this[p];
			}
			Decimal$3.config(obj);
			return Decimal$3;
		}
		function config$1(obj) {
			if (!obj || typeof obj !== "object") throw Error(decimalError + "Object expected");
			var i$2, p, v, ps = [
				"precision",
				1,
				MAX_DIGITS,
				"rounding",
				0,
				8,
				"toExpNeg",
				-Infinity,
				0,
				"toExpPos",
				0,
				Infinity
			];
			for (i$2 = 0; i$2 < ps.length; i$2 += 3) if ((v = obj[p = ps[i$2]]) !== void 0) if (mathfloor(v) === v && v >= ps[i$2 + 1] && v <= ps[i$2 + 2]) this[p] = v;
			else throw Error(invalidArgument + p + ": " + v);
			if ((v = obj[p = "LN10"]) !== void 0) if (v == Math.LN10) this[p] = new this(v);
			else throw Error(invalidArgument + p + ": " + v);
			return this;
		}
		Decimal$2 = clone$1(Decimal$2);
		Decimal$2["default"] = Decimal$2.Decimal = Decimal$2;
		ONE = new Decimal$2(1);
		if (typeof define == "function" && define.amd) define(function() {
			return Decimal$2;
		});
		else if (typeof module != "undefined" && module.exports) module.exports = Decimal$2;
		else {
			if (!globalScope) globalScope = typeof self != "undefined" && self && self.self == self ? self : Function("return this")();
			globalScope.Decimal = Decimal$2;
		}
	})(exports);
}));
function _toConsumableArray$10(arr) {
	return _arrayWithoutHoles$10(arr) || _iterableToArray$11(arr) || _unsupportedIterableToArray$15(arr) || _nonIterableSpread$10();
}
function _nonIterableSpread$10() {
	throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$15(o$1, minLen) {
	if (!o$1) return;
	if (typeof o$1 === "string") return _arrayLikeToArray$15(o$1, minLen);
	var n$1 = Object.prototype.toString.call(o$1).slice(8, -1);
	if (n$1 === "Object" && o$1.constructor) n$1 = o$1.constructor.name;
	if (n$1 === "Map" || n$1 === "Set") return Array.from(o$1);
	if (n$1 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n$1)) return _arrayLikeToArray$15(o$1, minLen);
}
function _iterableToArray$11(iter) {
	if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}
function _arrayWithoutHoles$10(arr) {
	if (Array.isArray(arr)) return _arrayLikeToArray$15(arr);
}
function _arrayLikeToArray$15(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i$2 = 0, arr2 = new Array(len); i$2 < len; i$2++) arr2[i$2] = arr[i$2];
	return arr2;
}
var identity$1 = function identity$11(i$2) {
	return i$2;
};
var PLACE_HOLDER = { "@@functional/placeholder": true };
var isPlaceHolder = function isPlaceHolder$1(val) {
	return val === PLACE_HOLDER;
};
var curry0 = function curry0$1(fn) {
	return function _curried() {
		if (arguments.length === 0 || arguments.length === 1 && isPlaceHolder(arguments.length <= 0 ? void 0 : arguments[0])) return _curried;
		return fn.apply(void 0, arguments);
	};
};
var curryN = function curryN$1(n$1, fn) {
	if (n$1 === 1) return fn;
	return curry0(function() {
		for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
		var argsLength = args.filter(function(arg) {
			return arg !== PLACE_HOLDER;
		}).length;
		if (argsLength >= n$1) return fn.apply(void 0, args);
		return curryN$1(n$1 - argsLength, curry0(function() {
			for (var _len2 = arguments.length, restArgs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) restArgs[_key2] = arguments[_key2];
			var newArgs = args.map(function(arg) {
				return isPlaceHolder(arg) ? restArgs.shift() : arg;
			});
			return fn.apply(void 0, _toConsumableArray$10(newArgs).concat(restArgs));
		}));
	});
};
var curry = function curry$1(fn) {
	return curryN(fn.length, fn);
};
var range$3 = function range$5(begin, end) {
	var arr = [];
	for (var i$2 = begin; i$2 < end; ++i$2) arr[i$2 - begin] = i$2;
	return arr;
};
var map = curry(function(fn, arr) {
	if (Array.isArray(arr)) return arr.map(fn);
	return Object.keys(arr).map(function(key) {
		return arr[key];
	}).map(fn);
});
var compose = function compose$1() {
	for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) args[_key3] = arguments[_key3];
	if (!args.length) return identity$1;
	var fns = args.reverse();
	var firstFn = fns[0];
	var tailsFn = fns.slice(1);
	return function() {
		return tailsFn.reduce(function(res, fn) {
			return fn(res);
		}, firstFn.apply(void 0, arguments));
	};
};
var reverse = function reverse$1(arr) {
	if (Array.isArray(arr)) return arr.reverse();
	return arr.split("").reverse.join("");
};
var memoize$1 = function memoize$4(fn) {
	var lastArgs = null;
	var lastResult$1 = null;
	return function() {
		for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) args[_key4] = arguments[_key4];
		if (lastArgs && args.every(function(val, i$2) {
			return val === lastArgs[i$2];
		})) return lastResult$1;
		lastArgs = args;
		lastResult$1 = fn.apply(void 0, args);
		return lastResult$1;
	};
};
var import_decimal$1 = /* @__PURE__ */ __toESM(require_decimal());
function getDigitCount(value) {
	var result;
	if (value === 0) result = 1;
	else result = Math.floor(new import_decimal$1.default(value).abs().log(10).toNumber()) + 1;
	return result;
}
function rangeStep(start, end, step) {
	var num = new import_decimal$1.default(start);
	var i$2 = 0;
	var result = [];
	while (num.lt(end) && i$2 < 1e5) {
		result.push(num.toNumber());
		num = num.add(step);
		i$2++;
	}
	return result;
}
var arithmetic_default = {
	rangeStep,
	getDigitCount,
	interpolateNumber: curry(function(a$2, b, t$1) {
		var newA = +a$2;
		return newA + t$1 * (+b - newA);
	}),
	uninterpolateNumber: curry(function(a$2, b, x$1) {
		var diff = b - +a$2;
		diff = diff || Infinity;
		return (x$1 - a$2) / diff;
	}),
	uninterpolateTruncation: curry(function(a$2, b, x$1) {
		var diff = b - +a$2;
		diff = diff || Infinity;
		return Math.max(0, Math.min(1, (x$1 - a$2) / diff));
	})
};
var import_decimal = /* @__PURE__ */ __toESM(require_decimal());
function _toConsumableArray$9(arr) {
	return _arrayWithoutHoles$9(arr) || _iterableToArray$10(arr) || _unsupportedIterableToArray$14(arr) || _nonIterableSpread$9();
}
function _nonIterableSpread$9() {
	throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArray$10(iter) {
	if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}
function _arrayWithoutHoles$9(arr) {
	if (Array.isArray(arr)) return _arrayLikeToArray$14(arr);
}
function _slicedToArray$7(arr, i$2) {
	return _arrayWithHoles$8(arr) || _iterableToArrayLimit$7(arr, i$2) || _unsupportedIterableToArray$14(arr, i$2) || _nonIterableRest$8();
}
function _nonIterableRest$8() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$14(o$1, minLen) {
	if (!o$1) return;
	if (typeof o$1 === "string") return _arrayLikeToArray$14(o$1, minLen);
	var n$1 = Object.prototype.toString.call(o$1).slice(8, -1);
	if (n$1 === "Object" && o$1.constructor) n$1 = o$1.constructor.name;
	if (n$1 === "Map" || n$1 === "Set") return Array.from(o$1);
	if (n$1 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n$1)) return _arrayLikeToArray$14(o$1, minLen);
}
function _arrayLikeToArray$14(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i$2 = 0, arr2 = new Array(len); i$2 < len; i$2++) arr2[i$2] = arr[i$2];
	return arr2;
}
function _iterableToArrayLimit$7(arr, i$2) {
	if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
	var _arr = [];
	var _n = true;
	var _d = false;
	var _e = void 0;
	try {
		for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
			_arr.push(_s.value);
			if (i$2 && _arr.length === i$2) break;
		}
	} catch (err) {
		_d = true;
		_e = err;
	} finally {
		try {
			if (!_n && _i["return"] != null) _i["return"]();
		} finally {
			if (_d) throw _e;
		}
	}
	return _arr;
}
function _arrayWithHoles$8(arr) {
	if (Array.isArray(arr)) return arr;
}
function getValidInterval(_ref) {
	var _ref2 = _slicedToArray$7(_ref, 2), min$3 = _ref2[0], max$4 = _ref2[1];
	var validMin = min$3, validMax = max$4;
	if (min$3 > max$4) {
		validMin = max$4;
		validMax = min$3;
	}
	return [validMin, validMax];
}
function getFormatStep(roughStep, allowDecimals, correctionFactor) {
	if (roughStep.lte(0)) return new import_decimal.default(0);
	var digitCount = arithmetic_default.getDigitCount(roughStep.toNumber());
	var digitCountValue = new import_decimal.default(10).pow(digitCount);
	var stepRatio = roughStep.div(digitCountValue);
	var stepRatioScale = digitCount !== 1 ? .05 : .1;
	var formatStep = new import_decimal.default(Math.ceil(stepRatio.div(stepRatioScale).toNumber())).add(correctionFactor).mul(stepRatioScale).mul(digitCountValue);
	return allowDecimals ? formatStep : new import_decimal.default(Math.ceil(formatStep));
}
function getTickOfSingleValue(value, tickCount, allowDecimals) {
	var step = 1;
	var middle = new import_decimal.default(value);
	if (!middle.isint() && allowDecimals) {
		var absVal = Math.abs(value);
		if (absVal < 1) {
			step = new import_decimal.default(10).pow(arithmetic_default.getDigitCount(value) - 1);
			middle = new import_decimal.default(Math.floor(middle.div(step).toNumber())).mul(step);
		} else if (absVal > 1) middle = new import_decimal.default(Math.floor(value));
	} else if (value === 0) middle = new import_decimal.default(Math.floor((tickCount - 1) / 2));
	else if (!allowDecimals) middle = new import_decimal.default(Math.floor(value));
	var middleIndex = Math.floor((tickCount - 1) / 2);
	return compose(map(function(n$1) {
		return middle.add(new import_decimal.default(n$1 - middleIndex).mul(step)).toNumber();
	}), range$3)(0, tickCount);
}
function calculateStep(min$3, max$4, tickCount, allowDecimals) {
	var correctionFactor = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
	if (!Number.isFinite((max$4 - min$3) / (tickCount - 1))) return {
		step: new import_decimal.default(0),
		tickMin: new import_decimal.default(0),
		tickMax: new import_decimal.default(0)
	};
	var step = getFormatStep(new import_decimal.default(max$4).sub(min$3).div(tickCount - 1), allowDecimals, correctionFactor);
	var middle;
	if (min$3 <= 0 && max$4 >= 0) middle = new import_decimal.default(0);
	else {
		middle = new import_decimal.default(min$3).add(max$4).div(2);
		middle = middle.sub(new import_decimal.default(middle).mod(step));
	}
	var belowCount = Math.ceil(middle.sub(min$3).div(step).toNumber());
	var upCount = Math.ceil(new import_decimal.default(max$4).sub(middle).div(step).toNumber());
	var scaleCount = belowCount + upCount + 1;
	if (scaleCount > tickCount) return calculateStep(min$3, max$4, tickCount, allowDecimals, correctionFactor + 1);
	if (scaleCount < tickCount) {
		upCount = max$4 > 0 ? upCount + (tickCount - scaleCount) : upCount;
		belowCount = max$4 > 0 ? belowCount : belowCount + (tickCount - scaleCount);
	}
	return {
		step,
		tickMin: middle.sub(new import_decimal.default(belowCount).mul(step)),
		tickMax: middle.add(new import_decimal.default(upCount).mul(step))
	};
}
function getNiceTickValuesFn(_ref3) {
	var _ref4 = _slicedToArray$7(_ref3, 2), min$3 = _ref4[0], max$4 = _ref4[1];
	var tickCount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 6;
	var allowDecimals = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
	var count = Math.max(tickCount, 2);
	var _getValidInterval2 = _slicedToArray$7(getValidInterval([min$3, max$4]), 2), cormin = _getValidInterval2[0], cormax = _getValidInterval2[1];
	if (cormin === -Infinity || cormax === Infinity) {
		var _values = cormax === Infinity ? [cormin].concat(_toConsumableArray$9(range$3(0, tickCount - 1).map(function() {
			return Infinity;
		}))) : [].concat(_toConsumableArray$9(range$3(0, tickCount - 1).map(function() {
			return -Infinity;
		})), [cormax]);
		return min$3 > max$4 ? reverse(_values) : _values;
	}
	if (cormin === cormax) return getTickOfSingleValue(cormin, tickCount, allowDecimals);
	var _calculateStep = calculateStep(cormin, cormax, count, allowDecimals), step = _calculateStep.step, tickMin = _calculateStep.tickMin, tickMax = _calculateStep.tickMax;
	var values = arithmetic_default.rangeStep(tickMin, tickMax.add(new import_decimal.default(.1).mul(step)), step);
	return min$3 > max$4 ? reverse(values) : values;
}
function getTickValuesFn(_ref5) {
	var _ref6 = _slicedToArray$7(_ref5, 2), min$3 = _ref6[0], max$4 = _ref6[1];
	var tickCount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 6;
	var allowDecimals = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
	var count = Math.max(tickCount, 2);
	var _getValidInterval4 = _slicedToArray$7(getValidInterval([min$3, max$4]), 2), cormin = _getValidInterval4[0], cormax = _getValidInterval4[1];
	if (cormin === -Infinity || cormax === Infinity) return [min$3, max$4];
	if (cormin === cormax) return getTickOfSingleValue(cormin, tickCount, allowDecimals);
	var step = getFormatStep(new import_decimal.default(cormax).sub(cormin).div(count - 1), allowDecimals, 0);
	var values = compose(map(function(n$1) {
		return new import_decimal.default(cormin).add(new import_decimal.default(n$1).mul(step)).toNumber();
	}), range$3)(0, count).filter(function(entry) {
		return entry >= cormin && entry <= cormax;
	});
	return min$3 > max$4 ? reverse(values) : values;
}
function getTickValuesFixedDomainFn(_ref7, tickCount) {
	var _ref8 = _slicedToArray$7(_ref7, 2), min$3 = _ref8[0], max$4 = _ref8[1];
	var allowDecimals = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
	var _getValidInterval6 = _slicedToArray$7(getValidInterval([min$3, max$4]), 2), cormin = _getValidInterval6[0], cormax = _getValidInterval6[1];
	if (cormin === -Infinity || cormax === Infinity) return [min$3, max$4];
	if (cormin === cormax) return [cormin];
	var count = Math.max(tickCount, 2);
	var step = getFormatStep(new import_decimal.default(cormax).sub(cormin).div(count - 1), allowDecimals, 0);
	var values = [].concat(_toConsumableArray$9(arithmetic_default.rangeStep(new import_decimal.default(cormin), new import_decimal.default(cormax).sub(new import_decimal.default(.99).mul(step)), step)), [cormax]);
	return min$3 > max$4 ? reverse(values) : values;
}
var getNiceTickValues = memoize$1(getNiceTickValuesFn);
memoize$1(getTickValuesFn);
var getTickValuesFixedDomain = memoize$1(getTickValuesFixedDomainFn);
var isProduction = false;
var prefix$1 = "Invariant failed";
function invariant(condition, message) {
	if (condition) return;
	if (isProduction) throw new Error(prefix$1);
	var provided = typeof message === "function" ? message() : message;
	var value = provided ? "".concat(prefix$1, ": ").concat(provided) : prefix$1;
	throw new Error(value);
}
var _excluded$12 = [
	"offset",
	"layout",
	"width",
	"dataKey",
	"data",
	"dataPointFormatter",
	"xAxis",
	"yAxis"
];
function _typeof$34(o$1) {
	"@babel/helpers - typeof";
	return _typeof$34 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$2) {
		return typeof o$2;
	} : function(o$2) {
		return o$2 && "function" == typeof Symbol && o$2.constructor === Symbol && o$2 !== Symbol.prototype ? "symbol" : typeof o$2;
	}, _typeof$34(o$1);
}
function _extends$21() {
	_extends$21 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i$2 = 1; i$2 < arguments.length; i$2++) {
			var source = arguments[i$2];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$21.apply(this, arguments);
}
function _slicedToArray$6(arr, i$2) {
	return _arrayWithHoles$7(arr) || _iterableToArrayLimit$6(arr, i$2) || _unsupportedIterableToArray$13(arr, i$2) || _nonIterableRest$7();
}
function _nonIterableRest$7() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$13(o$1, minLen) {
	if (!o$1) return;
	if (typeof o$1 === "string") return _arrayLikeToArray$13(o$1, minLen);
	var n$1 = Object.prototype.toString.call(o$1).slice(8, -1);
	if (n$1 === "Object" && o$1.constructor) n$1 = o$1.constructor.name;
	if (n$1 === "Map" || n$1 === "Set") return Array.from(o$1);
	if (n$1 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n$1)) return _arrayLikeToArray$13(o$1, minLen);
}
function _arrayLikeToArray$13(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i$2 = 0, arr2 = new Array(len); i$2 < len; i$2++) arr2[i$2] = arr[i$2];
	return arr2;
}
function _iterableToArrayLimit$6(r$1, l) {
	var t$1 = null == r$1 ? null : "undefined" != typeof Symbol && r$1[Symbol.iterator] || r$1["@@iterator"];
	if (null != t$1) {
		var e, n$1, i$2, u, a$2 = [], f = !0, o$1 = !1;
		try {
			if (i$2 = (t$1 = t$1.call(r$1)).next, 0 === l) {
				if (Object(t$1) !== t$1) return;
				f = !1;
			} else for (; !(f = (e = i$2.call(t$1)).done) && (a$2.push(e.value), a$2.length !== l); f = !0);
		} catch (r$2) {
			o$1 = !0, n$1 = r$2;
		} finally {
			try {
				if (!f && null != t$1["return"] && (u = t$1["return"](), Object(u) !== u)) return;
			} finally {
				if (o$1) throw n$1;
			}
		}
		return a$2;
	}
}
function _arrayWithHoles$7(arr) {
	if (Array.isArray(arr)) return arr;
}
function _objectWithoutProperties$12(source, excluded) {
	if (source == null) return {};
	var target = _objectWithoutPropertiesLoose$12(source, excluded);
	var key, i$2;
	if (Object.getOwnPropertySymbols) {
		var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
		for (i$2 = 0; i$2 < sourceSymbolKeys.length; i$2++) {
			key = sourceSymbolKeys[i$2];
			if (excluded.indexOf(key) >= 0) continue;
			if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
			target[key] = source[key];
		}
	}
	return target;
}
function _objectWithoutPropertiesLoose$12(source, excluded) {
	if (source == null) return {};
	var target = {};
	for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) {
		if (excluded.indexOf(key) >= 0) continue;
		target[key] = source[key];
	}
	return target;
}
function _classCallCheck$14(instance, Constructor) {
	if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties$14(target, props) {
	for (var i$2 = 0; i$2 < props.length; i$2++) {
		var descriptor = props[i$2];
		descriptor.enumerable = descriptor.enumerable || false;
		descriptor.configurable = true;
		if ("value" in descriptor) descriptor.writable = true;
		Object.defineProperty(target, _toPropertyKey$32(descriptor.key), descriptor);
	}
}
function _createClass$14(Constructor, protoProps, staticProps) {
	if (protoProps) _defineProperties$14(Constructor.prototype, protoProps);
	if (staticProps) _defineProperties$14(Constructor, staticProps);
	Object.defineProperty(Constructor, "prototype", { writable: false });
	return Constructor;
}
function _callSuper$11(t$1, o$1, e) {
	return o$1 = _getPrototypeOf$12(o$1), _possibleConstructorReturn$12(t$1, _isNativeReflectConstruct$12() ? Reflect.construct(o$1, e || [], _getPrototypeOf$12(t$1).constructor) : o$1.apply(t$1, e));
}
function _possibleConstructorReturn$12(self$1, call) {
	if (call && (_typeof$34(call) === "object" || typeof call === "function")) return call;
	else if (call !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
	return _assertThisInitialized$12(self$1);
}
function _assertThisInitialized$12(self$1) {
	if (self$1 === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	return self$1;
}
function _isNativeReflectConstruct$12() {
	try {
		var t$1 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
	} catch (t$2) {}
	return (_isNativeReflectConstruct$12 = function _isNativeReflectConstruct$17() {
		return !!t$1;
	})();
}
function _getPrototypeOf$12(o$1) {
	_getPrototypeOf$12 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf$17(o$2) {
		return o$2.__proto__ || Object.getPrototypeOf(o$2);
	};
	return _getPrototypeOf$12(o$1);
}
function _inherits$12(subClass, superClass) {
	if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
	subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: {
		value: subClass,
		writable: true,
		configurable: true
	} });
	Object.defineProperty(subClass, "prototype", { writable: false });
	if (superClass) _setPrototypeOf$12(subClass, superClass);
}
function _setPrototypeOf$12(o$1, p) {
	_setPrototypeOf$12 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf$17(o$2, p$1) {
		o$2.__proto__ = p$1;
		return o$2;
	};
	return _setPrototypeOf$12(o$1, p);
}
function _defineProperty$32(obj, key, value) {
	key = _toPropertyKey$32(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$32(t$1) {
	var i$2 = _toPrimitive$32(t$1, "string");
	return "symbol" == _typeof$34(i$2) ? i$2 : i$2 + "";
}
function _toPrimitive$32(t$1, r$1) {
	if ("object" != _typeof$34(t$1) || !t$1) return t$1;
	var e = t$1[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i$2 = e.call(t$1, r$1 || "default");
		if ("object" != _typeof$34(i$2)) return i$2;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t$1);
}
var ErrorBar = /* @__PURE__ */ function(_React$Component) {
	function ErrorBar$1() {
		_classCallCheck$14(this, ErrorBar$1);
		return _callSuper$11(this, ErrorBar$1, arguments);
	}
	_inherits$12(ErrorBar$1, _React$Component);
	return _createClass$14(ErrorBar$1, [{
		key: "render",
		value: function render() {
			var _this$props = this.props, offset = _this$props.offset, layout = _this$props.layout, width = _this$props.width, dataKey = _this$props.dataKey, data = _this$props.data, dataPointFormatter = _this$props.dataPointFormatter, xAxis = _this$props.xAxis, yAxis = _this$props.yAxis;
			var svgProps = filterProps(_objectWithoutProperties$12(_this$props, _excluded$12), false);
			this.props.direction === "x" && xAxis.type !== "number" && invariant(false, "ErrorBar requires Axis type property to be \"number\".");
			var errorBars = data.map(function(entry) {
				var _dataPointFormatter = dataPointFormatter(entry, dataKey), x$1 = _dataPointFormatter.x, y$1 = _dataPointFormatter.y, value = _dataPointFormatter.value, errorVal = _dataPointFormatter.errorVal;
				if (!errorVal) return null;
				var lineCoordinates = [];
				var lowBound, highBound;
				if (Array.isArray(errorVal)) {
					var _errorVal = _slicedToArray$6(errorVal, 2);
					lowBound = _errorVal[0];
					highBound = _errorVal[1];
				} else lowBound = highBound = errorVal;
				if (layout === "vertical") {
					var scale = xAxis.scale;
					var yMid = y$1 + offset;
					var yMin = yMid + width;
					var yMax = yMid - width;
					var xMin = scale(value - lowBound);
					var xMax = scale(value + highBound);
					lineCoordinates.push({
						x1: xMax,
						y1: yMin,
						x2: xMax,
						y2: yMax
					});
					lineCoordinates.push({
						x1: xMin,
						y1: yMid,
						x2: xMax,
						y2: yMid
					});
					lineCoordinates.push({
						x1: xMin,
						y1: yMin,
						x2: xMin,
						y2: yMax
					});
				} else if (layout === "horizontal") {
					var _scale = yAxis.scale;
					var xMid = x$1 + offset;
					var _xMin = xMid - width;
					var _xMax = xMid + width;
					var _yMin = _scale(value - lowBound);
					var _yMax = _scale(value + highBound);
					lineCoordinates.push({
						x1: _xMin,
						y1: _yMax,
						x2: _xMax,
						y2: _yMax
					});
					lineCoordinates.push({
						x1: xMid,
						y1: _yMin,
						x2: xMid,
						y2: _yMax
					});
					lineCoordinates.push({
						x1: _xMin,
						y1: _yMin,
						x2: _xMax,
						y2: _yMin
					});
				}
				return /* @__PURE__ */ import_react.createElement(Layer, _extends$21({
					className: "recharts-errorBar",
					key: "bar-".concat(lineCoordinates.map(function(c$1) {
						return "".concat(c$1.x1, "-").concat(c$1.x2, "-").concat(c$1.y1, "-").concat(c$1.y2);
					}))
				}, svgProps), lineCoordinates.map(function(coordinates) {
					return /* @__PURE__ */ import_react.createElement("line", _extends$21({}, coordinates, { key: "line-".concat(coordinates.x1, "-").concat(coordinates.x2, "-").concat(coordinates.y1, "-").concat(coordinates.y2) }));
				}));
			});
			return /* @__PURE__ */ import_react.createElement(Layer, { className: "recharts-errorBars" }, errorBars);
		}
	}]);
}(import_react.Component);
_defineProperty$32(ErrorBar, "defaultProps", {
	stroke: "black",
	strokeWidth: 1.5,
	width: 5,
	offset: 0,
	layout: "horizontal"
});
_defineProperty$32(ErrorBar, "displayName", "ErrorBar");
function _typeof$33(o$1) {
	"@babel/helpers - typeof";
	return _typeof$33 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$2) {
		return typeof o$2;
	} : function(o$2) {
		return o$2 && "function" == typeof Symbol && o$2.constructor === Symbol && o$2 !== Symbol.prototype ? "symbol" : typeof o$2;
	}, _typeof$33(o$1);
}
function ownKeys$28(e, r$1) {
	var t$1 = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o$1 = Object.getOwnPropertySymbols(e);
		r$1 && (o$1 = o$1.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t$1.push.apply(t$1, o$1);
	}
	return t$1;
}
function _objectSpread$28(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t$1 = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$28(Object(t$1), !0).forEach(function(r$2) {
			_defineProperty$31(e, r$2, t$1[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t$1)) : ownKeys$28(Object(t$1)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t$1, r$2));
		});
	}
	return e;
}
function _defineProperty$31(obj, key, value) {
	key = _toPropertyKey$31(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$31(t$1) {
	var i$2 = _toPrimitive$31(t$1, "string");
	return "symbol" == _typeof$33(i$2) ? i$2 : i$2 + "";
}
function _toPrimitive$31(t$1, r$1) {
	if ("object" != _typeof$33(t$1) || !t$1) return t$1;
	var e = t$1[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i$2 = e.call(t$1, r$1 || "default");
		if ("object" != _typeof$33(i$2)) return i$2;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t$1);
}
var getLegendProps = function getLegendProps$1(_ref) {
	var children = _ref.children, formattedGraphicalItems = _ref.formattedGraphicalItems, legendWidth = _ref.legendWidth, legendContent = _ref.legendContent;
	var legendItem = findChildByType(children, Legend);
	if (!legendItem) return null;
	var legendDefaultProps = Legend.defaultProps;
	var legendProps = legendDefaultProps !== void 0 ? _objectSpread$28(_objectSpread$28({}, legendDefaultProps), legendItem.props) : {};
	var legendData;
	if (legendItem.props && legendItem.props.payload) legendData = legendItem.props && legendItem.props.payload;
	else if (legendContent === "children") legendData = (formattedGraphicalItems || []).reduce(function(result, _ref2) {
		var item = _ref2.item, props = _ref2.props;
		var data = props.sectors || props.data || [];
		return result.concat(data.map(function(entry) {
			return {
				type: legendItem.props.iconType || item.props.legendType,
				value: entry.name,
				color: entry.fill,
				payload: entry
			};
		}));
	}, []);
	else legendData = (formattedGraphicalItems || []).map(function(_ref3) {
		var item = _ref3.item;
		var itemDefaultProps = item.type.defaultProps;
		var itemProps = itemDefaultProps !== void 0 ? _objectSpread$28(_objectSpread$28({}, itemDefaultProps), item.props) : {};
		var dataKey = itemProps.dataKey, name = itemProps.name, legendType = itemProps.legendType;
		return {
			inactive: itemProps.hide,
			dataKey,
			type: legendProps.iconType || legendType || "square",
			color: getMainColorOfGraphicItem(item),
			value: name || dataKey,
			payload: itemProps
		};
	});
	return _objectSpread$28(_objectSpread$28(_objectSpread$28({}, legendProps), Legend.getWithHeight(legendItem, legendWidth)), {}, {
		payload: legendData,
		item: legendItem
	});
};
var import_max$1 = /* @__PURE__ */ __toESM(require_max());
var import_min = /* @__PURE__ */ __toESM(require_min());
var import_isNil$7 = /* @__PURE__ */ __toESM(require_isNil());
var import_isFunction$15 = /* @__PURE__ */ __toESM(require_isFunction());
var import_isString = /* @__PURE__ */ __toESM(require_isString());
var import_get$2 = /* @__PURE__ */ __toESM(require_get());
var import_flatMap = /* @__PURE__ */ __toESM(require_flatMap());
var import_isNaN$1 = /* @__PURE__ */ __toESM(require_isNaN());
var import_upperFirst$1 = /* @__PURE__ */ __toESM(require_upperFirst());
var import_isEqual$4 = /* @__PURE__ */ __toESM(require_isEqual());
var import_sortBy$1 = /* @__PURE__ */ __toESM(require_sortBy());
function _typeof$32(o$1) {
	"@babel/helpers - typeof";
	return _typeof$32 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$2) {
		return typeof o$2;
	} : function(o$2) {
		return o$2 && "function" == typeof Symbol && o$2.constructor === Symbol && o$2 !== Symbol.prototype ? "symbol" : typeof o$2;
	}, _typeof$32(o$1);
}
function _toConsumableArray$8(arr) {
	return _arrayWithoutHoles$8(arr) || _iterableToArray$9(arr) || _unsupportedIterableToArray$12(arr) || _nonIterableSpread$8();
}
function _nonIterableSpread$8() {
	throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$12(o$1, minLen) {
	if (!o$1) return;
	if (typeof o$1 === "string") return _arrayLikeToArray$12(o$1, minLen);
	var n$1 = Object.prototype.toString.call(o$1).slice(8, -1);
	if (n$1 === "Object" && o$1.constructor) n$1 = o$1.constructor.name;
	if (n$1 === "Map" || n$1 === "Set") return Array.from(o$1);
	if (n$1 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n$1)) return _arrayLikeToArray$12(o$1, minLen);
}
function _iterableToArray$9(iter) {
	if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles$8(arr) {
	if (Array.isArray(arr)) return _arrayLikeToArray$12(arr);
}
function _arrayLikeToArray$12(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i$2 = 0, arr2 = new Array(len); i$2 < len; i$2++) arr2[i$2] = arr[i$2];
	return arr2;
}
function ownKeys$27(e, r$1) {
	var t$1 = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o$1 = Object.getOwnPropertySymbols(e);
		r$1 && (o$1 = o$1.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t$1.push.apply(t$1, o$1);
	}
	return t$1;
}
function _objectSpread$27(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t$1 = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$27(Object(t$1), !0).forEach(function(r$2) {
			_defineProperty$30(e, r$2, t$1[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t$1)) : ownKeys$27(Object(t$1)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t$1, r$2));
		});
	}
	return e;
}
function _defineProperty$30(obj, key, value) {
	key = _toPropertyKey$30(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$30(t$1) {
	var i$2 = _toPrimitive$30(t$1, "string");
	return "symbol" == _typeof$32(i$2) ? i$2 : i$2 + "";
}
function _toPrimitive$30(t$1, r$1) {
	if ("object" != _typeof$32(t$1) || !t$1) return t$1;
	var e = t$1[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i$2 = e.call(t$1, r$1 || "default");
		if ("object" != _typeof$32(i$2)) return i$2;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t$1);
}
function getValueByDataKey(obj, dataKey, defaultValue) {
	if ((0, import_isNil$7.default)(obj) || (0, import_isNil$7.default)(dataKey)) return defaultValue;
	if (isNumOrStr(dataKey)) return (0, import_get$2.default)(obj, dataKey, defaultValue);
	if ((0, import_isFunction$15.default)(dataKey)) return dataKey(obj);
	return defaultValue;
}
function getDomainOfDataByKey(data, key, type, filterNil) {
	var flattenData = (0, import_flatMap.default)(data, function(entry) {
		return getValueByDataKey(entry, key);
	});
	if (type === "number") {
		var domain = flattenData.filter(function(entry) {
			return isNumber(entry) || parseFloat(entry);
		});
		return domain.length ? [(0, import_min.default)(domain), (0, import_max$1.default)(domain)] : [Infinity, -Infinity];
	}
	return (filterNil ? flattenData.filter(function(entry) {
		return !(0, import_isNil$7.default)(entry);
	}) : flattenData).map(function(entry) {
		return isNumOrStr(entry) || entry instanceof Date ? entry : "";
	});
}
var calculateActiveTickIndex = function calculateActiveTickIndex$1(coordinate) {
	var _ticks$length;
	var ticks$1 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
	var unsortedTicks = arguments.length > 2 ? arguments[2] : void 0;
	var axis = arguments.length > 3 ? arguments[3] : void 0;
	var index = -1;
	var len = (_ticks$length = ticks$1 === null || ticks$1 === void 0 ? void 0 : ticks$1.length) !== null && _ticks$length !== void 0 ? _ticks$length : 0;
	if (len <= 1) return 0;
	if (axis && axis.axisType === "angleAxis" && Math.abs(Math.abs(axis.range[1] - axis.range[0]) - 360) <= 1e-6) {
		var range$5 = axis.range;
		for (var i$2 = 0; i$2 < len; i$2++) {
			var before = i$2 > 0 ? unsortedTicks[i$2 - 1].coordinate : unsortedTicks[len - 1].coordinate;
			var cur = unsortedTicks[i$2].coordinate;
			var after = i$2 >= len - 1 ? unsortedTicks[0].coordinate : unsortedTicks[i$2 + 1].coordinate;
			var sameDirectionCoord = void 0;
			if (mathSign(cur - before) !== mathSign(after - cur)) {
				var diffInterval = [];
				if (mathSign(after - cur) === mathSign(range$5[1] - range$5[0])) {
					sameDirectionCoord = after;
					var curInRange = cur + range$5[1] - range$5[0];
					diffInterval[0] = Math.min(curInRange, (curInRange + before) / 2);
					diffInterval[1] = Math.max(curInRange, (curInRange + before) / 2);
				} else {
					sameDirectionCoord = before;
					var afterInRange = after + range$5[1] - range$5[0];
					diffInterval[0] = Math.min(cur, (afterInRange + cur) / 2);
					diffInterval[1] = Math.max(cur, (afterInRange + cur) / 2);
				}
				var sameInterval = [Math.min(cur, (sameDirectionCoord + cur) / 2), Math.max(cur, (sameDirectionCoord + cur) / 2)];
				if (coordinate > sameInterval[0] && coordinate <= sameInterval[1] || coordinate >= diffInterval[0] && coordinate <= diffInterval[1]) {
					index = unsortedTicks[i$2].index;
					break;
				}
			} else {
				var minValue = Math.min(before, after);
				var maxValue = Math.max(before, after);
				if (coordinate > (minValue + cur) / 2 && coordinate <= (maxValue + cur) / 2) {
					index = unsortedTicks[i$2].index;
					break;
				}
			}
		}
	} else for (var _i = 0; _i < len; _i++) if (_i === 0 && coordinate <= (ticks$1[_i].coordinate + ticks$1[_i + 1].coordinate) / 2 || _i > 0 && _i < len - 1 && coordinate > (ticks$1[_i].coordinate + ticks$1[_i - 1].coordinate) / 2 && coordinate <= (ticks$1[_i].coordinate + ticks$1[_i + 1].coordinate) / 2 || _i === len - 1 && coordinate > (ticks$1[_i].coordinate + ticks$1[_i - 1].coordinate) / 2) {
		index = ticks$1[_i].index;
		break;
	}
	return index;
};
var getMainColorOfGraphicItem = function getMainColorOfGraphicItem$1(item) {
	var _item$type;
	var displayName = item.type.displayName;
	var defaultedProps = (_item$type = item.type) !== null && _item$type !== void 0 && _item$type.defaultProps ? _objectSpread$27(_objectSpread$27({}, item.type.defaultProps), item.props) : item.props;
	var stroke = defaultedProps.stroke, fill = defaultedProps.fill;
	var result;
	switch (displayName) {
		case "Line":
			result = stroke;
			break;
		case "Area":
		case "Radar":
			result = stroke && stroke !== "none" ? stroke : fill;
			break;
		default:
			result = fill;
			break;
	}
	return result;
};
var getBarSizeList = function getBarSizeList$1(_ref2) {
	var globalSize = _ref2.barSize, totalSize = _ref2.totalSize, _ref2$stackGroups = _ref2.stackGroups, stackGroups = _ref2$stackGroups === void 0 ? {} : _ref2$stackGroups;
	if (!stackGroups) return {};
	var result = {};
	var numericAxisIds = Object.keys(stackGroups);
	for (var i$2 = 0, len = numericAxisIds.length; i$2 < len; i$2++) {
		var sgs = stackGroups[numericAxisIds[i$2]].stackGroups;
		var stackIds = Object.keys(sgs);
		for (var j = 0, sLen = stackIds.length; j < sLen; j++) {
			var _sgs$stackIds$j = sgs[stackIds[j]], items = _sgs$stackIds$j.items, cateAxisId = _sgs$stackIds$j.cateAxisId;
			var barItems = items.filter(function(item) {
				return getDisplayName(item.type).indexOf("Bar") >= 0;
			});
			if (barItems && barItems.length) {
				var barItemDefaultProps = barItems[0].type.defaultProps;
				var barItemProps = barItemDefaultProps !== void 0 ? _objectSpread$27(_objectSpread$27({}, barItemDefaultProps), barItems[0].props) : barItems[0].props;
				var selfSize = barItemProps.barSize;
				var cateId = barItemProps[cateAxisId];
				if (!result[cateId]) result[cateId] = [];
				var barSize = (0, import_isNil$7.default)(selfSize) ? globalSize : selfSize;
				result[cateId].push({
					item: barItems[0],
					stackList: barItems.slice(1),
					barSize: (0, import_isNil$7.default)(barSize) ? void 0 : getPercentValue(barSize, totalSize, 0)
				});
			}
		}
	}
	return result;
};
var getBarPosition = function getBarPosition$1(_ref3) {
	var barGap = _ref3.barGap, barCategoryGap = _ref3.barCategoryGap, bandSize = _ref3.bandSize, _ref3$sizeList = _ref3.sizeList, sizeList = _ref3$sizeList === void 0 ? [] : _ref3$sizeList, maxBarSize = _ref3.maxBarSize;
	var len = sizeList.length;
	if (len < 1) return null;
	var realBarGap = getPercentValue(barGap, bandSize, 0, true);
	var result;
	var initialValue = [];
	if (sizeList[0].barSize === +sizeList[0].barSize) {
		var useFull = false;
		var fullBarSize = bandSize / len;
		var sum = sizeList.reduce(function(res, entry) {
			return res + entry.barSize || 0;
		}, 0);
		sum += (len - 1) * realBarGap;
		if (sum >= bandSize) {
			sum -= (len - 1) * realBarGap;
			realBarGap = 0;
		}
		if (sum >= bandSize && fullBarSize > 0) {
			useFull = true;
			fullBarSize *= .9;
			sum = len * fullBarSize;
		}
		var prev = {
			offset: ((bandSize - sum) / 2 >> 0) - realBarGap,
			size: 0
		};
		result = sizeList.reduce(function(res, entry) {
			var newPosition = {
				item: entry.item,
				position: {
					offset: prev.offset + prev.size + realBarGap,
					size: useFull ? fullBarSize : entry.barSize
				}
			};
			var newRes = [].concat(_toConsumableArray$8(res), [newPosition]);
			prev = newRes[newRes.length - 1].position;
			if (entry.stackList && entry.stackList.length) entry.stackList.forEach(function(item) {
				newRes.push({
					item,
					position: prev
				});
			});
			return newRes;
		}, initialValue);
	} else {
		var _offset = getPercentValue(barCategoryGap, bandSize, 0, true);
		if (bandSize - 2 * _offset - (len - 1) * realBarGap <= 0) realBarGap = 0;
		var originalSize = (bandSize - 2 * _offset - (len - 1) * realBarGap) / len;
		if (originalSize > 1) originalSize >>= 0;
		var size = maxBarSize === +maxBarSize ? Math.min(originalSize, maxBarSize) : originalSize;
		result = sizeList.reduce(function(res, entry, i$2) {
			var newRes = [].concat(_toConsumableArray$8(res), [{
				item: entry.item,
				position: {
					offset: _offset + (originalSize + realBarGap) * i$2 + (originalSize - size) / 2,
					size
				}
			}]);
			if (entry.stackList && entry.stackList.length) entry.stackList.forEach(function(item) {
				newRes.push({
					item,
					position: newRes[newRes.length - 1].position
				});
			});
			return newRes;
		}, initialValue);
	}
	return result;
};
var appendOffsetOfLegend = function appendOffsetOfLegend$1(offset, _unused, props, legendBox) {
	var children = props.children, width = props.width, margin = props.margin;
	var legendProps = getLegendProps({
		children,
		legendWidth: width - (margin.left || 0) - (margin.right || 0)
	});
	if (legendProps) {
		var _ref4 = legendBox || {}, boxWidth = _ref4.width, boxHeight = _ref4.height;
		var align = legendProps.align, verticalAlign = legendProps.verticalAlign, layout = legendProps.layout;
		if ((layout === "vertical" || layout === "horizontal" && verticalAlign === "middle") && align !== "center" && isNumber(offset[align])) return _objectSpread$27(_objectSpread$27({}, offset), {}, _defineProperty$30({}, align, offset[align] + (boxWidth || 0)));
		if ((layout === "horizontal" || layout === "vertical" && align === "center") && verticalAlign !== "middle" && isNumber(offset[verticalAlign])) return _objectSpread$27(_objectSpread$27({}, offset), {}, _defineProperty$30({}, verticalAlign, offset[verticalAlign] + (boxHeight || 0)));
	}
	return offset;
};
var isErrorBarRelevantForAxis = function isErrorBarRelevantForAxis$1(layout, axisType, direction) {
	if ((0, import_isNil$7.default)(axisType)) return true;
	if (layout === "horizontal") return axisType === "yAxis";
	if (layout === "vertical") return axisType === "xAxis";
	if (direction === "x") return axisType === "xAxis";
	if (direction === "y") return axisType === "yAxis";
	return true;
};
var getDomainOfErrorBars = function getDomainOfErrorBars$1(data, item, dataKey, layout, axisType) {
	var children = item.props.children;
	var errorBars = findAllByType(children, ErrorBar).filter(function(errorBarChild) {
		return isErrorBarRelevantForAxis(layout, axisType, errorBarChild.props.direction);
	});
	if (errorBars && errorBars.length) {
		var keys$6 = errorBars.map(function(errorBarChild) {
			return errorBarChild.props.dataKey;
		});
		return data.reduce(function(result, entry) {
			var entryValue = getValueByDataKey(entry, dataKey);
			if ((0, import_isNil$7.default)(entryValue)) return result;
			var mainValue = Array.isArray(entryValue) ? [(0, import_min.default)(entryValue), (0, import_max$1.default)(entryValue)] : [entryValue, entryValue];
			var errorDomain = keys$6.reduce(function(prevErrorArr, k$1) {
				var errorValue = getValueByDataKey(entry, k$1, 0);
				var lowerValue = mainValue[0] - Math.abs(Array.isArray(errorValue) ? errorValue[0] : errorValue);
				var upperValue = mainValue[1] + Math.abs(Array.isArray(errorValue) ? errorValue[1] : errorValue);
				return [Math.min(lowerValue, prevErrorArr[0]), Math.max(upperValue, prevErrorArr[1])];
			}, [Infinity, -Infinity]);
			return [Math.min(errorDomain[0], result[0]), Math.max(errorDomain[1], result[1])];
		}, [Infinity, -Infinity]);
	}
	return null;
};
var parseErrorBarsOfAxis = function parseErrorBarsOfAxis$1(data, items, dataKey, axisType, layout) {
	var domains = items.map(function(item) {
		return getDomainOfErrorBars(data, item, dataKey, layout, axisType);
	}).filter(function(entry) {
		return !(0, import_isNil$7.default)(entry);
	});
	if (domains && domains.length) return domains.reduce(function(result, entry) {
		return [Math.min(result[0], entry[0]), Math.max(result[1], entry[1])];
	}, [Infinity, -Infinity]);
	return null;
};
var getDomainOfItemsWithSameAxis = function getDomainOfItemsWithSameAxis$1(data, items, type, layout, filterNil) {
	var domains = items.map(function(item) {
		var dataKey = item.props.dataKey;
		if (type === "number" && dataKey) return getDomainOfErrorBars(data, item, dataKey, layout) || getDomainOfDataByKey(data, dataKey, type, filterNil);
		return getDomainOfDataByKey(data, dataKey, type, filterNil);
	});
	if (type === "number") return domains.reduce(function(result, entry) {
		return [Math.min(result[0], entry[0]), Math.max(result[1], entry[1])];
	}, [Infinity, -Infinity]);
	var tag = {};
	return domains.reduce(function(result, entry) {
		for (var i$2 = 0, len = entry.length; i$2 < len; i$2++) if (!tag[entry[i$2]]) {
			tag[entry[i$2]] = true;
			result.push(entry[i$2]);
		}
		return result;
	}, []);
};
var isCategoricalAxis = function isCategoricalAxis$1(layout, axisType) {
	return layout === "horizontal" && axisType === "xAxis" || layout === "vertical" && axisType === "yAxis" || layout === "centric" && axisType === "angleAxis" || layout === "radial" && axisType === "radiusAxis";
};
var getCoordinatesOfGrid = function getCoordinatesOfGrid$1(ticks$1, minValue, maxValue, syncWithTicks) {
	if (syncWithTicks) return ticks$1.map(function(entry) {
		return entry.coordinate;
	});
	var hasMin, hasMax;
	var values = ticks$1.map(function(entry) {
		if (entry.coordinate === minValue) hasMin = true;
		if (entry.coordinate === maxValue) hasMax = true;
		return entry.coordinate;
	});
	if (!hasMin) values.push(minValue);
	if (!hasMax) values.push(maxValue);
	return values;
};
var getTicksOfAxis = function getTicksOfAxis$1(axis, isGrid, isAll) {
	if (!axis) return null;
	var scale = axis.scale;
	var duplicateDomain = axis.duplicateDomain, type = axis.type, range$5 = axis.range;
	var offsetForBand = axis.realScaleType === "scaleBand" ? scale.bandwidth() / 2 : 2;
	var offset = (isGrid || isAll) && type === "category" && scale.bandwidth ? scale.bandwidth() / offsetForBand : 0;
	offset = axis.axisType === "angleAxis" && (range$5 === null || range$5 === void 0 ? void 0 : range$5.length) >= 2 ? mathSign(range$5[0] - range$5[1]) * 2 * offset : offset;
	if (isGrid && (axis.ticks || axis.niceTicks)) return (axis.ticks || axis.niceTicks).map(function(entry) {
		return {
			coordinate: scale(duplicateDomain ? duplicateDomain.indexOf(entry) : entry) + offset,
			value: entry,
			offset
		};
	}).filter(function(row) {
		return !(0, import_isNaN$1.default)(row.coordinate);
	});
	if (axis.isCategorical && axis.categoricalDomain) return axis.categoricalDomain.map(function(entry, index) {
		return {
			coordinate: scale(entry) + offset,
			value: entry,
			index,
			offset
		};
	});
	if (scale.ticks && !isAll) return scale.ticks(axis.tickCount).map(function(entry) {
		return {
			coordinate: scale(entry) + offset,
			value: entry,
			offset
		};
	});
	return scale.domain().map(function(entry, index) {
		return {
			coordinate: scale(entry) + offset,
			value: duplicateDomain ? duplicateDomain[entry] : entry,
			index,
			offset
		};
	});
};
var handlerWeakMap = /* @__PURE__ */ new WeakMap();
var combineEventHandlers = function combineEventHandlers$1(defaultHandler, childHandler) {
	if (typeof childHandler !== "function") return defaultHandler;
	if (!handlerWeakMap.has(defaultHandler)) handlerWeakMap.set(defaultHandler, /* @__PURE__ */ new WeakMap());
	var childWeakMap = handlerWeakMap.get(defaultHandler);
	if (childWeakMap.has(childHandler)) return childWeakMap.get(childHandler);
	var combineHandler = function combineHandler$1() {
		defaultHandler.apply(void 0, arguments);
		childHandler.apply(void 0, arguments);
	};
	childWeakMap.set(childHandler, combineHandler);
	return combineHandler;
};
var parseScale = function parseScale$1(axis, chartType, hasBar) {
	var scale = axis.scale, type = axis.type, layout = axis.layout, axisType = axis.axisType;
	if (scale === "auto") {
		if (layout === "radial" && axisType === "radiusAxis") return {
			scale: band(),
			realScaleType: "band"
		};
		if (layout === "radial" && axisType === "angleAxis") return {
			scale: linear(),
			realScaleType: "linear"
		};
		if (type === "category" && chartType && (chartType.indexOf("LineChart") >= 0 || chartType.indexOf("AreaChart") >= 0 || chartType.indexOf("ComposedChart") >= 0 && !hasBar)) return {
			scale: point(),
			realScaleType: "point"
		};
		if (type === "category") return {
			scale: band(),
			realScaleType: "band"
		};
		return {
			scale: linear(),
			realScaleType: "linear"
		};
	}
	if ((0, import_isString.default)(scale)) {
		var name = "scale".concat((0, import_upperFirst$1.default)(scale));
		return {
			scale: (d3_scale_exports[name] || point)(),
			realScaleType: d3_scale_exports[name] ? name : "point"
		};
	}
	return (0, import_isFunction$15.default)(scale) ? { scale } : {
		scale: point(),
		realScaleType: "point"
	};
};
var EPS = 1e-4;
var checkDomainOfScale = function checkDomainOfScale$1(scale) {
	var domain = scale.domain();
	if (!domain || domain.length <= 2) return;
	var len = domain.length;
	var range$5 = scale.range();
	var minValue = Math.min(range$5[0], range$5[1]) - EPS;
	var maxValue = Math.max(range$5[0], range$5[1]) + EPS;
	var first = scale(domain[0]);
	var last$2 = scale(domain[len - 1]);
	if (first < minValue || first > maxValue || last$2 < minValue || last$2 > maxValue) scale.domain([domain[0], domain[len - 1]]);
};
var findPositionOfBar = function findPositionOfBar$1(barPosition, child) {
	if (!barPosition) return null;
	for (var i$2 = 0, len = barPosition.length; i$2 < len; i$2++) if (barPosition[i$2].item === child) return barPosition[i$2].position;
	return null;
};
var truncateByDomain = function truncateByDomain$1(value, domain) {
	if (!domain || domain.length !== 2 || !isNumber(domain[0]) || !isNumber(domain[1])) return value;
	var minValue = Math.min(domain[0], domain[1]);
	var maxValue = Math.max(domain[0], domain[1]);
	var result = [value[0], value[1]];
	if (!isNumber(value[0]) || value[0] < minValue) result[0] = minValue;
	if (!isNumber(value[1]) || value[1] > maxValue) result[1] = maxValue;
	if (result[0] > maxValue) result[0] = maxValue;
	if (result[1] < minValue) result[1] = minValue;
	return result;
};
var STACK_OFFSET_MAP = {
	sign: function offsetSign$1(series) {
		var n$1 = series.length;
		if (n$1 <= 0) return;
		for (var j = 0, m = series[0].length; j < m; ++j) {
			var positive = 0;
			var negative = 0;
			for (var i$2 = 0; i$2 < n$1; ++i$2) {
				var value = (0, import_isNaN$1.default)(series[i$2][j][1]) ? series[i$2][j][0] : series[i$2][j][1];
				if (value >= 0) {
					series[i$2][j][0] = positive;
					series[i$2][j][1] = positive + value;
					positive = series[i$2][j][1];
				} else {
					series[i$2][j][0] = negative;
					series[i$2][j][1] = negative + value;
					negative = series[i$2][j][1];
				}
			}
		}
	},
	expand: expand_default,
	none: none_default,
	silhouette: silhouette_default,
	wiggle: wiggle_default,
	positive: function offsetPositive$1(series) {
		var n$1 = series.length;
		if (n$1 <= 0) return;
		for (var j = 0, m = series[0].length; j < m; ++j) {
			var positive = 0;
			for (var i$2 = 0; i$2 < n$1; ++i$2) {
				var value = (0, import_isNaN$1.default)(series[i$2][j][1]) ? series[i$2][j][0] : series[i$2][j][1];
				if (value >= 0) {
					series[i$2][j][0] = positive;
					series[i$2][j][1] = positive + value;
					positive = series[i$2][j][1];
				} else {
					series[i$2][j][0] = 0;
					series[i$2][j][1] = 0;
				}
			}
		}
	}
};
var getStackedData = function getStackedData$1(data, stackItems, offsetType) {
	var dataKeys = stackItems.map(function(item) {
		return item.props.dataKey;
	});
	var offsetAccessor = STACK_OFFSET_MAP[offsetType];
	return stack_default().keys(dataKeys).value(function(d, key) {
		return +getValueByDataKey(d, key, 0);
	}).order(none_default$1).offset(offsetAccessor)(data);
};
var getStackGroupsByAxisId = function getStackGroupsByAxisId$1(data, _items, numericAxisId, cateAxisId, offsetType, reverseStackOrder) {
	if (!data) return null;
	var stackGroups = (reverseStackOrder ? _items.reverse() : _items).reduce(function(result, item) {
		var _item$type2;
		var defaultedProps = (_item$type2 = item.type) !== null && _item$type2 !== void 0 && _item$type2.defaultProps ? _objectSpread$27(_objectSpread$27({}, item.type.defaultProps), item.props) : item.props;
		var stackId = defaultedProps.stackId;
		if (defaultedProps.hide) return result;
		var axisId = defaultedProps[numericAxisId];
		var parentGroup = result[axisId] || {
			hasStack: false,
			stackGroups: {}
		};
		if (isNumOrStr(stackId)) {
			var childGroup = parentGroup.stackGroups[stackId] || {
				numericAxisId,
				cateAxisId,
				items: []
			};
			childGroup.items.push(item);
			parentGroup.hasStack = true;
			parentGroup.stackGroups[stackId] = childGroup;
		} else parentGroup.stackGroups[uniqueId("_stackId_")] = {
			numericAxisId,
			cateAxisId,
			items: [item]
		};
		return _objectSpread$27(_objectSpread$27({}, result), {}, _defineProperty$30({}, axisId, parentGroup));
	}, {});
	return Object.keys(stackGroups).reduce(function(result, axisId) {
		var group = stackGroups[axisId];
		if (group.hasStack) group.stackGroups = Object.keys(group.stackGroups).reduce(function(res, stackId) {
			var g = group.stackGroups[stackId];
			return _objectSpread$27(_objectSpread$27({}, res), {}, _defineProperty$30({}, stackId, {
				numericAxisId,
				cateAxisId,
				items: g.items,
				stackedData: getStackedData(data, g.items, offsetType)
			}));
		}, {});
		return _objectSpread$27(_objectSpread$27({}, result), {}, _defineProperty$30({}, axisId, group));
	}, {});
};
var getTicksOfScale = function getTicksOfScale$1(scale, opts) {
	var realScaleType = opts.realScaleType, type = opts.type, tickCount = opts.tickCount, originalDomain = opts.originalDomain, allowDecimals = opts.allowDecimals;
	var scaleType = realScaleType || opts.scale;
	if (scaleType !== "auto" && scaleType !== "linear") return null;
	if (tickCount && type === "number" && originalDomain && (originalDomain[0] === "auto" || originalDomain[1] === "auto")) {
		var domain = scale.domain();
		if (!domain.length) return null;
		var tickValues = getNiceTickValues(domain, tickCount, allowDecimals);
		scale.domain([(0, import_min.default)(tickValues), (0, import_max$1.default)(tickValues)]);
		return { niceTicks: tickValues };
	}
	if (tickCount && type === "number") return { niceTicks: getTickValuesFixedDomain(scale.domain(), tickCount, allowDecimals) };
	return null;
};
function getCateCoordinateOfLine(_ref5) {
	var axis = _ref5.axis, ticks$1 = _ref5.ticks, bandSize = _ref5.bandSize, entry = _ref5.entry, index = _ref5.index, dataKey = _ref5.dataKey;
	if (axis.type === "category") {
		if (!axis.allowDuplicatedCategory && axis.dataKey && !(0, import_isNil$7.default)(entry[axis.dataKey])) {
			var matchedTick = findEntryInArray(ticks$1, "value", entry[axis.dataKey]);
			if (matchedTick) return matchedTick.coordinate + bandSize / 2;
		}
		return ticks$1[index] ? ticks$1[index].coordinate + bandSize / 2 : null;
	}
	var value = getValueByDataKey(entry, !(0, import_isNil$7.default)(dataKey) ? dataKey : axis.dataKey);
	return !(0, import_isNil$7.default)(value) ? axis.scale(value) : null;
}
var getCateCoordinateOfBar = function getCateCoordinateOfBar$1(_ref6) {
	var axis = _ref6.axis, ticks$1 = _ref6.ticks, offset = _ref6.offset, bandSize = _ref6.bandSize, entry = _ref6.entry, index = _ref6.index;
	if (axis.type === "category") return ticks$1[index] ? ticks$1[index].coordinate + offset : null;
	var value = getValueByDataKey(entry, axis.dataKey, axis.domain[index]);
	return !(0, import_isNil$7.default)(value) ? axis.scale(value) - bandSize / 2 + offset : null;
};
var getBaseValueOfBar = function getBaseValueOfBar$1(_ref7) {
	var numericAxis = _ref7.numericAxis;
	var domain = numericAxis.scale.domain();
	if (numericAxis.type === "number") {
		var minValue = Math.min(domain[0], domain[1]);
		var maxValue = Math.max(domain[0], domain[1]);
		if (minValue <= 0 && maxValue >= 0) return 0;
		if (maxValue < 0) return maxValue;
		return minValue;
	}
	return domain[0];
};
var getStackedDataOfItem = function getStackedDataOfItem$1(item, stackGroups) {
	var _item$type3;
	var stackId = ((_item$type3 = item.type) !== null && _item$type3 !== void 0 && _item$type3.defaultProps ? _objectSpread$27(_objectSpread$27({}, item.type.defaultProps), item.props) : item.props).stackId;
	if (isNumOrStr(stackId)) {
		var group = stackGroups[stackId];
		if (group) {
			var itemIndex = group.items.indexOf(item);
			return itemIndex >= 0 ? group.stackedData[itemIndex] : null;
		}
	}
	return null;
};
var getDomainOfSingle = function getDomainOfSingle$1(data) {
	return data.reduce(function(result, entry) {
		return [(0, import_min.default)(entry.concat([result[0]]).filter(isNumber)), (0, import_max$1.default)(entry.concat([result[1]]).filter(isNumber))];
	}, [Infinity, -Infinity]);
};
var getDomainOfStackGroups = function getDomainOfStackGroups$1(stackGroups, startIndex, endIndex) {
	return Object.keys(stackGroups).reduce(function(result, stackId) {
		var domain = stackGroups[stackId].stackedData.reduce(function(res, entry) {
			var s$3 = getDomainOfSingle(entry.slice(startIndex, endIndex + 1));
			return [Math.min(res[0], s$3[0]), Math.max(res[1], s$3[1])];
		}, [Infinity, -Infinity]);
		return [Math.min(domain[0], result[0]), Math.max(domain[1], result[1])];
	}, [Infinity, -Infinity]).map(function(result) {
		return result === Infinity || result === -Infinity ? 0 : result;
	});
};
var MIN_VALUE_REG = /^dataMin[\s]*-[\s]*([0-9]+([.]{1}[0-9]+){0,1})$/;
var MAX_VALUE_REG = /^dataMax[\s]*\+[\s]*([0-9]+([.]{1}[0-9]+){0,1})$/;
var parseSpecifiedDomain = function parseSpecifiedDomain$1(specifiedDomain, dataDomain, allowDataOverflow) {
	if ((0, import_isFunction$15.default)(specifiedDomain)) return specifiedDomain(dataDomain, allowDataOverflow);
	if (!Array.isArray(specifiedDomain)) return dataDomain;
	var domain = [];
	if (isNumber(specifiedDomain[0])) domain[0] = allowDataOverflow ? specifiedDomain[0] : Math.min(specifiedDomain[0], dataDomain[0]);
	else if (MIN_VALUE_REG.test(specifiedDomain[0])) {
		var value = +MIN_VALUE_REG.exec(specifiedDomain[0])[1];
		domain[0] = dataDomain[0] - value;
	} else if ((0, import_isFunction$15.default)(specifiedDomain[0])) domain[0] = specifiedDomain[0](dataDomain[0]);
	else domain[0] = dataDomain[0];
	if (isNumber(specifiedDomain[1])) domain[1] = allowDataOverflow ? specifiedDomain[1] : Math.max(specifiedDomain[1], dataDomain[1]);
	else if (MAX_VALUE_REG.test(specifiedDomain[1])) {
		var _value = +MAX_VALUE_REG.exec(specifiedDomain[1])[1];
		domain[1] = dataDomain[1] + _value;
	} else if ((0, import_isFunction$15.default)(specifiedDomain[1])) domain[1] = specifiedDomain[1](dataDomain[1]);
	else domain[1] = dataDomain[1];
	return domain;
};
var getBandSizeOfAxis = function getBandSizeOfAxis$1(axis, ticks$1, isBar) {
	if (axis && axis.scale && axis.scale.bandwidth) {
		var bandWidth = axis.scale.bandwidth();
		if (!isBar || bandWidth > 0) return bandWidth;
	}
	if (axis && ticks$1 && ticks$1.length >= 2) {
		var orderedTicks = (0, import_sortBy$1.default)(ticks$1, function(o$1) {
			return o$1.coordinate;
		});
		var bandSize = Infinity;
		for (var i$2 = 1, len = orderedTicks.length; i$2 < len; i$2++) {
			var cur = orderedTicks[i$2];
			var prev = orderedTicks[i$2 - 1];
			bandSize = Math.min((cur.coordinate || 0) - (prev.coordinate || 0), bandSize);
		}
		return bandSize === Infinity ? 0 : bandSize;
	}
	return isBar ? void 0 : 0;
};
var parseDomainOfCategoryAxis = function parseDomainOfCategoryAxis$1(specifiedDomain, calculatedDomain, axisChild) {
	if (!specifiedDomain || !specifiedDomain.length) return calculatedDomain;
	if ((0, import_isEqual$4.default)(specifiedDomain, (0, import_get$2.default)(axisChild, "type.defaultProps.domain"))) return calculatedDomain;
	return specifiedDomain;
};
var getTooltipItem = function getTooltipItem$1(graphicalItem, payload) {
	var defaultedProps = graphicalItem.type.defaultProps ? _objectSpread$27(_objectSpread$27({}, graphicalItem.type.defaultProps), graphicalItem.props) : graphicalItem.props;
	var dataKey = defaultedProps.dataKey, name = defaultedProps.name, unit$1 = defaultedProps.unit, formatter = defaultedProps.formatter, tooltipType = defaultedProps.tooltipType, chartType = defaultedProps.chartType, hide = defaultedProps.hide;
	return _objectSpread$27(_objectSpread$27({}, filterProps(graphicalItem, false)), {}, {
		dataKey,
		unit: unit$1,
		formatter,
		name: name || dataKey,
		color: getMainColorOfGraphicItem(graphicalItem),
		value: getValueByDataKey(payload, dataKey),
		type: tooltipType,
		payload,
		chartType,
		hide
	});
};
require_isNil();
require_isFunction();
function _typeof$31(o$1) {
	"@babel/helpers - typeof";
	return _typeof$31 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$2) {
		return typeof o$2;
	} : function(o$2) {
		return o$2 && "function" == typeof Symbol && o$2.constructor === Symbol && o$2 !== Symbol.prototype ? "symbol" : typeof o$2;
	}, _typeof$31(o$1);
}
function ownKeys$26(e, r$1) {
	var t$1 = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o$1 = Object.getOwnPropertySymbols(e);
		r$1 && (o$1 = o$1.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t$1.push.apply(t$1, o$1);
	}
	return t$1;
}
function _objectSpread$26(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t$1 = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$26(Object(t$1), !0).forEach(function(r$2) {
			_defineProperty$29(e, r$2, t$1[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t$1)) : ownKeys$26(Object(t$1)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t$1, r$2));
		});
	}
	return e;
}
function _defineProperty$29(obj, key, value) {
	key = _toPropertyKey$29(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$29(t$1) {
	var i$2 = _toPrimitive$29(t$1, "string");
	return "symbol" == _typeof$31(i$2) ? i$2 : i$2 + "";
}
function _toPrimitive$29(t$1, r$1) {
	if ("object" != _typeof$31(t$1) || !t$1) return t$1;
	var e = t$1[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i$2 = e.call(t$1, r$1 || "default");
		if ("object" != _typeof$31(i$2)) return i$2;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t$1);
}
var RADIAN = Math.PI / 180;
var radianToDegree = function radianToDegree$1(angleInRadian) {
	return angleInRadian * 180 / Math.PI;
};
var polarToCartesian = function polarToCartesian$1(cx, cy, radius, angle) {
	return {
		x: cx + Math.cos(-RADIAN * angle) * radius,
		y: cy + Math.sin(-RADIAN * angle) * radius
	};
};
var distanceBetweenPoints = function distanceBetweenPoints$1(point$3, anotherPoint) {
	var x1 = point$3.x, y1 = point$3.y;
	var x2 = anotherPoint.x, y2 = anotherPoint.y;
	return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
};
var getAngleOfPoint = function getAngleOfPoint$1(_ref, _ref2) {
	var x$1 = _ref.x, y$1 = _ref.y;
	var cx = _ref2.cx, cy = _ref2.cy;
	var radius = distanceBetweenPoints({
		x: x$1,
		y: y$1
	}, {
		x: cx,
		y: cy
	});
	if (radius <= 0) return { radius };
	var cos$1 = (x$1 - cx) / radius;
	var angleInRadian = Math.acos(cos$1);
	if (y$1 > cy) angleInRadian = 2 * Math.PI - angleInRadian;
	return {
		radius,
		angle: radianToDegree(angleInRadian),
		angleInRadian
	};
};
var formatAngleOfSector = function formatAngleOfSector$1(_ref3) {
	var startAngle = _ref3.startAngle, endAngle = _ref3.endAngle;
	var startCnt = Math.floor(startAngle / 360);
	var endCnt = Math.floor(endAngle / 360);
	var min$3 = Math.min(startCnt, endCnt);
	return {
		startAngle: startAngle - min$3 * 360,
		endAngle: endAngle - min$3 * 360
	};
};
var reverseFormatAngleOfSetor = function reverseFormatAngleOfSetor$1(angle, _ref4) {
	var startAngle = _ref4.startAngle, endAngle = _ref4.endAngle;
	var startCnt = Math.floor(startAngle / 360);
	var endCnt = Math.floor(endAngle / 360);
	return angle + Math.min(startCnt, endCnt) * 360;
};
var inRangeOfSector = function inRangeOfSector$1(_ref5, sector) {
	var x$1 = _ref5.x, y$1 = _ref5.y;
	var _getAngleOfPoint = getAngleOfPoint({
		x: x$1,
		y: y$1
	}, sector), radius = _getAngleOfPoint.radius, angle = _getAngleOfPoint.angle;
	var innerRadius = sector.innerRadius, outerRadius = sector.outerRadius;
	if (radius < innerRadius || radius > outerRadius) return false;
	if (radius === 0) return true;
	var _formatAngleOfSector = formatAngleOfSector(sector), startAngle = _formatAngleOfSector.startAngle, endAngle = _formatAngleOfSector.endAngle;
	var formatAngle = angle;
	var inRange;
	if (startAngle <= endAngle) {
		while (formatAngle > endAngle) formatAngle -= 360;
		while (formatAngle < startAngle) formatAngle += 360;
		inRange = formatAngle >= startAngle && formatAngle <= endAngle;
	} else {
		while (formatAngle > startAngle) formatAngle -= 360;
		while (formatAngle < endAngle) formatAngle += 360;
		inRange = formatAngle >= endAngle && formatAngle <= startAngle;
	}
	if (inRange) return _objectSpread$26(_objectSpread$26({}, sector), {}, {
		radius,
		angle: reverseFormatAngleOfSetor(formatAngle, sector)
	});
	return null;
};
var import_isNil$5 = /* @__PURE__ */ __toESM(require_isNil());
var import_isFunction$13 = /* @__PURE__ */ __toESM(require_isFunction());
var import_isObject$1 = /* @__PURE__ */ __toESM(require_isObject());
function _typeof$30(o$1) {
	"@babel/helpers - typeof";
	return _typeof$30 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$2) {
		return typeof o$2;
	} : function(o$2) {
		return o$2 && "function" == typeof Symbol && o$2.constructor === Symbol && o$2 !== Symbol.prototype ? "symbol" : typeof o$2;
	}, _typeof$30(o$1);
}
var _excluded$11 = ["offset"];
function _toConsumableArray$7(arr) {
	return _arrayWithoutHoles$7(arr) || _iterableToArray$8(arr) || _unsupportedIterableToArray$11(arr) || _nonIterableSpread$7();
}
function _nonIterableSpread$7() {
	throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$11(o$1, minLen) {
	if (!o$1) return;
	if (typeof o$1 === "string") return _arrayLikeToArray$11(o$1, minLen);
	var n$1 = Object.prototype.toString.call(o$1).slice(8, -1);
	if (n$1 === "Object" && o$1.constructor) n$1 = o$1.constructor.name;
	if (n$1 === "Map" || n$1 === "Set") return Array.from(o$1);
	if (n$1 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n$1)) return _arrayLikeToArray$11(o$1, minLen);
}
function _iterableToArray$8(iter) {
	if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles$7(arr) {
	if (Array.isArray(arr)) return _arrayLikeToArray$11(arr);
}
function _arrayLikeToArray$11(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i$2 = 0, arr2 = new Array(len); i$2 < len; i$2++) arr2[i$2] = arr[i$2];
	return arr2;
}
function _objectWithoutProperties$11(source, excluded) {
	if (source == null) return {};
	var target = _objectWithoutPropertiesLoose$11(source, excluded);
	var key, i$2;
	if (Object.getOwnPropertySymbols) {
		var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
		for (i$2 = 0; i$2 < sourceSymbolKeys.length; i$2++) {
			key = sourceSymbolKeys[i$2];
			if (excluded.indexOf(key) >= 0) continue;
			if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
			target[key] = source[key];
		}
	}
	return target;
}
function _objectWithoutPropertiesLoose$11(source, excluded) {
	if (source == null) return {};
	var target = {};
	for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) {
		if (excluded.indexOf(key) >= 0) continue;
		target[key] = source[key];
	}
	return target;
}
function ownKeys$25(e, r$1) {
	var t$1 = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o$1 = Object.getOwnPropertySymbols(e);
		r$1 && (o$1 = o$1.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t$1.push.apply(t$1, o$1);
	}
	return t$1;
}
function _objectSpread$25(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t$1 = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$25(Object(t$1), !0).forEach(function(r$2) {
			_defineProperty$28(e, r$2, t$1[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t$1)) : ownKeys$25(Object(t$1)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t$1, r$2));
		});
	}
	return e;
}
function _defineProperty$28(obj, key, value) {
	key = _toPropertyKey$28(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$28(t$1) {
	var i$2 = _toPrimitive$28(t$1, "string");
	return "symbol" == _typeof$30(i$2) ? i$2 : i$2 + "";
}
function _toPrimitive$28(t$1, r$1) {
	if ("object" != _typeof$30(t$1) || !t$1) return t$1;
	var e = t$1[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i$2 = e.call(t$1, r$1 || "default");
		if ("object" != _typeof$30(i$2)) return i$2;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t$1);
}
function _extends$20() {
	_extends$20 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i$2 = 1; i$2 < arguments.length; i$2++) {
			var source = arguments[i$2];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$20.apply(this, arguments);
}
var getLabel = function getLabel$1(props) {
	var value = props.value, formatter = props.formatter;
	var label = (0, import_isNil$5.default)(props.children) ? value : props.children;
	if ((0, import_isFunction$13.default)(formatter)) return formatter(label);
	return label;
};
var getDeltaAngle$1 = function getDeltaAngle$2(startAngle, endAngle) {
	return mathSign(endAngle - startAngle) * Math.min(Math.abs(endAngle - startAngle), 360);
};
var renderRadialLabel = function renderRadialLabel$1(labelProps, label, attrs) {
	var position = labelProps.position, viewBox = labelProps.viewBox, offset = labelProps.offset, className = labelProps.className;
	var _ref = viewBox, cx = _ref.cx, cy = _ref.cy, innerRadius = _ref.innerRadius, outerRadius = _ref.outerRadius, startAngle = _ref.startAngle, endAngle = _ref.endAngle, clockWise = _ref.clockWise;
	var radius = (innerRadius + outerRadius) / 2;
	var deltaAngle = getDeltaAngle$1(startAngle, endAngle);
	var sign$1 = deltaAngle >= 0 ? 1 : -1;
	var labelAngle, direction;
	if (position === "insideStart") {
		labelAngle = startAngle + sign$1 * offset;
		direction = clockWise;
	} else if (position === "insideEnd") {
		labelAngle = endAngle - sign$1 * offset;
		direction = !clockWise;
	} else if (position === "end") {
		labelAngle = endAngle + sign$1 * offset;
		direction = clockWise;
	}
	direction = deltaAngle <= 0 ? direction : !direction;
	var startPoint = polarToCartesian(cx, cy, radius, labelAngle);
	var endPoint = polarToCartesian(cx, cy, radius, labelAngle + (direction ? 1 : -1) * 359);
	var path$1 = "M".concat(startPoint.x, ",").concat(startPoint.y, "\n    A").concat(radius, ",").concat(radius, ",0,1,").concat(direction ? 0 : 1, ",\n    ").concat(endPoint.x, ",").concat(endPoint.y);
	var id = (0, import_isNil$5.default)(labelProps.id) ? uniqueId("recharts-radial-line-") : labelProps.id;
	return /* @__PURE__ */ import_react.createElement("text", _extends$20({}, attrs, {
		dominantBaseline: "central",
		className: clsx_default("recharts-radial-bar-label", className)
	}), /* @__PURE__ */ import_react.createElement("defs", null, /* @__PURE__ */ import_react.createElement("path", {
		id,
		d: path$1
	})), /* @__PURE__ */ import_react.createElement("textPath", { xlinkHref: "#".concat(id) }, label));
};
var getAttrsOfPolarLabel = function getAttrsOfPolarLabel$1(props) {
	var viewBox = props.viewBox, offset = props.offset, position = props.position;
	var _ref2 = viewBox, cx = _ref2.cx, cy = _ref2.cy, innerRadius = _ref2.innerRadius, outerRadius = _ref2.outerRadius;
	var midAngle = (_ref2.startAngle + _ref2.endAngle) / 2;
	if (position === "outside") {
		var _polarToCartesian = polarToCartesian(cx, cy, outerRadius + offset, midAngle), _x = _polarToCartesian.x;
		return {
			x: _x,
			y: _polarToCartesian.y,
			textAnchor: _x >= cx ? "start" : "end",
			verticalAnchor: "middle"
		};
	}
	if (position === "center") return {
		x: cx,
		y: cy,
		textAnchor: "middle",
		verticalAnchor: "middle"
	};
	if (position === "centerTop") return {
		x: cx,
		y: cy,
		textAnchor: "middle",
		verticalAnchor: "start"
	};
	if (position === "centerBottom") return {
		x: cx,
		y: cy,
		textAnchor: "middle",
		verticalAnchor: "end"
	};
	var _polarToCartesian2 = polarToCartesian(cx, cy, (innerRadius + outerRadius) / 2, midAngle);
	return {
		x: _polarToCartesian2.x,
		y: _polarToCartesian2.y,
		textAnchor: "middle",
		verticalAnchor: "middle"
	};
};
var getAttrsOfCartesianLabel = function getAttrsOfCartesianLabel$1(props) {
	var viewBox = props.viewBox, parentViewBox = props.parentViewBox, offset = props.offset, position = props.position;
	var _ref3 = viewBox, x$1 = _ref3.x, y$1 = _ref3.y, width = _ref3.width, height = _ref3.height;
	var verticalSign = height >= 0 ? 1 : -1;
	var verticalOffset = verticalSign * offset;
	var verticalEnd = verticalSign > 0 ? "end" : "start";
	var verticalStart = verticalSign > 0 ? "start" : "end";
	var horizontalSign = width >= 0 ? 1 : -1;
	var horizontalOffset = horizontalSign * offset;
	var horizontalEnd = horizontalSign > 0 ? "end" : "start";
	var horizontalStart = horizontalSign > 0 ? "start" : "end";
	if (position === "top") return _objectSpread$25(_objectSpread$25({}, {
		x: x$1 + width / 2,
		y: y$1 - verticalSign * offset,
		textAnchor: "middle",
		verticalAnchor: verticalEnd
	}), parentViewBox ? {
		height: Math.max(y$1 - parentViewBox.y, 0),
		width
	} : {});
	if (position === "bottom") return _objectSpread$25(_objectSpread$25({}, {
		x: x$1 + width / 2,
		y: y$1 + height + verticalOffset,
		textAnchor: "middle",
		verticalAnchor: verticalStart
	}), parentViewBox ? {
		height: Math.max(parentViewBox.y + parentViewBox.height - (y$1 + height), 0),
		width
	} : {});
	if (position === "left") {
		var _attrs2 = {
			x: x$1 - horizontalOffset,
			y: y$1 + height / 2,
			textAnchor: horizontalEnd,
			verticalAnchor: "middle"
		};
		return _objectSpread$25(_objectSpread$25({}, _attrs2), parentViewBox ? {
			width: Math.max(_attrs2.x - parentViewBox.x, 0),
			height
		} : {});
	}
	if (position === "right") {
		var _attrs3 = {
			x: x$1 + width + horizontalOffset,
			y: y$1 + height / 2,
			textAnchor: horizontalStart,
			verticalAnchor: "middle"
		};
		return _objectSpread$25(_objectSpread$25({}, _attrs3), parentViewBox ? {
			width: Math.max(parentViewBox.x + parentViewBox.width - _attrs3.x, 0),
			height
		} : {});
	}
	var sizeAttrs = parentViewBox ? {
		width,
		height
	} : {};
	if (position === "insideLeft") return _objectSpread$25({
		x: x$1 + horizontalOffset,
		y: y$1 + height / 2,
		textAnchor: horizontalStart,
		verticalAnchor: "middle"
	}, sizeAttrs);
	if (position === "insideRight") return _objectSpread$25({
		x: x$1 + width - horizontalOffset,
		y: y$1 + height / 2,
		textAnchor: horizontalEnd,
		verticalAnchor: "middle"
	}, sizeAttrs);
	if (position === "insideTop") return _objectSpread$25({
		x: x$1 + width / 2,
		y: y$1 + verticalOffset,
		textAnchor: "middle",
		verticalAnchor: verticalStart
	}, sizeAttrs);
	if (position === "insideBottom") return _objectSpread$25({
		x: x$1 + width / 2,
		y: y$1 + height - verticalOffset,
		textAnchor: "middle",
		verticalAnchor: verticalEnd
	}, sizeAttrs);
	if (position === "insideTopLeft") return _objectSpread$25({
		x: x$1 + horizontalOffset,
		y: y$1 + verticalOffset,
		textAnchor: horizontalStart,
		verticalAnchor: verticalStart
	}, sizeAttrs);
	if (position === "insideTopRight") return _objectSpread$25({
		x: x$1 + width - horizontalOffset,
		y: y$1 + verticalOffset,
		textAnchor: horizontalEnd,
		verticalAnchor: verticalStart
	}, sizeAttrs);
	if (position === "insideBottomLeft") return _objectSpread$25({
		x: x$1 + horizontalOffset,
		y: y$1 + height - verticalOffset,
		textAnchor: horizontalStart,
		verticalAnchor: verticalEnd
	}, sizeAttrs);
	if (position === "insideBottomRight") return _objectSpread$25({
		x: x$1 + width - horizontalOffset,
		y: y$1 + height - verticalOffset,
		textAnchor: horizontalEnd,
		verticalAnchor: verticalEnd
	}, sizeAttrs);
	if ((0, import_isObject$1.default)(position) && (isNumber(position.x) || isPercent(position.x)) && (isNumber(position.y) || isPercent(position.y))) return _objectSpread$25({
		x: x$1 + getPercentValue(position.x, width),
		y: y$1 + getPercentValue(position.y, height),
		textAnchor: "end",
		verticalAnchor: "end"
	}, sizeAttrs);
	return _objectSpread$25({
		x: x$1 + width / 2,
		y: y$1 + height / 2,
		textAnchor: "middle",
		verticalAnchor: "middle"
	}, sizeAttrs);
};
var isPolar = function isPolar$1(viewBox) {
	return "cx" in viewBox && isNumber(viewBox.cx);
};
function Label(_ref4) {
	var _ref4$offset = _ref4.offset, offset = _ref4$offset === void 0 ? 5 : _ref4$offset, restProps = _objectWithoutProperties$11(_ref4, _excluded$11);
	var props = _objectSpread$25({ offset }, restProps);
	var viewBox = props.viewBox, position = props.position, value = props.value, children = props.children, content = props.content, _props$className = props.className, className = _props$className === void 0 ? "" : _props$className, textBreakAll = props.textBreakAll;
	if (!viewBox || (0, import_isNil$5.default)(value) && (0, import_isNil$5.default)(children) && !/* @__PURE__ */ (0, import_react.isValidElement)(content) && !(0, import_isFunction$13.default)(content)) return null;
	if (/* @__PURE__ */ (0, import_react.isValidElement)(content)) return /* @__PURE__ */ (0, import_react.cloneElement)(content, props);
	var label;
	if ((0, import_isFunction$13.default)(content)) {
		label = /* @__PURE__ */ (0, import_react.createElement)(content, props);
		if (/* @__PURE__ */ (0, import_react.isValidElement)(label)) return label;
	} else label = getLabel(props);
	var isPolarLabel = isPolar(viewBox);
	var attrs = filterProps(props, true);
	if (isPolarLabel && (position === "insideStart" || position === "insideEnd" || position === "end")) return renderRadialLabel(props, label, attrs);
	var positionAttrs = isPolarLabel ? getAttrsOfPolarLabel(props) : getAttrsOfCartesianLabel(props);
	return /* @__PURE__ */ import_react.createElement(Text, _extends$20({ className: clsx_default("recharts-label", className) }, attrs, positionAttrs, { breakAll: textBreakAll }), label);
}
Label.displayName = "Label";
var parseViewBox = function parseViewBox$1(props) {
	var cx = props.cx, cy = props.cy, angle = props.angle, startAngle = props.startAngle, endAngle = props.endAngle, r$1 = props.r, radius = props.radius, innerRadius = props.innerRadius, outerRadius = props.outerRadius, x$1 = props.x, y$1 = props.y, top = props.top, left = props.left, width = props.width, height = props.height, clockWise = props.clockWise, labelViewBox = props.labelViewBox;
	if (labelViewBox) return labelViewBox;
	if (isNumber(width) && isNumber(height)) {
		if (isNumber(x$1) && isNumber(y$1)) return {
			x: x$1,
			y: y$1,
			width,
			height
		};
		if (isNumber(top) && isNumber(left)) return {
			x: top,
			y: left,
			width,
			height
		};
	}
	if (isNumber(x$1) && isNumber(y$1)) return {
		x: x$1,
		y: y$1,
		width: 0,
		height: 0
	};
	if (isNumber(cx) && isNumber(cy)) return {
		cx,
		cy,
		startAngle: startAngle || angle || 0,
		endAngle: endAngle || angle || 0,
		innerRadius: innerRadius || 0,
		outerRadius: outerRadius || radius || r$1 || 0,
		clockWise
	};
	if (props.viewBox) return props.viewBox;
	return {};
};
var parseLabel = function parseLabel$1(label, viewBox) {
	if (!label) return null;
	if (label === true) return /* @__PURE__ */ import_react.createElement(Label, {
		key: "label-implicit",
		viewBox
	});
	if (isNumOrStr(label)) return /* @__PURE__ */ import_react.createElement(Label, {
		key: "label-implicit",
		viewBox,
		value: label
	});
	if (/* @__PURE__ */ (0, import_react.isValidElement)(label)) {
		if (label.type === Label) return /* @__PURE__ */ (0, import_react.cloneElement)(label, {
			key: "label-implicit",
			viewBox
		});
		return /* @__PURE__ */ import_react.createElement(Label, {
			key: "label-implicit",
			content: label,
			viewBox
		});
	}
	if ((0, import_isFunction$13.default)(label)) return /* @__PURE__ */ import_react.createElement(Label, {
		key: "label-implicit",
		content: label,
		viewBox
	});
	if ((0, import_isObject$1.default)(label)) return /* @__PURE__ */ import_react.createElement(Label, _extends$20({ viewBox }, label, { key: "label-implicit" }));
	return null;
};
var renderCallByParent$1 = function renderCallByParent$2(parentProps, viewBox) {
	var checkPropsLabel = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
	if (!parentProps || !parentProps.children && checkPropsLabel && !parentProps.label) return null;
	var children = parentProps.children;
	var parentViewBox = parseViewBox(parentProps);
	var explicitChildren = findAllByType(children, Label).map(function(child, index) {
		return /* @__PURE__ */ (0, import_react.cloneElement)(child, {
			viewBox: viewBox || parentViewBox,
			key: "label-".concat(index)
		});
	});
	if (!checkPropsLabel) return explicitChildren;
	return [parseLabel(parentProps.label, viewBox || parentViewBox)].concat(_toConsumableArray$7(explicitChildren));
};
Label.parseViewBox = parseViewBox;
Label.renderCallByParent = renderCallByParent$1;
var require_last = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function last$1(array$1) {
		var length = array$1 == null ? 0 : array$1.length;
		return length ? array$1[length - 1] : void 0;
	}
	module.exports = last$1;
}));
var import_isNil$4 = /* @__PURE__ */ __toESM(require_isNil());
var import_isObject = /* @__PURE__ */ __toESM(require_isObject());
var import_isFunction$12 = /* @__PURE__ */ __toESM(require_isFunction());
var import_last = /* @__PURE__ */ __toESM(require_last());
function _typeof$29(o$1) {
	"@babel/helpers - typeof";
	return _typeof$29 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$2) {
		return typeof o$2;
	} : function(o$2) {
		return o$2 && "function" == typeof Symbol && o$2.constructor === Symbol && o$2 !== Symbol.prototype ? "symbol" : typeof o$2;
	}, _typeof$29(o$1);
}
var _excluded$10 = ["valueAccessor"], _excluded2$5 = [
	"data",
	"dataKey",
	"clockWise",
	"id",
	"textBreakAll"
];
function _toConsumableArray$6(arr) {
	return _arrayWithoutHoles$6(arr) || _iterableToArray$7(arr) || _unsupportedIterableToArray$10(arr) || _nonIterableSpread$6();
}
function _nonIterableSpread$6() {
	throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$10(o$1, minLen) {
	if (!o$1) return;
	if (typeof o$1 === "string") return _arrayLikeToArray$10(o$1, minLen);
	var n$1 = Object.prototype.toString.call(o$1).slice(8, -1);
	if (n$1 === "Object" && o$1.constructor) n$1 = o$1.constructor.name;
	if (n$1 === "Map" || n$1 === "Set") return Array.from(o$1);
	if (n$1 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n$1)) return _arrayLikeToArray$10(o$1, minLen);
}
function _iterableToArray$7(iter) {
	if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles$6(arr) {
	if (Array.isArray(arr)) return _arrayLikeToArray$10(arr);
}
function _arrayLikeToArray$10(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i$2 = 0, arr2 = new Array(len); i$2 < len; i$2++) arr2[i$2] = arr[i$2];
	return arr2;
}
function _extends$19() {
	_extends$19 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i$2 = 1; i$2 < arguments.length; i$2++) {
			var source = arguments[i$2];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$19.apply(this, arguments);
}
function ownKeys$24(e, r$1) {
	var t$1 = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o$1 = Object.getOwnPropertySymbols(e);
		r$1 && (o$1 = o$1.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t$1.push.apply(t$1, o$1);
	}
	return t$1;
}
function _objectSpread$24(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t$1 = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$24(Object(t$1), !0).forEach(function(r$2) {
			_defineProperty$27(e, r$2, t$1[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t$1)) : ownKeys$24(Object(t$1)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t$1, r$2));
		});
	}
	return e;
}
function _defineProperty$27(obj, key, value) {
	key = _toPropertyKey$27(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$27(t$1) {
	var i$2 = _toPrimitive$27(t$1, "string");
	return "symbol" == _typeof$29(i$2) ? i$2 : i$2 + "";
}
function _toPrimitive$27(t$1, r$1) {
	if ("object" != _typeof$29(t$1) || !t$1) return t$1;
	var e = t$1[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i$2 = e.call(t$1, r$1 || "default");
		if ("object" != _typeof$29(i$2)) return i$2;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t$1);
}
function _objectWithoutProperties$10(source, excluded) {
	if (source == null) return {};
	var target = _objectWithoutPropertiesLoose$10(source, excluded);
	var key, i$2;
	if (Object.getOwnPropertySymbols) {
		var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
		for (i$2 = 0; i$2 < sourceSymbolKeys.length; i$2++) {
			key = sourceSymbolKeys[i$2];
			if (excluded.indexOf(key) >= 0) continue;
			if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
			target[key] = source[key];
		}
	}
	return target;
}
function _objectWithoutPropertiesLoose$10(source, excluded) {
	if (source == null) return {};
	var target = {};
	for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) {
		if (excluded.indexOf(key) >= 0) continue;
		target[key] = source[key];
	}
	return target;
}
var defaultAccessor = function defaultAccessor$1(entry) {
	return Array.isArray(entry.value) ? (0, import_last.default)(entry.value) : entry.value;
};
function LabelList(_ref) {
	var _ref$valueAccessor = _ref.valueAccessor, valueAccessor = _ref$valueAccessor === void 0 ? defaultAccessor : _ref$valueAccessor, restProps = _objectWithoutProperties$10(_ref, _excluded$10);
	var data = restProps.data, dataKey = restProps.dataKey, clockWise = restProps.clockWise, id = restProps.id, textBreakAll = restProps.textBreakAll, others = _objectWithoutProperties$10(restProps, _excluded2$5);
	if (!data || !data.length) return null;
	return /* @__PURE__ */ import_react.createElement(Layer, { className: "recharts-label-list" }, data.map(function(entry, index) {
		var value = (0, import_isNil$4.default)(dataKey) ? valueAccessor(entry, index) : getValueByDataKey(entry && entry.payload, dataKey);
		var idProps = (0, import_isNil$4.default)(id) ? {} : { id: "".concat(id, "-").concat(index) };
		return /* @__PURE__ */ import_react.createElement(Label, _extends$19({}, filterProps(entry, true), others, idProps, {
			parentViewBox: entry.parentViewBox,
			value,
			textBreakAll,
			viewBox: Label.parseViewBox((0, import_isNil$4.default)(clockWise) ? entry : _objectSpread$24(_objectSpread$24({}, entry), {}, { clockWise })),
			key: "label-".concat(index),
			index
		}));
	}));
}
LabelList.displayName = "LabelList";
function parseLabelList(label, data) {
	if (!label) return null;
	if (label === true) return /* @__PURE__ */ import_react.createElement(LabelList, {
		key: "labelList-implicit",
		data
	});
	if (/* @__PURE__ */ import_react.isValidElement(label) || (0, import_isFunction$12.default)(label)) return /* @__PURE__ */ import_react.createElement(LabelList, {
		key: "labelList-implicit",
		data,
		content: label
	});
	if ((0, import_isObject.default)(label)) return /* @__PURE__ */ import_react.createElement(LabelList, _extends$19({ data }, label, { key: "labelList-implicit" }));
	return null;
}
function renderCallByParent(parentProps, data) {
	var checkPropsLabel = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
	if (!parentProps || !parentProps.children && checkPropsLabel && !parentProps.label) return null;
	var children = parentProps.children;
	var explicitChildren = findAllByType(children, LabelList).map(function(child, index) {
		return /* @__PURE__ */ (0, import_react.cloneElement)(child, {
			data,
			key: "labelList-".concat(index)
		});
	});
	if (!checkPropsLabel) return explicitChildren;
	return [parseLabelList(parentProps.label, data)].concat(_toConsumableArray$6(explicitChildren));
}
LabelList.renderCallByParent = renderCallByParent;
function _typeof$28(o$1) {
	"@babel/helpers - typeof";
	return _typeof$28 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$2) {
		return typeof o$2;
	} : function(o$2) {
		return o$2 && "function" == typeof Symbol && o$2.constructor === Symbol && o$2 !== Symbol.prototype ? "symbol" : typeof o$2;
	}, _typeof$28(o$1);
}
function _extends$18() {
	_extends$18 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i$2 = 1; i$2 < arguments.length; i$2++) {
			var source = arguments[i$2];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$18.apply(this, arguments);
}
function ownKeys$23(e, r$1) {
	var t$1 = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o$1 = Object.getOwnPropertySymbols(e);
		r$1 && (o$1 = o$1.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t$1.push.apply(t$1, o$1);
	}
	return t$1;
}
function _objectSpread$23(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t$1 = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$23(Object(t$1), !0).forEach(function(r$2) {
			_defineProperty$26(e, r$2, t$1[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t$1)) : ownKeys$23(Object(t$1)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t$1, r$2));
		});
	}
	return e;
}
function _defineProperty$26(obj, key, value) {
	key = _toPropertyKey$26(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$26(t$1) {
	var i$2 = _toPrimitive$26(t$1, "string");
	return "symbol" == _typeof$28(i$2) ? i$2 : i$2 + "";
}
function _toPrimitive$26(t$1, r$1) {
	if ("object" != _typeof$28(t$1) || !t$1) return t$1;
	var e = t$1[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i$2 = e.call(t$1, r$1 || "default");
		if ("object" != _typeof$28(i$2)) return i$2;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t$1);
}
var getDeltaAngle = function getDeltaAngle$2(startAngle, endAngle) {
	return mathSign(endAngle - startAngle) * Math.min(Math.abs(endAngle - startAngle), 359.999);
};
var getTangentCircle = function getTangentCircle$1(_ref) {
	var cx = _ref.cx, cy = _ref.cy, radius = _ref.radius, angle = _ref.angle, sign$1 = _ref.sign, isExternal = _ref.isExternal, cornerRadius = _ref.cornerRadius, cornerIsExternal = _ref.cornerIsExternal;
	var centerRadius = cornerRadius * (isExternal ? 1 : -1) + radius;
	var theta = Math.asin(cornerRadius / centerRadius) / RADIAN;
	var centerAngle = cornerIsExternal ? angle : angle + sign$1 * theta;
	var center = polarToCartesian(cx, cy, centerRadius, centerAngle);
	var circleTangency = polarToCartesian(cx, cy, radius, centerAngle);
	var lineTangencyAngle = cornerIsExternal ? angle - sign$1 * theta : angle;
	return {
		center,
		circleTangency,
		lineTangency: polarToCartesian(cx, cy, centerRadius * Math.cos(theta * RADIAN), lineTangencyAngle),
		theta
	};
};
var getSectorPath = function getSectorPath$1(_ref2) {
	var cx = _ref2.cx, cy = _ref2.cy, innerRadius = _ref2.innerRadius, outerRadius = _ref2.outerRadius, startAngle = _ref2.startAngle, endAngle = _ref2.endAngle;
	var angle = getDeltaAngle(startAngle, endAngle);
	var tempEndAngle = startAngle + angle;
	var outerStartPoint = polarToCartesian(cx, cy, outerRadius, startAngle);
	var outerEndPoint = polarToCartesian(cx, cy, outerRadius, tempEndAngle);
	var path$1 = "M ".concat(outerStartPoint.x, ",").concat(outerStartPoint.y, "\n    A ").concat(outerRadius, ",").concat(outerRadius, ",0,\n    ").concat(+(Math.abs(angle) > 180), ",").concat(+(startAngle > tempEndAngle), ",\n    ").concat(outerEndPoint.x, ",").concat(outerEndPoint.y, "\n  ");
	if (innerRadius > 0) {
		var innerStartPoint = polarToCartesian(cx, cy, innerRadius, startAngle);
		var innerEndPoint = polarToCartesian(cx, cy, innerRadius, tempEndAngle);
		path$1 += "L ".concat(innerEndPoint.x, ",").concat(innerEndPoint.y, "\n            A ").concat(innerRadius, ",").concat(innerRadius, ",0,\n            ").concat(+(Math.abs(angle) > 180), ",").concat(+(startAngle <= tempEndAngle), ",\n            ").concat(innerStartPoint.x, ",").concat(innerStartPoint.y, " Z");
	} else path$1 += "L ".concat(cx, ",").concat(cy, " Z");
	return path$1;
};
var getSectorWithCorner = function getSectorWithCorner$1(_ref3) {
	var cx = _ref3.cx, cy = _ref3.cy, innerRadius = _ref3.innerRadius, outerRadius = _ref3.outerRadius, cornerRadius = _ref3.cornerRadius, forceCornerRadius = _ref3.forceCornerRadius, cornerIsExternal = _ref3.cornerIsExternal, startAngle = _ref3.startAngle, endAngle = _ref3.endAngle;
	var sign$1 = mathSign(endAngle - startAngle);
	var _getTangentCircle = getTangentCircle({
		cx,
		cy,
		radius: outerRadius,
		angle: startAngle,
		sign: sign$1,
		cornerRadius,
		cornerIsExternal
	}), soct = _getTangentCircle.circleTangency, solt = _getTangentCircle.lineTangency, sot = _getTangentCircle.theta;
	var _getTangentCircle2 = getTangentCircle({
		cx,
		cy,
		radius: outerRadius,
		angle: endAngle,
		sign: -sign$1,
		cornerRadius,
		cornerIsExternal
	}), eoct = _getTangentCircle2.circleTangency, eolt = _getTangentCircle2.lineTangency, eot = _getTangentCircle2.theta;
	var outerArcAngle = cornerIsExternal ? Math.abs(startAngle - endAngle) : Math.abs(startAngle - endAngle) - sot - eot;
	if (outerArcAngle < 0) {
		if (forceCornerRadius) return "M ".concat(solt.x, ",").concat(solt.y, "\n        a").concat(cornerRadius, ",").concat(cornerRadius, ",0,0,1,").concat(cornerRadius * 2, ",0\n        a").concat(cornerRadius, ",").concat(cornerRadius, ",0,0,1,").concat(-cornerRadius * 2, ",0\n      ");
		return getSectorPath({
			cx,
			cy,
			innerRadius,
			outerRadius,
			startAngle,
			endAngle
		});
	}
	var path$1 = "M ".concat(solt.x, ",").concat(solt.y, "\n    A").concat(cornerRadius, ",").concat(cornerRadius, ",0,0,").concat(+(sign$1 < 0), ",").concat(soct.x, ",").concat(soct.y, "\n    A").concat(outerRadius, ",").concat(outerRadius, ",0,").concat(+(outerArcAngle > 180), ",").concat(+(sign$1 < 0), ",").concat(eoct.x, ",").concat(eoct.y, "\n    A").concat(cornerRadius, ",").concat(cornerRadius, ",0,0,").concat(+(sign$1 < 0), ",").concat(eolt.x, ",").concat(eolt.y, "\n  ");
	if (innerRadius > 0) {
		var _getTangentCircle3 = getTangentCircle({
			cx,
			cy,
			radius: innerRadius,
			angle: startAngle,
			sign: sign$1,
			isExternal: true,
			cornerRadius,
			cornerIsExternal
		}), sict = _getTangentCircle3.circleTangency, silt = _getTangentCircle3.lineTangency, sit = _getTangentCircle3.theta;
		var _getTangentCircle4 = getTangentCircle({
			cx,
			cy,
			radius: innerRadius,
			angle: endAngle,
			sign: -sign$1,
			isExternal: true,
			cornerRadius,
			cornerIsExternal
		}), eict = _getTangentCircle4.circleTangency, eilt = _getTangentCircle4.lineTangency, eit = _getTangentCircle4.theta;
		var innerArcAngle = cornerIsExternal ? Math.abs(startAngle - endAngle) : Math.abs(startAngle - endAngle) - sit - eit;
		if (innerArcAngle < 0 && cornerRadius === 0) return "".concat(path$1, "L").concat(cx, ",").concat(cy, "Z");
		path$1 += "L".concat(eilt.x, ",").concat(eilt.y, "\n      A").concat(cornerRadius, ",").concat(cornerRadius, ",0,0,").concat(+(sign$1 < 0), ",").concat(eict.x, ",").concat(eict.y, "\n      A").concat(innerRadius, ",").concat(innerRadius, ",0,").concat(+(innerArcAngle > 180), ",").concat(+(sign$1 > 0), ",").concat(sict.x, ",").concat(sict.y, "\n      A").concat(cornerRadius, ",").concat(cornerRadius, ",0,0,").concat(+(sign$1 < 0), ",").concat(silt.x, ",").concat(silt.y, "Z");
	} else path$1 += "L".concat(cx, ",").concat(cy, "Z");
	return path$1;
};
var defaultProps$3 = {
	cx: 0,
	cy: 0,
	innerRadius: 0,
	outerRadius: 0,
	startAngle: 0,
	endAngle: 0,
	cornerRadius: 0,
	forceCornerRadius: false,
	cornerIsExternal: false
};
var Sector = function Sector$1(sectorProps) {
	var props = _objectSpread$23(_objectSpread$23({}, defaultProps$3), sectorProps);
	var cx = props.cx, cy = props.cy, innerRadius = props.innerRadius, outerRadius = props.outerRadius, cornerRadius = props.cornerRadius, forceCornerRadius = props.forceCornerRadius, cornerIsExternal = props.cornerIsExternal, startAngle = props.startAngle, endAngle = props.endAngle, className = props.className;
	if (outerRadius < innerRadius || startAngle === endAngle) return null;
	var layerClass = clsx_default("recharts-sector", className);
	var deltaRadius = outerRadius - innerRadius;
	var cr = getPercentValue(cornerRadius, deltaRadius, 0, true);
	var path$1;
	if (cr > 0 && Math.abs(startAngle - endAngle) < 360) path$1 = getSectorWithCorner({
		cx,
		cy,
		innerRadius,
		outerRadius,
		cornerRadius: Math.min(cr, deltaRadius / 2),
		forceCornerRadius,
		cornerIsExternal,
		startAngle,
		endAngle
	});
	else path$1 = getSectorPath({
		cx,
		cy,
		innerRadius,
		outerRadius,
		startAngle,
		endAngle
	});
	return /* @__PURE__ */ import_react.createElement("path", _extends$18({}, filterProps(props, true), {
		className: layerClass,
		d: path$1,
		role: "img"
	}));
};
var import_upperFirst = /* @__PURE__ */ __toESM(require_upperFirst());
var import_isFunction$11 = /* @__PURE__ */ __toESM(require_isFunction());
function _typeof$27(o$1) {
	"@babel/helpers - typeof";
	return _typeof$27 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$2) {
		return typeof o$2;
	} : function(o$2) {
		return o$2 && "function" == typeof Symbol && o$2.constructor === Symbol && o$2 !== Symbol.prototype ? "symbol" : typeof o$2;
	}, _typeof$27(o$1);
}
function _extends$17() {
	_extends$17 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i$2 = 1; i$2 < arguments.length; i$2++) {
			var source = arguments[i$2];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$17.apply(this, arguments);
}
function ownKeys$22(e, r$1) {
	var t$1 = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o$1 = Object.getOwnPropertySymbols(e);
		r$1 && (o$1 = o$1.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t$1.push.apply(t$1, o$1);
	}
	return t$1;
}
function _objectSpread$22(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t$1 = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$22(Object(t$1), !0).forEach(function(r$2) {
			_defineProperty$25(e, r$2, t$1[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t$1)) : ownKeys$22(Object(t$1)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t$1, r$2));
		});
	}
	return e;
}
function _defineProperty$25(obj, key, value) {
	key = _toPropertyKey$25(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$25(t$1) {
	var i$2 = _toPrimitive$25(t$1, "string");
	return "symbol" == _typeof$27(i$2) ? i$2 : i$2 + "";
}
function _toPrimitive$25(t$1, r$1) {
	if ("object" != _typeof$27(t$1) || !t$1) return t$1;
	var e = t$1[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i$2 = e.call(t$1, r$1 || "default");
		if ("object" != _typeof$27(i$2)) return i$2;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t$1);
}
var CURVE_FACTORIES = {
	curveBasisClosed: basisClosed_default,
	curveBasisOpen: basisOpen_default,
	curveBasis: basis_default,
	curveBumpX: bumpX,
	curveBumpY: bumpY,
	curveLinearClosed: linearClosed_default,
	curveLinear: linear_default,
	curveMonotoneX: monotoneX,
	curveMonotoneY: monotoneY,
	curveNatural: natural_default,
	curveStep: step_default,
	curveStepAfter: stepAfter,
	curveStepBefore: stepBefore
};
var defined = function defined$1(p) {
	return p.x === +p.x && p.y === +p.y;
};
var getX = function getX$1(p) {
	return p.x;
};
var getY = function getY$1(p) {
	return p.y;
};
var getCurveFactory = function getCurveFactory$1(type, layout) {
	if ((0, import_isFunction$11.default)(type)) return type;
	var name = "curve".concat((0, import_upperFirst.default)(type));
	if ((name === "curveMonotone" || name === "curveBump") && layout) return CURVE_FACTORIES["".concat(name).concat(layout === "vertical" ? "Y" : "X")];
	return CURVE_FACTORIES[name] || linear_default;
};
var getPath$1 = function getPath$2(_ref) {
	var _ref$type = _ref.type, type = _ref$type === void 0 ? "linear" : _ref$type, _ref$points = _ref.points, points = _ref$points === void 0 ? [] : _ref$points, baseLine = _ref.baseLine, layout = _ref.layout, _ref$connectNulls = _ref.connectNulls, connectNulls = _ref$connectNulls === void 0 ? false : _ref$connectNulls;
	var curveFactory = getCurveFactory(type, layout);
	var formatPoints = connectNulls ? points.filter(function(entry) {
		return defined(entry);
	}) : points;
	var lineFunction;
	if (Array.isArray(baseLine)) {
		var formatBaseLine = connectNulls ? baseLine.filter(function(base) {
			return defined(base);
		}) : baseLine;
		var areaPoints = formatPoints.map(function(entry, index) {
			return _objectSpread$22(_objectSpread$22({}, entry), {}, { base: formatBaseLine[index] });
		});
		if (layout === "vertical") lineFunction = area_default().y(getY).x1(getX).x0(function(d) {
			return d.base.x;
		});
		else lineFunction = area_default().x(getX).y1(getY).y0(function(d) {
			return d.base.y;
		});
		lineFunction.defined(defined).curve(curveFactory);
		return lineFunction(areaPoints);
	}
	if (layout === "vertical" && isNumber(baseLine)) lineFunction = area_default().y(getY).x1(getX).x0(baseLine);
	else if (isNumber(baseLine)) lineFunction = area_default().x(getX).y1(getY).y0(baseLine);
	else lineFunction = line_default().x(getX).y(getY);
	lineFunction.defined(defined).curve(curveFactory);
	return lineFunction(formatPoints);
};
var Curve = function Curve$1(props) {
	var className = props.className, points = props.points, path$1 = props.path, pathRef = props.pathRef;
	if ((!points || !points.length) && !path$1) return null;
	var realPath = points && points.length ? getPath$1(props) : path$1;
	return /* @__PURE__ */ import_react.createElement("path", _extends$17({}, filterProps(props, false), adaptEventHandlers(props), {
		className: clsx_default("recharts-curve", className),
		d: realPath,
		ref: pathRef
	}));
};
/** @license React v16.13.1
* react-is.development.js
*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
var require_react_is_development = /* @__PURE__ */ __commonJSMin(((exports) => {
	(function() {
		"use strict";
		var hasSymbol = typeof Symbol === "function" && Symbol.for;
		var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
		var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
		var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
		var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
		var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
		var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
		var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
		var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
		var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
		var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
		var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
		var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
		var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
		var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
		var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
		var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
		var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
		var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
		function isValidElementType(type) {
			return typeof type === "string" || typeof type === "function" || type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
		}
		function typeOf(object$1) {
			if (typeof object$1 === "object" && object$1 !== null) {
				var $$typeof = object$1.$$typeof;
				switch ($$typeof) {
					case REACT_ELEMENT_TYPE:
						var type = object$1.type;
						switch (type) {
							case REACT_ASYNC_MODE_TYPE:
							case REACT_CONCURRENT_MODE_TYPE:
							case REACT_FRAGMENT_TYPE:
							case REACT_PROFILER_TYPE:
							case REACT_STRICT_MODE_TYPE:
							case REACT_SUSPENSE_TYPE: return type;
							default:
								var $$typeofType = type && type.$$typeof;
								switch ($$typeofType) {
									case REACT_CONTEXT_TYPE:
									case REACT_FORWARD_REF_TYPE:
									case REACT_LAZY_TYPE:
									case REACT_MEMO_TYPE:
									case REACT_PROVIDER_TYPE: return $$typeofType;
									default: return $$typeof;
								}
						}
					case REACT_PORTAL_TYPE: return $$typeof;
				}
			}
		}
		var AsyncMode = REACT_ASYNC_MODE_TYPE;
		var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
		var ContextConsumer = REACT_CONTEXT_TYPE;
		var ContextProvider = REACT_PROVIDER_TYPE;
		var Element = REACT_ELEMENT_TYPE;
		var ForwardRef = REACT_FORWARD_REF_TYPE;
		var Fragment = REACT_FRAGMENT_TYPE;
		var Lazy = REACT_LAZY_TYPE;
		var Memo = REACT_MEMO_TYPE;
		var Portal = REACT_PORTAL_TYPE;
		var Profiler = REACT_PROFILER_TYPE;
		var StrictMode = REACT_STRICT_MODE_TYPE;
		var Suspense = REACT_SUSPENSE_TYPE;
		var hasWarnedAboutDeprecatedIsAsyncMode = false;
		function isAsyncMode(object$1) {
			if (!hasWarnedAboutDeprecatedIsAsyncMode) {
				hasWarnedAboutDeprecatedIsAsyncMode = true;
				console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
			}
			return isConcurrentMode(object$1) || typeOf(object$1) === REACT_ASYNC_MODE_TYPE;
		}
		function isConcurrentMode(object$1) {
			return typeOf(object$1) === REACT_CONCURRENT_MODE_TYPE;
		}
		function isContextConsumer(object$1) {
			return typeOf(object$1) === REACT_CONTEXT_TYPE;
		}
		function isContextProvider(object$1) {
			return typeOf(object$1) === REACT_PROVIDER_TYPE;
		}
		function isElement(object$1) {
			return typeof object$1 === "object" && object$1 !== null && object$1.$$typeof === REACT_ELEMENT_TYPE;
		}
		function isForwardRef(object$1) {
			return typeOf(object$1) === REACT_FORWARD_REF_TYPE;
		}
		function isFragment$1(object$1) {
			return typeOf(object$1) === REACT_FRAGMENT_TYPE;
		}
		function isLazy(object$1) {
			return typeOf(object$1) === REACT_LAZY_TYPE;
		}
		function isMemo(object$1) {
			return typeOf(object$1) === REACT_MEMO_TYPE;
		}
		function isPortal(object$1) {
			return typeOf(object$1) === REACT_PORTAL_TYPE;
		}
		function isProfiler(object$1) {
			return typeOf(object$1) === REACT_PROFILER_TYPE;
		}
		function isStrictMode(object$1) {
			return typeOf(object$1) === REACT_STRICT_MODE_TYPE;
		}
		function isSuspense(object$1) {
			return typeOf(object$1) === REACT_SUSPENSE_TYPE;
		}
		exports.AsyncMode = AsyncMode;
		exports.ConcurrentMode = ConcurrentMode;
		exports.ContextConsumer = ContextConsumer;
		exports.ContextProvider = ContextProvider;
		exports.Element = Element;
		exports.ForwardRef = ForwardRef;
		exports.Fragment = Fragment;
		exports.Lazy = Lazy;
		exports.Memo = Memo;
		exports.Portal = Portal;
		exports.Profiler = Profiler;
		exports.StrictMode = StrictMode;
		exports.Suspense = Suspense;
		exports.isAsyncMode = isAsyncMode;
		exports.isConcurrentMode = isConcurrentMode;
		exports.isContextConsumer = isContextConsumer;
		exports.isContextProvider = isContextProvider;
		exports.isElement = isElement;
		exports.isForwardRef = isForwardRef;
		exports.isFragment = isFragment$1;
		exports.isLazy = isLazy;
		exports.isMemo = isMemo;
		exports.isPortal = isPortal;
		exports.isProfiler = isProfiler;
		exports.isStrictMode = isStrictMode;
		exports.isSuspense = isSuspense;
		exports.isValidElementType = isValidElementType;
		exports.typeOf = typeOf;
	})();
}));
var require_react_is = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = require_react_is_development();
}));
var require_object_assign = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var getOwnPropertySymbols$1 = Object.getOwnPropertySymbols;
	var hasOwnProperty$2 = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;
	function toObject(val) {
		if (val === null || val === void 0) throw new TypeError("Object.assign cannot be called with null or undefined");
		return Object(val);
	}
	function shouldUseNative() {
		try {
			if (!Object.assign) return false;
			var test1 = /* @__PURE__ */ new String("abc");
			test1[5] = "de";
			if (Object.getOwnPropertyNames(test1)[0] === "5") return false;
			var test2 = {};
			for (var i$2 = 0; i$2 < 10; i$2++) test2["_" + String.fromCharCode(i$2)] = i$2;
			if (Object.getOwnPropertyNames(test2).map(function(n$1) {
				return test2[n$1];
			}).join("") !== "0123456789") return false;
			var test3 = {};
			"abcdefghijklmnopqrst".split("").forEach(function(letter) {
				test3[letter] = letter;
			});
			if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") return false;
			return true;
		} catch (err) {
			return false;
		}
	}
	module.exports = shouldUseNative() ? Object.assign : function(target, source) {
		var from;
		var to = toObject(target);
		var symbols;
		for (var s$3 = 1; s$3 < arguments.length; s$3++) {
			from = Object(arguments[s$3]);
			for (var key in from) if (hasOwnProperty$2.call(from, key)) to[key] = from[key];
			if (getOwnPropertySymbols$1) {
				symbols = getOwnPropertySymbols$1(from);
				for (var i$2 = 0; i$2 < symbols.length; i$2++) if (propIsEnumerable.call(from, symbols[i$2])) to[symbols[i$2]] = from[symbols[i$2]];
			}
		}
		return to;
	};
}));
var require_ReactPropTypesSecret = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
}));
var require_has = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = Function.call.bind(Object.prototype.hasOwnProperty);
}));
var require_checkPropTypes = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var printWarning$1 = function() {};
	var ReactPropTypesSecret$1 = require_ReactPropTypesSecret();
	var loggedTypeFailures = {};
	var has$2 = require_has();
	printWarning$1 = function(text) {
		var message = "Warning: " + text;
		if (typeof console !== "undefined") console.error(message);
		try {
			throw new Error(message);
		} catch (x$1) {}
	};
	function checkPropTypes$1(typeSpecs, values, location, componentName, getStack) {
		for (var typeSpecName in typeSpecs) if (has$2(typeSpecs, typeSpecName)) {
			var error;
			try {
				if (typeof typeSpecs[typeSpecName] !== "function") {
					var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
					err.name = "Invariant Violation";
					throw err;
				}
				error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret$1);
			} catch (ex) {
				error = ex;
			}
			if (error && !(error instanceof Error)) printWarning$1((componentName || "React class") + ": type specification of " + location + " `" + typeSpecName + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof error + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).");
			if (error instanceof Error && !(error.message in loggedTypeFailures)) {
				loggedTypeFailures[error.message] = true;
				var stack = getStack ? getStack() : "";
				printWarning$1("Failed " + location + " type: " + error.message + (stack != null ? stack : ""));
			}
		}
	}
	checkPropTypes$1.resetWarningCache = function() {
		loggedTypeFailures = {};
	};
	module.exports = checkPropTypes$1;
}));
var require_factoryWithTypeCheckers = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var ReactIs$1 = require_react_is();
	var assign = require_object_assign();
	var ReactPropTypesSecret = require_ReactPropTypesSecret();
	var has$1 = require_has();
	var checkPropTypes = require_checkPropTypes();
	var printWarning = function() {};
	printWarning = function(text) {
		var message = "Warning: " + text;
		if (typeof console !== "undefined") console.error(message);
		try {
			throw new Error(message);
		} catch (x$1) {}
	};
	function emptyFunctionThatReturnsNull() {
		return null;
	}
	module.exports = function(isValidElement$7, throwOnDirectAccess$1) {
		var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
		var FAUX_ITERATOR_SYMBOL = "@@iterator";
		function getIteratorFn(maybeIterable) {
			var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
			if (typeof iteratorFn === "function") return iteratorFn;
		}
		var ANONYMOUS = "<<anonymous>>";
		var ReactPropTypes = {
			array: createPrimitiveTypeChecker("array"),
			bigint: createPrimitiveTypeChecker("bigint"),
			bool: createPrimitiveTypeChecker("boolean"),
			func: createPrimitiveTypeChecker("function"),
			number: createPrimitiveTypeChecker("number"),
			object: createPrimitiveTypeChecker("object"),
			string: createPrimitiveTypeChecker("string"),
			symbol: createPrimitiveTypeChecker("symbol"),
			any: createAnyTypeChecker(),
			arrayOf: createArrayOfTypeChecker,
			element: createElementTypeChecker(),
			elementType: createElementTypeTypeChecker(),
			instanceOf: createInstanceTypeChecker,
			node: createNodeChecker(),
			objectOf: createObjectOfTypeChecker,
			oneOf: createEnumTypeChecker,
			oneOfType: createUnionTypeChecker,
			shape: createShapeTypeChecker,
			exact: createStrictShapeTypeChecker
		};
		function is(x$1, y$1) {
			if (x$1 === y$1) return x$1 !== 0 || 1 / x$1 === 1 / y$1;
			else return x$1 !== x$1 && y$1 !== y$1;
		}
		function PropTypeError(message, data) {
			this.message = message;
			this.data = data && typeof data === "object" ? data : {};
			this.stack = "";
		}
		PropTypeError.prototype = Error.prototype;
		function createChainableTypeChecker(validate) {
			var manualPropTypeCallCache = {};
			var manualPropTypeWarningCount = 0;
			function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
				componentName = componentName || ANONYMOUS;
				propFullName = propFullName || propName;
				if (secret !== ReactPropTypesSecret) {
					if (throwOnDirectAccess$1) {
						var err = /* @__PURE__ */ new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types");
						err.name = "Invariant Violation";
						throw err;
					} else if (typeof console !== "undefined") {
						var cacheKey = componentName + ":" + propName;
						if (!manualPropTypeCallCache[cacheKey] && manualPropTypeWarningCount < 3) {
							printWarning("You are manually calling a React.PropTypes validation function for the `" + propFullName + "` prop on `" + componentName + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details.");
							manualPropTypeCallCache[cacheKey] = true;
							manualPropTypeWarningCount++;
						}
					}
				}
				if (props[propName] == null) {
					if (isRequired) {
						if (props[propName] === null) return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`."));
						return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`."));
					}
					return null;
				} else return validate(props, propName, componentName, location, propFullName);
			}
			var chainedCheckType = checkType.bind(null, false);
			chainedCheckType.isRequired = checkType.bind(null, true);
			return chainedCheckType;
		}
		function createPrimitiveTypeChecker(expectedType) {
			function validate(props, propName, componentName, location, propFullName, secret) {
				var propValue = props[propName];
				if (getPropType(propValue) !== expectedType) {
					var preciseType = getPreciseType(propValue);
					return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."), { expectedType });
				}
				return null;
			}
			return createChainableTypeChecker(validate);
		}
		function createAnyTypeChecker() {
			return createChainableTypeChecker(emptyFunctionThatReturnsNull);
		}
		function createArrayOfTypeChecker(typeChecker) {
			function validate(props, propName, componentName, location, propFullName) {
				if (typeof typeChecker !== "function") return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
				var propValue = props[propName];
				if (!Array.isArray(propValue)) {
					var propType = getPropType(propValue);
					return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
				}
				for (var i$2 = 0; i$2 < propValue.length; i$2++) {
					var error = typeChecker(propValue, i$2, componentName, location, propFullName + "[" + i$2 + "]", ReactPropTypesSecret);
					if (error instanceof Error) return error;
				}
				return null;
			}
			return createChainableTypeChecker(validate);
		}
		function createElementTypeChecker() {
			function validate(props, propName, componentName, location, propFullName) {
				var propValue = props[propName];
				if (!isValidElement$7(propValue)) {
					var propType = getPropType(propValue);
					return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
				}
				return null;
			}
			return createChainableTypeChecker(validate);
		}
		function createElementTypeTypeChecker() {
			function validate(props, propName, componentName, location, propFullName) {
				var propValue = props[propName];
				if (!ReactIs$1.isValidElementType(propValue)) {
					var propType = getPropType(propValue);
					return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement type."));
				}
				return null;
			}
			return createChainableTypeChecker(validate);
		}
		function createInstanceTypeChecker(expectedClass) {
			function validate(props, propName, componentName, location, propFullName) {
				if (!(props[propName] instanceof expectedClass)) {
					var expectedClassName = expectedClass.name || ANONYMOUS;
					var actualClassName = getClassName(props[propName]);
					return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
				}
				return null;
			}
			return createChainableTypeChecker(validate);
		}
		function createEnumTypeChecker(expectedValues) {
			if (!Array.isArray(expectedValues)) {
				if (arguments.length > 1) printWarning("Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).");
				else printWarning("Invalid argument supplied to oneOf, expected an array.");
				return emptyFunctionThatReturnsNull;
			}
			function validate(props, propName, componentName, location, propFullName) {
				var propValue = props[propName];
				for (var i$2 = 0; i$2 < expectedValues.length; i$2++) if (is(propValue, expectedValues[i$2])) return null;
				var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
					if (getPreciseType(value) === "symbol") return String(value);
					return value;
				});
				return new PropTypeError("Invalid " + location + " `" + propFullName + "` of value `" + String(propValue) + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
			}
			return createChainableTypeChecker(validate);
		}
		function createObjectOfTypeChecker(typeChecker) {
			function validate(props, propName, componentName, location, propFullName) {
				if (typeof typeChecker !== "function") return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
				var propValue = props[propName];
				var propType = getPropType(propValue);
				if (propType !== "object") return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
				for (var key in propValue) if (has$1(propValue, key)) {
					var error = typeChecker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
					if (error instanceof Error) return error;
				}
				return null;
			}
			return createChainableTypeChecker(validate);
		}
		function createUnionTypeChecker(arrayOfTypeCheckers) {
			if (!Array.isArray(arrayOfTypeCheckers)) {
				printWarning("Invalid argument supplied to oneOfType, expected an instance of array.");
				return emptyFunctionThatReturnsNull;
			}
			for (var i$2 = 0; i$2 < arrayOfTypeCheckers.length; i$2++) {
				var checker = arrayOfTypeCheckers[i$2];
				if (typeof checker !== "function") {
					printWarning("Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + getPostfixForTypeWarning(checker) + " at index " + i$2 + ".");
					return emptyFunctionThatReturnsNull;
				}
			}
			function validate(props, propName, componentName, location, propFullName) {
				var expectedTypes = [];
				for (var i$3 = 0; i$3 < arrayOfTypeCheckers.length; i$3++) {
					var checker$1 = arrayOfTypeCheckers[i$3];
					var checkerResult = checker$1(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
					if (checkerResult == null) return null;
					if (checkerResult.data && has$1(checkerResult.data, "expectedType")) expectedTypes.push(checkerResult.data.expectedType);
				}
				var expectedTypesMessage = expectedTypes.length > 0 ? ", expected one of type [" + expectedTypes.join(", ") + "]" : "";
				return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`" + expectedTypesMessage + "."));
			}
			return createChainableTypeChecker(validate);
		}
		function createNodeChecker() {
			function validate(props, propName, componentName, location, propFullName) {
				if (!isNode(props[propName])) return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
				return null;
			}
			return createChainableTypeChecker(validate);
		}
		function invalidValidatorError(componentName, location, propFullName, key, type) {
			return new PropTypeError((componentName || "React class") + ": " + location + " type `" + propFullName + "." + key + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + type + "`.");
		}
		function createShapeTypeChecker(shapeTypes) {
			function validate(props, propName, componentName, location, propFullName) {
				var propValue = props[propName];
				var propType = getPropType(propValue);
				if (propType !== "object") return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
				for (var key in shapeTypes) {
					var checker = shapeTypes[key];
					if (typeof checker !== "function") return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
					var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
					if (error) return error;
				}
				return null;
			}
			return createChainableTypeChecker(validate);
		}
		function createStrictShapeTypeChecker(shapeTypes) {
			function validate(props, propName, componentName, location, propFullName) {
				var propValue = props[propName];
				var propType = getPropType(propValue);
				if (propType !== "object") return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
				for (var key in assign({}, props[propName], shapeTypes)) {
					var checker = shapeTypes[key];
					if (has$1(shapeTypes, key) && typeof checker !== "function") return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
					if (!checker) return new PropTypeError("Invalid " + location + " `" + propFullName + "` key `" + key + "` supplied to `" + componentName + "`.\nBad object: " + JSON.stringify(props[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  "));
					var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
					if (error) return error;
				}
				return null;
			}
			return createChainableTypeChecker(validate);
		}
		function isNode(propValue) {
			switch (typeof propValue) {
				case "number":
				case "string":
				case "undefined": return true;
				case "boolean": return !propValue;
				case "object":
					if (Array.isArray(propValue)) return propValue.every(isNode);
					if (propValue === null || isValidElement$7(propValue)) return true;
					var iteratorFn = getIteratorFn(propValue);
					if (iteratorFn) {
						var iterator = iteratorFn.call(propValue);
						var step;
						if (iteratorFn !== propValue.entries) {
							while (!(step = iterator.next()).done) if (!isNode(step.value)) return false;
						} else while (!(step = iterator.next()).done) {
							var entry = step.value;
							if (entry) {
								if (!isNode(entry[1])) return false;
							}
						}
					} else return false;
					return true;
				default: return false;
			}
		}
		function isSymbol$7(propType, propValue) {
			if (propType === "symbol") return true;
			if (!propValue) return false;
			if (propValue["@@toStringTag"] === "Symbol") return true;
			if (typeof Symbol === "function" && propValue instanceof Symbol) return true;
			return false;
		}
		function getPropType(propValue) {
			var propType = typeof propValue;
			if (Array.isArray(propValue)) return "array";
			if (propValue instanceof RegExp) return "object";
			if (isSymbol$7(propType, propValue)) return "symbol";
			return propType;
		}
		function getPreciseType(propValue) {
			if (typeof propValue === "undefined" || propValue === null) return "" + propValue;
			var propType = getPropType(propValue);
			if (propType === "object") {
				if (propValue instanceof Date) return "date";
				else if (propValue instanceof RegExp) return "regexp";
			}
			return propType;
		}
		function getPostfixForTypeWarning(value) {
			var type = getPreciseType(value);
			switch (type) {
				case "array":
				case "object": return "an " + type;
				case "boolean":
				case "date":
				case "regexp": return "a " + type;
				default: return type;
			}
		}
		function getClassName(propValue) {
			if (!propValue.constructor || !propValue.constructor.name) return ANONYMOUS;
			return propValue.constructor.name;
		}
		ReactPropTypes.checkPropTypes = checkPropTypes;
		ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
		ReactPropTypes.PropTypes = ReactPropTypes;
		return ReactPropTypes;
	};
}));
var require_prop_types = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var ReactIs = require_react_is();
	module.exports = require_factoryWithTypeCheckers()(ReactIs.isElement, true);
}));
var { getOwnPropertyNames, getOwnPropertySymbols } = Object;
var { hasOwnProperty: hasOwnProperty$1 } = Object.prototype;
function combineComparators(comparatorA, comparatorB) {
	return function isEqual$6(a$2, b, state) {
		return comparatorA(a$2, b, state) && comparatorB(a$2, b, state);
	};
}
function createIsCircular(areItemsEqual) {
	return function isCircular(a$2, b, state) {
		if (!a$2 || !b || typeof a$2 !== "object" || typeof b !== "object") return areItemsEqual(a$2, b, state);
		const { cache } = state;
		const cachedA = cache.get(a$2);
		const cachedB = cache.get(b);
		if (cachedA && cachedB) return cachedA === b && cachedB === a$2;
		cache.set(a$2, b);
		cache.set(b, a$2);
		const result = areItemsEqual(a$2, b, state);
		cache.delete(a$2);
		cache.delete(b);
		return result;
	};
}
function getShortTag(value) {
	return value != null ? value[Symbol.toStringTag] : void 0;
}
function getStrictProperties(object$1) {
	return getOwnPropertyNames(object$1).concat(getOwnPropertySymbols(object$1));
}
var hasOwn = Object.hasOwn || ((object$1, property$2) => hasOwnProperty$1.call(object$1, property$2));
function sameValueZeroEqual(a$2, b) {
	return a$2 === b || !a$2 && !b && a$2 !== a$2 && b !== b;
}
var PREACT_VNODE = "__v";
var PREACT_OWNER = "__o";
var REACT_OWNER = "_owner";
var { getOwnPropertyDescriptor, keys: keys$1 } = Object;
function areArrayBuffersEqual(a$2, b) {
	return a$2.byteLength === b.byteLength && areTypedArraysEqual(new Uint8Array(a$2), new Uint8Array(b));
}
function areArraysEqual(a$2, b, state) {
	let index = a$2.length;
	if (b.length !== index) return false;
	while (index-- > 0) if (!state.equals(a$2[index], b[index], index, index, a$2, b, state)) return false;
	return true;
}
function areDataViewsEqual(a$2, b) {
	return a$2.byteLength === b.byteLength && areTypedArraysEqual(new Uint8Array(a$2.buffer, a$2.byteOffset, a$2.byteLength), new Uint8Array(b.buffer, b.byteOffset, b.byteLength));
}
function areDatesEqual(a$2, b) {
	return sameValueZeroEqual(a$2.getTime(), b.getTime());
}
function areErrorsEqual(a$2, b) {
	return a$2.name === b.name && a$2.message === b.message && a$2.cause === b.cause && a$2.stack === b.stack;
}
function areFunctionsEqual(a$2, b) {
	return a$2 === b;
}
function areMapsEqual(a$2, b, state) {
	const size = a$2.size;
	if (size !== b.size) return false;
	if (!size) return true;
	const matchedIndices = new Array(size);
	const aIterable = a$2.entries();
	let aResult;
	let bResult;
	let index = 0;
	while (aResult = aIterable.next()) {
		if (aResult.done) break;
		const bIterable = b.entries();
		let hasMatch = false;
		let matchIndex = 0;
		while (bResult = bIterable.next()) {
			if (bResult.done) break;
			if (matchedIndices[matchIndex]) {
				matchIndex++;
				continue;
			}
			const aEntry = aResult.value;
			const bEntry = bResult.value;
			if (state.equals(aEntry[0], bEntry[0], index, matchIndex, a$2, b, state) && state.equals(aEntry[1], bEntry[1], aEntry[0], bEntry[0], a$2, b, state)) {
				hasMatch = matchedIndices[matchIndex] = true;
				break;
			}
			matchIndex++;
		}
		if (!hasMatch) return false;
		index++;
	}
	return true;
}
var areNumbersEqual = sameValueZeroEqual;
function areObjectsEqual(a$2, b, state) {
	const properties = keys$1(a$2);
	let index = properties.length;
	if (keys$1(b).length !== index) return false;
	while (index-- > 0) if (!isPropertyEqual(a$2, b, state, properties[index])) return false;
	return true;
}
function areObjectsEqualStrict(a$2, b, state) {
	const properties = getStrictProperties(a$2);
	let index = properties.length;
	if (getStrictProperties(b).length !== index) return false;
	let property$2;
	let descriptorA;
	let descriptorB;
	while (index-- > 0) {
		property$2 = properties[index];
		if (!isPropertyEqual(a$2, b, state, property$2)) return false;
		descriptorA = getOwnPropertyDescriptor(a$2, property$2);
		descriptorB = getOwnPropertyDescriptor(b, property$2);
		if ((descriptorA || descriptorB) && (!descriptorA || !descriptorB || descriptorA.configurable !== descriptorB.configurable || descriptorA.enumerable !== descriptorB.enumerable || descriptorA.writable !== descriptorB.writable)) return false;
	}
	return true;
}
function arePrimitiveWrappersEqual(a$2, b) {
	return sameValueZeroEqual(a$2.valueOf(), b.valueOf());
}
function areRegExpsEqual(a$2, b) {
	return a$2.source === b.source && a$2.flags === b.flags;
}
function areSetsEqual(a$2, b, state) {
	const size = a$2.size;
	if (size !== b.size) return false;
	if (!size) return true;
	const matchedIndices = new Array(size);
	const aIterable = a$2.values();
	let aResult;
	let bResult;
	while (aResult = aIterable.next()) {
		if (aResult.done) break;
		const bIterable = b.values();
		let hasMatch = false;
		let matchIndex = 0;
		while (bResult = bIterable.next()) {
			if (bResult.done) break;
			if (!matchedIndices[matchIndex] && state.equals(aResult.value, bResult.value, aResult.value, bResult.value, a$2, b, state)) {
				hasMatch = matchedIndices[matchIndex] = true;
				break;
			}
			matchIndex++;
		}
		if (!hasMatch) return false;
	}
	return true;
}
function areTypedArraysEqual(a$2, b) {
	let index = a$2.byteLength;
	if (b.byteLength !== index || a$2.byteOffset !== b.byteOffset) return false;
	while (index-- > 0) if (a$2[index] !== b[index]) return false;
	return true;
}
function areUrlsEqual(a$2, b) {
	return a$2.hostname === b.hostname && a$2.pathname === b.pathname && a$2.protocol === b.protocol && a$2.port === b.port && a$2.hash === b.hash && a$2.username === b.username && a$2.password === b.password;
}
function isPropertyEqual(a$2, b, state, property$2) {
	if ((property$2 === REACT_OWNER || property$2 === PREACT_OWNER || property$2 === PREACT_VNODE) && (a$2.$$typeof || b.$$typeof)) return true;
	return hasOwn(b, property$2) && state.equals(a$2[property$2], b[property$2], property$2, property$2, a$2, b, state);
}
var ARRAY_BUFFER_TAG = "[object ArrayBuffer]";
var ARGUMENTS_TAG = "[object Arguments]";
var BOOLEAN_TAG = "[object Boolean]";
var DATA_VIEW_TAG = "[object DataView]";
var DATE_TAG = "[object Date]";
var ERROR_TAG = "[object Error]";
var MAP_TAG = "[object Map]";
var NUMBER_TAG = "[object Number]";
var OBJECT_TAG = "[object Object]";
var REG_EXP_TAG = "[object RegExp]";
var SET_TAG = "[object Set]";
var STRING_TAG = "[object String]";
var TYPED_ARRAY_TAGS = {
	"[object Int8Array]": true,
	"[object Uint8Array]": true,
	"[object Uint8ClampedArray]": true,
	"[object Int16Array]": true,
	"[object Uint16Array]": true,
	"[object Int32Array]": true,
	"[object Uint32Array]": true,
	"[object Float16Array]": true,
	"[object Float32Array]": true,
	"[object Float64Array]": true,
	"[object BigInt64Array]": true,
	"[object BigUint64Array]": true
};
var URL_TAG = "[object URL]";
var toString = Object.prototype.toString;
function createEqualityComparator({ areArrayBuffersEqual: areArrayBuffersEqual$1, areArraysEqual: areArraysEqual$1, areDataViewsEqual: areDataViewsEqual$1, areDatesEqual: areDatesEqual$1, areErrorsEqual: areErrorsEqual$1, areFunctionsEqual: areFunctionsEqual$1, areMapsEqual: areMapsEqual$1, areNumbersEqual: areNumbersEqual$1, areObjectsEqual: areObjectsEqual$1, arePrimitiveWrappersEqual: arePrimitiveWrappersEqual$1, areRegExpsEqual: areRegExpsEqual$1, areSetsEqual: areSetsEqual$1, areTypedArraysEqual: areTypedArraysEqual$1, areUrlsEqual: areUrlsEqual$1, unknownTagComparators }) {
	return function comparator(a$2, b, state) {
		if (a$2 === b) return true;
		if (a$2 == null || b == null) return false;
		const type = typeof a$2;
		if (type !== typeof b) return false;
		if (type !== "object") {
			if (type === "number") return areNumbersEqual$1(a$2, b, state);
			if (type === "function") return areFunctionsEqual$1(a$2, b, state);
			return false;
		}
		const constructor = a$2.constructor;
		if (constructor !== b.constructor) return false;
		if (constructor === Object) return areObjectsEqual$1(a$2, b, state);
		if (Array.isArray(a$2)) return areArraysEqual$1(a$2, b, state);
		if (constructor === Date) return areDatesEqual$1(a$2, b, state);
		if (constructor === RegExp) return areRegExpsEqual$1(a$2, b, state);
		if (constructor === Map) return areMapsEqual$1(a$2, b, state);
		if (constructor === Set) return areSetsEqual$1(a$2, b, state);
		const tag = toString.call(a$2);
		if (tag === DATE_TAG) return areDatesEqual$1(a$2, b, state);
		if (tag === REG_EXP_TAG) return areRegExpsEqual$1(a$2, b, state);
		if (tag === MAP_TAG) return areMapsEqual$1(a$2, b, state);
		if (tag === SET_TAG) return areSetsEqual$1(a$2, b, state);
		if (tag === OBJECT_TAG) return typeof a$2.then !== "function" && typeof b.then !== "function" && areObjectsEqual$1(a$2, b, state);
		if (tag === URL_TAG) return areUrlsEqual$1(a$2, b, state);
		if (tag === ERROR_TAG) return areErrorsEqual$1(a$2, b, state);
		if (tag === ARGUMENTS_TAG) return areObjectsEqual$1(a$2, b, state);
		if (TYPED_ARRAY_TAGS[tag]) return areTypedArraysEqual$1(a$2, b, state);
		if (tag === ARRAY_BUFFER_TAG) return areArrayBuffersEqual$1(a$2, b, state);
		if (tag === DATA_VIEW_TAG) return areDataViewsEqual$1(a$2, b, state);
		if (tag === BOOLEAN_TAG || tag === NUMBER_TAG || tag === STRING_TAG) return arePrimitiveWrappersEqual$1(a$2, b, state);
		if (unknownTagComparators) {
			let unknownTagComparator = unknownTagComparators[tag];
			if (!unknownTagComparator) {
				const shortTag = getShortTag(a$2);
				if (shortTag) unknownTagComparator = unknownTagComparators[shortTag];
			}
			if (unknownTagComparator) return unknownTagComparator(a$2, b, state);
		}
		return false;
	};
}
function createEqualityComparatorConfig({ circular, createCustomConfig, strict }) {
	let config$1 = {
		areArrayBuffersEqual,
		areArraysEqual: strict ? areObjectsEqualStrict : areArraysEqual,
		areDataViewsEqual,
		areDatesEqual,
		areErrorsEqual,
		areFunctionsEqual,
		areMapsEqual: strict ? combineComparators(areMapsEqual, areObjectsEqualStrict) : areMapsEqual,
		areNumbersEqual,
		areObjectsEqual: strict ? areObjectsEqualStrict : areObjectsEqual,
		arePrimitiveWrappersEqual,
		areRegExpsEqual,
		areSetsEqual: strict ? combineComparators(areSetsEqual, areObjectsEqualStrict) : areSetsEqual,
		areTypedArraysEqual: strict ? combineComparators(areTypedArraysEqual, areObjectsEqualStrict) : areTypedArraysEqual,
		areUrlsEqual,
		unknownTagComparators: void 0
	};
	if (createCustomConfig) config$1 = Object.assign({}, config$1, createCustomConfig(config$1));
	if (circular) {
		const areArraysEqual$1 = createIsCircular(config$1.areArraysEqual);
		const areMapsEqual$1 = createIsCircular(config$1.areMapsEqual);
		const areObjectsEqual$1 = createIsCircular(config$1.areObjectsEqual);
		const areSetsEqual$1 = createIsCircular(config$1.areSetsEqual);
		config$1 = Object.assign({}, config$1, {
			areArraysEqual: areArraysEqual$1,
			areMapsEqual: areMapsEqual$1,
			areObjectsEqual: areObjectsEqual$1,
			areSetsEqual: areSetsEqual$1
		});
	}
	return config$1;
}
function createInternalEqualityComparator(compare) {
	return function(a$2, b, _indexOrKeyA, _indexOrKeyB, _parentA, _parentB, state) {
		return compare(a$2, b, state);
	};
}
function createIsEqual({ circular, comparator, createState, equals, strict }) {
	if (createState) return function isEqual$6(a$2, b) {
		const { cache = circular ? /* @__PURE__ */ new WeakMap() : void 0, meta: meta$2 } = createState();
		return comparator(a$2, b, {
			cache,
			equals,
			meta: meta$2,
			strict
		});
	};
	if (circular) return function isEqual$6(a$2, b) {
		return comparator(a$2, b, {
			cache: /* @__PURE__ */ new WeakMap(),
			equals,
			meta: void 0,
			strict
		});
	};
	const state = {
		cache: void 0,
		equals,
		meta: void 0,
		strict
	};
	return function isEqual$6(a$2, b) {
		return comparator(a$2, b, state);
	};
}
var deepEqual = createCustomEqual();
createCustomEqual({ strict: true });
createCustomEqual({ circular: true });
createCustomEqual({
	circular: true,
	strict: true
});
createCustomEqual({ createInternalComparator: () => sameValueZeroEqual });
createCustomEqual({
	strict: true,
	createInternalComparator: () => sameValueZeroEqual
});
createCustomEqual({
	circular: true,
	createInternalComparator: () => sameValueZeroEqual
});
createCustomEqual({
	circular: true,
	createInternalComparator: () => sameValueZeroEqual,
	strict: true
});
function createCustomEqual(options = {}) {
	const { circular = false, createInternalComparator: createCustomInternalComparator, createState, strict = false } = options;
	const comparator = createEqualityComparator(createEqualityComparatorConfig(options));
	return createIsEqual({
		circular,
		comparator,
		createState,
		equals: createCustomInternalComparator ? createCustomInternalComparator(comparator) : createInternalEqualityComparator(comparator),
		strict
	});
}
function safeRequestAnimationFrame(callback) {
	if (typeof requestAnimationFrame !== "undefined") requestAnimationFrame(callback);
}
function setRafTimeout(callback) {
	var timeout = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
	var currTime = -1;
	requestAnimationFrame(function shouldUpdate(now$2) {
		if (currTime < 0) currTime = now$2;
		if (now$2 - currTime > timeout) {
			callback(now$2);
			currTime = -1;
		} else safeRequestAnimationFrame(shouldUpdate);
	});
}
function _typeof$26(o$1) {
	"@babel/helpers - typeof";
	return _typeof$26 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$2) {
		return typeof o$2;
	} : function(o$2) {
		return o$2 && "function" == typeof Symbol && o$2.constructor === Symbol && o$2 !== Symbol.prototype ? "symbol" : typeof o$2;
	}, _typeof$26(o$1);
}
function _toArray(arr) {
	return _arrayWithHoles$6(arr) || _iterableToArray$6(arr) || _unsupportedIterableToArray$9(arr) || _nonIterableRest$6();
}
function _nonIterableRest$6() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$9(o$1, minLen) {
	if (!o$1) return;
	if (typeof o$1 === "string") return _arrayLikeToArray$9(o$1, minLen);
	var n$1 = Object.prototype.toString.call(o$1).slice(8, -1);
	if (n$1 === "Object" && o$1.constructor) n$1 = o$1.constructor.name;
	if (n$1 === "Map" || n$1 === "Set") return Array.from(o$1);
	if (n$1 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n$1)) return _arrayLikeToArray$9(o$1, minLen);
}
function _arrayLikeToArray$9(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i$2 = 0, arr2 = new Array(len); i$2 < len; i$2++) arr2[i$2] = arr[i$2];
	return arr2;
}
function _iterableToArray$6(iter) {
	if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithHoles$6(arr) {
	if (Array.isArray(arr)) return arr;
}
function createAnimateManager() {
	var currStyle = {};
	var handleChange = function handleChange$1() {
		return null;
	};
	var shouldStop = false;
	var setStyle = function setStyle$1(_style) {
		if (shouldStop) return;
		if (Array.isArray(_style)) {
			if (!_style.length) return;
			var _styles = _toArray(_style), curr = _styles[0], restStyles = _styles.slice(1);
			if (typeof curr === "number") {
				setRafTimeout(setStyle$1.bind(null, restStyles), curr);
				return;
			}
			setStyle$1(curr);
			setRafTimeout(setStyle$1.bind(null, restStyles));
			return;
		}
		if (_typeof$26(_style) === "object") {
			currStyle = _style;
			handleChange(currStyle);
		}
		if (typeof _style === "function") _style();
	};
	return {
		stop: function stop() {
			shouldStop = true;
		},
		start: function start(style) {
			shouldStop = false;
			setStyle(style);
		},
		subscribe: function subscribe(_handleChange) {
			handleChange = _handleChange;
			return function() {
				handleChange = function handleChange$1() {
					return null;
				};
			};
		}
	};
}
function _typeof$25(o$1) {
	"@babel/helpers - typeof";
	return _typeof$25 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$2) {
		return typeof o$2;
	} : function(o$2) {
		return o$2 && "function" == typeof Symbol && o$2.constructor === Symbol && o$2 !== Symbol.prototype ? "symbol" : typeof o$2;
	}, _typeof$25(o$1);
}
function ownKeys$21(e, r$1) {
	var t$1 = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o$1 = Object.getOwnPropertySymbols(e);
		r$1 && (o$1 = o$1.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t$1.push.apply(t$1, o$1);
	}
	return t$1;
}
function _objectSpread$21(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t$1 = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$21(Object(t$1), !0).forEach(function(r$2) {
			_defineProperty$24(e, r$2, t$1[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t$1)) : ownKeys$21(Object(t$1)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t$1, r$2));
		});
	}
	return e;
}
function _defineProperty$24(obj, key, value) {
	key = _toPropertyKey$24(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$24(arg) {
	var key = _toPrimitive$24(arg, "string");
	return _typeof$25(key) === "symbol" ? key : String(key);
}
function _toPrimitive$24(input, hint) {
	if (_typeof$25(input) !== "object" || input === null) return input;
	var prim = input[Symbol.toPrimitive];
	if (prim !== void 0) {
		var res = prim.call(input, hint || "default");
		if (_typeof$25(res) !== "object") return res;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return (hint === "string" ? String : Number)(input);
}
var getIntersectionKeys = function getIntersectionKeys$1(preObj, nextObj) {
	return [Object.keys(preObj), Object.keys(nextObj)].reduce(function(a$2, b) {
		return a$2.filter(function(c$1) {
			return b.includes(c$1);
		});
	});
};
var identity = function identity$11(param) {
	return param;
};
var getDashCase = function getDashCase$1(name) {
	return name.replace(/([A-Z])/g, function(v) {
		return "-".concat(v.toLowerCase());
	});
};
var mapObject = function mapObject$1(fn, obj) {
	return Object.keys(obj).reduce(function(res, key) {
		return _objectSpread$21(_objectSpread$21({}, res), {}, _defineProperty$24({}, key, fn(key, obj[key])));
	}, {});
};
var getTransitionVal = function getTransitionVal$1(props, duration$2, easing) {
	return props.map(function(prop) {
		return "".concat(getDashCase(prop), " ").concat(duration$2, "ms ").concat(easing);
	}).join(",");
};
var isDev = true;
var warn$1 = function warn$2(condition, format$2, a$2, b, c$1, d, e, f) {
	if (isDev && typeof console !== "undefined" && console.warn) {
		if (format$2 === void 0) console.warn("LogUtils requires an error message argument");
		if (!condition) if (format$2 === void 0) console.warn("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
		else {
			var args = [
				a$2,
				b,
				c$1,
				d,
				e,
				f
			];
			var argIndex = 0;
			console.warn(format$2.replace(/%s/g, function() {
				return args[argIndex++];
			}));
		}
	}
};
function _slicedToArray$5(arr, i$2) {
	return _arrayWithHoles$5(arr) || _iterableToArrayLimit$5(arr, i$2) || _unsupportedIterableToArray$8(arr, i$2) || _nonIterableRest$5();
}
function _nonIterableRest$5() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArrayLimit$5(r$1, l) {
	var t$1 = null == r$1 ? null : "undefined" != typeof Symbol && r$1[Symbol.iterator] || r$1["@@iterator"];
	if (null != t$1) {
		var e, n$1, i$2, u, a$2 = [], f = !0, o$1 = !1;
		try {
			if (i$2 = (t$1 = t$1.call(r$1)).next, 0 === l) {
				if (Object(t$1) !== t$1) return;
				f = !1;
			} else for (; !(f = (e = i$2.call(t$1)).done) && (a$2.push(e.value), a$2.length !== l); f = !0);
		} catch (r$2) {
			o$1 = !0, n$1 = r$2;
		} finally {
			try {
				if (!f && null != t$1.return && (u = t$1.return(), Object(u) !== u)) return;
			} finally {
				if (o$1) throw n$1;
			}
		}
		return a$2;
	}
}
function _arrayWithHoles$5(arr) {
	if (Array.isArray(arr)) return arr;
}
function _toConsumableArray$5(arr) {
	return _arrayWithoutHoles$5(arr) || _iterableToArray$5(arr) || _unsupportedIterableToArray$8(arr) || _nonIterableSpread$5();
}
function _nonIterableSpread$5() {
	throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$8(o$1, minLen) {
	if (!o$1) return;
	if (typeof o$1 === "string") return _arrayLikeToArray$8(o$1, minLen);
	var n$1 = Object.prototype.toString.call(o$1).slice(8, -1);
	if (n$1 === "Object" && o$1.constructor) n$1 = o$1.constructor.name;
	if (n$1 === "Map" || n$1 === "Set") return Array.from(o$1);
	if (n$1 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n$1)) return _arrayLikeToArray$8(o$1, minLen);
}
function _iterableToArray$5(iter) {
	if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles$5(arr) {
	if (Array.isArray(arr)) return _arrayLikeToArray$8(arr);
}
function _arrayLikeToArray$8(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i$2 = 0, arr2 = new Array(len); i$2 < len; i$2++) arr2[i$2] = arr[i$2];
	return arr2;
}
var ACCURACY = 1e-4;
var cubicBezierFactor = function cubicBezierFactor$1(c1, c2) {
	return [
		0,
		3 * c1,
		3 * c2 - 6 * c1,
		3 * c1 - 3 * c2 + 1
	];
};
var multyTime = function multyTime$1(params, t$1) {
	return params.map(function(param, i$2) {
		return param * Math.pow(t$1, i$2);
	}).reduce(function(pre, curr) {
		return pre + curr;
	});
};
var cubicBezier = function cubicBezier$1(c1, c2) {
	return function(t$1) {
		return multyTime(cubicBezierFactor(c1, c2), t$1);
	};
};
var derivativeCubicBezier = function derivativeCubicBezier$1(c1, c2) {
	return function(t$1) {
		var params = cubicBezierFactor(c1, c2);
		return multyTime([].concat(_toConsumableArray$5(params.map(function(param, i$2) {
			return param * i$2;
		}).slice(1)), [0]), t$1);
	};
};
var configBezier = function configBezier$1() {
	for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
	var x1 = args[0], y1 = args[1], x2 = args[2], y2 = args[3];
	if (args.length === 1) switch (args[0]) {
		case "linear":
			x1 = 0;
			y1 = 0;
			x2 = 1;
			y2 = 1;
			break;
		case "ease":
			x1 = .25;
			y1 = .1;
			x2 = .25;
			y2 = 1;
			break;
		case "ease-in":
			x1 = .42;
			y1 = 0;
			x2 = 1;
			y2 = 1;
			break;
		case "ease-out":
			x1 = .42;
			y1 = 0;
			x2 = .58;
			y2 = 1;
			break;
		case "ease-in-out":
			x1 = 0;
			y1 = 0;
			x2 = .58;
			y2 = 1;
			break;
		default:
			var easing = args[0].split("(");
			if (easing[0] === "cubic-bezier" && easing[1].split(")")[0].split(",").length === 4) {
				var _easing$1$split$0$spl2 = _slicedToArray$5(easing[1].split(")")[0].split(",").map(function(x$1) {
					return parseFloat(x$1);
				}), 4);
				x1 = _easing$1$split$0$spl2[0];
				y1 = _easing$1$split$0$spl2[1];
				x2 = _easing$1$split$0$spl2[2];
				y2 = _easing$1$split$0$spl2[3];
			} else warn$1(false, "[configBezier]: arguments should be one of oneOf 'linear', 'ease', 'ease-in', 'ease-out', 'ease-in-out','cubic-bezier(x1,y1,x2,y2)', instead received %s", args);
	}
	warn$1([
		x1,
		x2,
		y1,
		y2
	].every(function(num) {
		return typeof num === "number" && num >= 0 && num <= 1;
	}), "[configBezier]: arguments should be x1, y1, x2, y2 of [0, 1] instead received %s", args);
	var curveX = cubicBezier(x1, x2);
	var curveY = cubicBezier(y1, y2);
	var derCurveX = derivativeCubicBezier(x1, x2);
	var rangeValue = function rangeValue$1(value) {
		if (value > 1) return 1;
		if (value < 0) return 0;
		return value;
	};
	var bezier = function bezier$1(_t) {
		var t$1 = _t > 1 ? 1 : _t;
		var x$1 = t$1;
		for (var i$2 = 0; i$2 < 8; ++i$2) {
			var evalT = curveX(x$1) - t$1;
			var derVal = derCurveX(x$1);
			if (Math.abs(evalT - t$1) < ACCURACY || derVal < ACCURACY) return curveY(x$1);
			x$1 = rangeValue(x$1 - evalT / derVal);
		}
		return curveY(x$1);
	};
	bezier.isStepper = false;
	return bezier;
};
var configSpring = function configSpring$1() {
	var config$1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
	var _config$stiff = config$1.stiff, stiff = _config$stiff === void 0 ? 100 : _config$stiff, _config$damping = config$1.damping, damping = _config$damping === void 0 ? 8 : _config$damping, _config$dt = config$1.dt, dt = _config$dt === void 0 ? 17 : _config$dt;
	var stepper = function stepper$1(currX, destX, currV) {
		var newV = currV + (-(currX - destX) * stiff - currV * damping) * dt / 1e3;
		var newX = currV * dt / 1e3 + currX;
		if (Math.abs(newX - destX) < ACCURACY && Math.abs(newV) < ACCURACY) return [destX, 0];
		return [newX, newV];
	};
	stepper.isStepper = true;
	stepper.dt = dt;
	return stepper;
};
var configEasing = function configEasing$1() {
	for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) args[_key2] = arguments[_key2];
	var easing = args[0];
	if (typeof easing === "string") switch (easing) {
		case "ease":
		case "ease-in-out":
		case "ease-out":
		case "ease-in":
		case "linear": return configBezier(easing);
		case "spring": return configSpring();
		default:
			if (easing.split("(")[0] === "cubic-bezier") return configBezier(easing);
			warn$1(false, "[configEasing]: first argument should be one of 'ease', 'ease-in', 'ease-out', 'ease-in-out','cubic-bezier(x1,y1,x2,y2)', 'linear' and 'spring', instead  received %s", args);
	}
	if (typeof easing === "function") return easing;
	warn$1(false, "[configEasing]: first argument type should be function or string, instead received %s", args);
	return null;
};
function _typeof$24(o$1) {
	"@babel/helpers - typeof";
	return _typeof$24 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$2) {
		return typeof o$2;
	} : function(o$2) {
		return o$2 && "function" == typeof Symbol && o$2.constructor === Symbol && o$2 !== Symbol.prototype ? "symbol" : typeof o$2;
	}, _typeof$24(o$1);
}
function _toConsumableArray$4(arr) {
	return _arrayWithoutHoles$4(arr) || _iterableToArray$4(arr) || _unsupportedIterableToArray$7(arr) || _nonIterableSpread$4();
}
function _nonIterableSpread$4() {
	throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArray$4(iter) {
	if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles$4(arr) {
	if (Array.isArray(arr)) return _arrayLikeToArray$7(arr);
}
function ownKeys$20(e, r$1) {
	var t$1 = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o$1 = Object.getOwnPropertySymbols(e);
		r$1 && (o$1 = o$1.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t$1.push.apply(t$1, o$1);
	}
	return t$1;
}
function _objectSpread$20(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t$1 = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$20(Object(t$1), !0).forEach(function(r$2) {
			_defineProperty$23(e, r$2, t$1[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t$1)) : ownKeys$20(Object(t$1)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t$1, r$2));
		});
	}
	return e;
}
function _defineProperty$23(obj, key, value) {
	key = _toPropertyKey$23(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$23(arg) {
	var key = _toPrimitive$23(arg, "string");
	return _typeof$24(key) === "symbol" ? key : String(key);
}
function _toPrimitive$23(input, hint) {
	if (_typeof$24(input) !== "object" || input === null) return input;
	var prim = input[Symbol.toPrimitive];
	if (prim !== void 0) {
		var res = prim.call(input, hint || "default");
		if (_typeof$24(res) !== "object") return res;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return (hint === "string" ? String : Number)(input);
}
function _slicedToArray$4(arr, i$2) {
	return _arrayWithHoles$4(arr) || _iterableToArrayLimit$4(arr, i$2) || _unsupportedIterableToArray$7(arr, i$2) || _nonIterableRest$4();
}
function _nonIterableRest$4() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$7(o$1, minLen) {
	if (!o$1) return;
	if (typeof o$1 === "string") return _arrayLikeToArray$7(o$1, minLen);
	var n$1 = Object.prototype.toString.call(o$1).slice(8, -1);
	if (n$1 === "Object" && o$1.constructor) n$1 = o$1.constructor.name;
	if (n$1 === "Map" || n$1 === "Set") return Array.from(o$1);
	if (n$1 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n$1)) return _arrayLikeToArray$7(o$1, minLen);
}
function _arrayLikeToArray$7(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i$2 = 0, arr2 = new Array(len); i$2 < len; i$2++) arr2[i$2] = arr[i$2];
	return arr2;
}
function _iterableToArrayLimit$4(r$1, l) {
	var t$1 = null == r$1 ? null : "undefined" != typeof Symbol && r$1[Symbol.iterator] || r$1["@@iterator"];
	if (null != t$1) {
		var e, n$1, i$2, u, a$2 = [], f = !0, o$1 = !1;
		try {
			if (i$2 = (t$1 = t$1.call(r$1)).next, 0 === l) {
				if (Object(t$1) !== t$1) return;
				f = !1;
			} else for (; !(f = (e = i$2.call(t$1)).done) && (a$2.push(e.value), a$2.length !== l); f = !0);
		} catch (r$2) {
			o$1 = !0, n$1 = r$2;
		} finally {
			try {
				if (!f && null != t$1.return && (u = t$1.return(), Object(u) !== u)) return;
			} finally {
				if (o$1) throw n$1;
			}
		}
		return a$2;
	}
}
function _arrayWithHoles$4(arr) {
	if (Array.isArray(arr)) return arr;
}
var alpha = function alpha$1(begin, end, k$1) {
	return begin + (end - begin) * k$1;
};
var needContinue = function needContinue$1(_ref) {
	return _ref.from !== _ref.to;
};
var calStepperVals = function calStepperVals$1(easing, preVals, steps) {
	var nextStepVals = mapObject(function(key, val) {
		if (needContinue(val)) {
			var _easing2 = _slicedToArray$4(easing(val.from, val.to, val.velocity), 2), newX = _easing2[0], newV = _easing2[1];
			return _objectSpread$20(_objectSpread$20({}, val), {}, {
				from: newX,
				velocity: newV
			});
		}
		return val;
	}, preVals);
	if (steps < 1) return mapObject(function(key, val) {
		if (needContinue(val)) return _objectSpread$20(_objectSpread$20({}, val), {}, {
			velocity: alpha(val.velocity, nextStepVals[key].velocity, steps),
			from: alpha(val.from, nextStepVals[key].from, steps)
		});
		return val;
	}, preVals);
	return calStepperVals$1(easing, nextStepVals, steps - 1);
};
var configUpdate_default = (function(from, to, easing, duration$2, render) {
	var interKeys = getIntersectionKeys(from, to);
	var timingStyle = interKeys.reduce(function(res, key) {
		return _objectSpread$20(_objectSpread$20({}, res), {}, _defineProperty$23({}, key, [from[key], to[key]]));
	}, {});
	var stepperStyle = interKeys.reduce(function(res, key) {
		return _objectSpread$20(_objectSpread$20({}, res), {}, _defineProperty$23({}, key, {
			from: from[key],
			velocity: 0,
			to: to[key]
		}));
	}, {});
	var cafId = -1;
	var preTime;
	var beginTime;
	var update = function update$1() {
		return null;
	};
	var getCurrStyle = function getCurrStyle$1() {
		return mapObject(function(key, val) {
			return val.from;
		}, stepperStyle);
	};
	var shouldStopAnimation = function shouldStopAnimation$1() {
		return !Object.values(stepperStyle).filter(needContinue).length;
	};
	update = easing.isStepper ? function stepperUpdate(now$2) {
		if (!preTime) preTime = now$2;
		var steps = (now$2 - preTime) / easing.dt;
		stepperStyle = calStepperVals(easing, stepperStyle, steps);
		render(_objectSpread$20(_objectSpread$20(_objectSpread$20({}, from), to), getCurrStyle(stepperStyle)));
		preTime = now$2;
		if (!shouldStopAnimation()) cafId = requestAnimationFrame(update);
	} : function timingUpdate(now$2) {
		if (!beginTime) beginTime = now$2;
		var t$1 = (now$2 - beginTime) / duration$2;
		var currStyle = mapObject(function(key, val) {
			return alpha.apply(void 0, _toConsumableArray$4(val).concat([easing(t$1)]));
		}, timingStyle);
		render(_objectSpread$20(_objectSpread$20(_objectSpread$20({}, from), to), currStyle));
		if (t$1 < 1) cafId = requestAnimationFrame(update);
		else {
			var finalStyle = mapObject(function(key, val) {
				return alpha.apply(void 0, _toConsumableArray$4(val).concat([easing(1)]));
			}, timingStyle);
			render(_objectSpread$20(_objectSpread$20(_objectSpread$20({}, from), to), finalStyle));
		}
	};
	return function() {
		requestAnimationFrame(update);
		return function() {
			cancelAnimationFrame(cafId);
		};
	};
});
var import_prop_types = /* @__PURE__ */ __toESM(require_prop_types());
function _typeof$23(o$1) {
	"@babel/helpers - typeof";
	return _typeof$23 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$2) {
		return typeof o$2;
	} : function(o$2) {
		return o$2 && "function" == typeof Symbol && o$2.constructor === Symbol && o$2 !== Symbol.prototype ? "symbol" : typeof o$2;
	}, _typeof$23(o$1);
}
var _excluded$9 = [
	"children",
	"begin",
	"duration",
	"attributeName",
	"easing",
	"isActive",
	"steps",
	"from",
	"to",
	"canBegin",
	"onAnimationEnd",
	"shouldReAnimate",
	"onAnimationReStart"
];
function _objectWithoutProperties$9(source, excluded) {
	if (source == null) return {};
	var target = _objectWithoutPropertiesLoose$9(source, excluded);
	var key, i$2;
	if (Object.getOwnPropertySymbols) {
		var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
		for (i$2 = 0; i$2 < sourceSymbolKeys.length; i$2++) {
			key = sourceSymbolKeys[i$2];
			if (excluded.indexOf(key) >= 0) continue;
			if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
			target[key] = source[key];
		}
	}
	return target;
}
function _objectWithoutPropertiesLoose$9(source, excluded) {
	if (source == null) return {};
	var target = {};
	var sourceKeys = Object.keys(source);
	var key, i$2;
	for (i$2 = 0; i$2 < sourceKeys.length; i$2++) {
		key = sourceKeys[i$2];
		if (excluded.indexOf(key) >= 0) continue;
		target[key] = source[key];
	}
	return target;
}
function _toConsumableArray$3(arr) {
	return _arrayWithoutHoles$3(arr) || _iterableToArray$3(arr) || _unsupportedIterableToArray$6(arr) || _nonIterableSpread$3();
}
function _nonIterableSpread$3() {
	throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$6(o$1, minLen) {
	if (!o$1) return;
	if (typeof o$1 === "string") return _arrayLikeToArray$6(o$1, minLen);
	var n$1 = Object.prototype.toString.call(o$1).slice(8, -1);
	if (n$1 === "Object" && o$1.constructor) n$1 = o$1.constructor.name;
	if (n$1 === "Map" || n$1 === "Set") return Array.from(o$1);
	if (n$1 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n$1)) return _arrayLikeToArray$6(o$1, minLen);
}
function _iterableToArray$3(iter) {
	if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles$3(arr) {
	if (Array.isArray(arr)) return _arrayLikeToArray$6(arr);
}
function _arrayLikeToArray$6(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i$2 = 0, arr2 = new Array(len); i$2 < len; i$2++) arr2[i$2] = arr[i$2];
	return arr2;
}
function ownKeys$19(e, r$1) {
	var t$1 = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o$1 = Object.getOwnPropertySymbols(e);
		r$1 && (o$1 = o$1.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t$1.push.apply(t$1, o$1);
	}
	return t$1;
}
function _objectSpread$19(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t$1 = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$19(Object(t$1), !0).forEach(function(r$2) {
			_defineProperty$22(e, r$2, t$1[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t$1)) : ownKeys$19(Object(t$1)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t$1, r$2));
		});
	}
	return e;
}
function _defineProperty$22(obj, key, value) {
	key = _toPropertyKey$22(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _classCallCheck$13(instance, Constructor) {
	if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties$13(target, props) {
	for (var i$2 = 0; i$2 < props.length; i$2++) {
		var descriptor = props[i$2];
		descriptor.enumerable = descriptor.enumerable || false;
		descriptor.configurable = true;
		if ("value" in descriptor) descriptor.writable = true;
		Object.defineProperty(target, _toPropertyKey$22(descriptor.key), descriptor);
	}
}
function _createClass$13(Constructor, protoProps, staticProps) {
	if (protoProps) _defineProperties$13(Constructor.prototype, protoProps);
	if (staticProps) _defineProperties$13(Constructor, staticProps);
	Object.defineProperty(Constructor, "prototype", { writable: false });
	return Constructor;
}
function _toPropertyKey$22(arg) {
	var key = _toPrimitive$22(arg, "string");
	return _typeof$23(key) === "symbol" ? key : String(key);
}
function _toPrimitive$22(input, hint) {
	if (_typeof$23(input) !== "object" || input === null) return input;
	var prim = input[Symbol.toPrimitive];
	if (prim !== void 0) {
		var res = prim.call(input, hint || "default");
		if (_typeof$23(res) !== "object") return res;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return (hint === "string" ? String : Number)(input);
}
function _inherits$11(subClass, superClass) {
	if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
	subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: {
		value: subClass,
		writable: true,
		configurable: true
	} });
	Object.defineProperty(subClass, "prototype", { writable: false });
	if (superClass) _setPrototypeOf$11(subClass, superClass);
}
function _setPrototypeOf$11(o$1, p) {
	_setPrototypeOf$11 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf$17(o$2, p$1) {
		o$2.__proto__ = p$1;
		return o$2;
	};
	return _setPrototypeOf$11(o$1, p);
}
function _createSuper(Derived) {
	var hasNativeReflectConstruct = _isNativeReflectConstruct$11();
	return function _createSuperInternal() {
		var Super = _getPrototypeOf$11(Derived), result;
		if (hasNativeReflectConstruct) {
			var NewTarget = _getPrototypeOf$11(this).constructor;
			result = Reflect.construct(Super, arguments, NewTarget);
		} else result = Super.apply(this, arguments);
		return _possibleConstructorReturn$11(this, result);
	};
}
function _possibleConstructorReturn$11(self$1, call) {
	if (call && (_typeof$23(call) === "object" || typeof call === "function")) return call;
	else if (call !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
	return _assertThisInitialized$11(self$1);
}
function _assertThisInitialized$11(self$1) {
	if (self$1 === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	return self$1;
}
function _isNativeReflectConstruct$11() {
	if (typeof Reflect === "undefined" || !Reflect.construct) return false;
	if (Reflect.construct.sham) return false;
	if (typeof Proxy === "function") return true;
	try {
		Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
		return true;
	} catch (e) {
		return false;
	}
}
function _getPrototypeOf$11(o$1) {
	_getPrototypeOf$11 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf$17(o$2) {
		return o$2.__proto__ || Object.getPrototypeOf(o$2);
	};
	return _getPrototypeOf$11(o$1);
}
var Animate = /* @__PURE__ */ function(_PureComponent) {
	_inherits$11(Animate$1, _PureComponent);
	var _super = _createSuper(Animate$1);
	function Animate$1(props, context) {
		var _this;
		_classCallCheck$13(this, Animate$1);
		_this = _super.call(this, props, context);
		var _this$props = _this.props, isActive = _this$props.isActive, attributeName = _this$props.attributeName, from = _this$props.from, to = _this$props.to, steps = _this$props.steps, children = _this$props.children, duration$2 = _this$props.duration;
		_this.handleStyleChange = _this.handleStyleChange.bind(_assertThisInitialized$11(_this));
		_this.changeStyle = _this.changeStyle.bind(_assertThisInitialized$11(_this));
		if (!isActive || duration$2 <= 0) {
			_this.state = { style: {} };
			if (typeof children === "function") _this.state = { style: to };
			return _possibleConstructorReturn$11(_this);
		}
		if (steps && steps.length) _this.state = { style: steps[0].style };
		else if (from) {
			if (typeof children === "function") {
				_this.state = { style: from };
				return _possibleConstructorReturn$11(_this);
			}
			_this.state = { style: attributeName ? _defineProperty$22({}, attributeName, from) : from };
		} else _this.state = { style: {} };
		return _this;
	}
	_createClass$13(Animate$1, [
		{
			key: "componentDidMount",
			value: function componentDidMount() {
				var _this$props2 = this.props, isActive = _this$props2.isActive, canBegin = _this$props2.canBegin;
				this.mounted = true;
				if (!isActive || !canBegin) return;
				this.runAnimation(this.props);
			}
		},
		{
			key: "componentDidUpdate",
			value: function componentDidUpdate(prevProps) {
				var _this$props3 = this.props, isActive = _this$props3.isActive, canBegin = _this$props3.canBegin, attributeName = _this$props3.attributeName, shouldReAnimate = _this$props3.shouldReAnimate, to = _this$props3.to, currentFrom = _this$props3.from;
				var style = this.state.style;
				if (!canBegin) return;
				if (!isActive) {
					var newState = { style: attributeName ? _defineProperty$22({}, attributeName, to) : to };
					if (this.state && style) {
						if (attributeName && style[attributeName] !== to || !attributeName && style !== to) this.setState(newState);
					}
					return;
				}
				if (deepEqual(prevProps.to, to) && prevProps.canBegin && prevProps.isActive) return;
				var isTriggered = !prevProps.canBegin || !prevProps.isActive;
				if (this.manager) this.manager.stop();
				if (this.stopJSAnimation) this.stopJSAnimation();
				var from = isTriggered || shouldReAnimate ? currentFrom : prevProps.to;
				if (this.state && style) {
					var _newState = { style: attributeName ? _defineProperty$22({}, attributeName, from) : from };
					if (attributeName && style[attributeName] !== from || !attributeName && style !== from) this.setState(_newState);
				}
				this.runAnimation(_objectSpread$19(_objectSpread$19({}, this.props), {}, {
					from,
					begin: 0
				}));
			}
		},
		{
			key: "componentWillUnmount",
			value: function componentWillUnmount() {
				this.mounted = false;
				var onAnimationEnd = this.props.onAnimationEnd;
				if (this.unSubscribe) this.unSubscribe();
				if (this.manager) {
					this.manager.stop();
					this.manager = null;
				}
				if (this.stopJSAnimation) this.stopJSAnimation();
				if (onAnimationEnd) onAnimationEnd();
			}
		},
		{
			key: "handleStyleChange",
			value: function handleStyleChange(style) {
				this.changeStyle(style);
			}
		},
		{
			key: "changeStyle",
			value: function changeStyle(style) {
				if (this.mounted) this.setState({ style });
			}
		},
		{
			key: "runJSAnimation",
			value: function runJSAnimation(props) {
				var _this2 = this;
				var from = props.from, to = props.to, duration$2 = props.duration, easing = props.easing, begin = props.begin, onAnimationEnd = props.onAnimationEnd, onAnimationStart = props.onAnimationStart;
				var startAnimation = configUpdate_default(from, to, configEasing(easing), duration$2, this.changeStyle);
				this.manager.start([
					onAnimationStart,
					begin,
					function finalStartAnimation() {
						_this2.stopJSAnimation = startAnimation();
					},
					duration$2,
					onAnimationEnd
				]);
			}
		},
		{
			key: "runStepAnimation",
			value: function runStepAnimation(props) {
				var _this3 = this;
				var steps = props.steps, begin = props.begin, onAnimationStart = props.onAnimationStart;
				var _steps$ = steps[0], initialStyle = _steps$.style, _steps$$duration = _steps$.duration, initialTime = _steps$$duration === void 0 ? 0 : _steps$$duration;
				return this.manager.start([onAnimationStart].concat(_toConsumableArray$3(steps.reduce(function addStyle(sequence, nextItem, index) {
					if (index === 0) return sequence;
					var duration$2 = nextItem.duration, _nextItem$easing = nextItem.easing, easing = _nextItem$easing === void 0 ? "ease" : _nextItem$easing, style = nextItem.style, nextProperties = nextItem.properties, onAnimationEnd = nextItem.onAnimationEnd;
					var preItem = index > 0 ? steps[index - 1] : nextItem;
					var properties = nextProperties || Object.keys(style);
					if (typeof easing === "function" || easing === "spring") return [].concat(_toConsumableArray$3(sequence), [_this3.runJSAnimation.bind(_this3, {
						from: preItem.style,
						to: style,
						duration: duration$2,
						easing
					}), duration$2]);
					var transition = getTransitionVal(properties, duration$2, easing);
					var newStyle = _objectSpread$19(_objectSpread$19(_objectSpread$19({}, preItem.style), style), {}, { transition });
					return [].concat(_toConsumableArray$3(sequence), [
						newStyle,
						duration$2,
						onAnimationEnd
					]).filter(identity);
				}, [initialStyle, Math.max(initialTime, begin)])), [props.onAnimationEnd]));
			}
		},
		{
			key: "runAnimation",
			value: function runAnimation(props) {
				if (!this.manager) this.manager = createAnimateManager();
				var begin = props.begin, duration$2 = props.duration, attributeName = props.attributeName, propsTo = props.to, easing = props.easing, onAnimationStart = props.onAnimationStart, onAnimationEnd = props.onAnimationEnd, steps = props.steps, children = props.children;
				var manager = this.manager;
				this.unSubscribe = manager.subscribe(this.handleStyleChange);
				if (typeof easing === "function" || typeof children === "function" || easing === "spring") {
					this.runJSAnimation(props);
					return;
				}
				if (steps.length > 1) {
					this.runStepAnimation(props);
					return;
				}
				var to = attributeName ? _defineProperty$22({}, attributeName, propsTo) : propsTo;
				var transition = getTransitionVal(Object.keys(to), duration$2, easing);
				manager.start([
					onAnimationStart,
					begin,
					_objectSpread$19(_objectSpread$19({}, to), {}, { transition }),
					duration$2,
					onAnimationEnd
				]);
			}
		},
		{
			key: "render",
			value: function render() {
				var _this$props4 = this.props, children = _this$props4.children;
				_this$props4.begin;
				var duration$2 = _this$props4.duration;
				_this$props4.attributeName;
				_this$props4.easing;
				var isActive = _this$props4.isActive;
				_this$props4.steps;
				_this$props4.from;
				_this$props4.to;
				_this$props4.canBegin;
				_this$props4.onAnimationEnd;
				_this$props4.shouldReAnimate;
				_this$props4.onAnimationReStart;
				var others = _objectWithoutProperties$9(_this$props4, _excluded$9);
				var count = import_react.Children.count(children);
				var stateStyle = this.state.style;
				if (typeof children === "function") return children(stateStyle);
				if (!isActive || count === 0 || duration$2 <= 0) return children;
				var cloneContainer = function cloneContainer$1(container) {
					var _container$props = container.props, _container$props$styl = _container$props.style, style = _container$props$styl === void 0 ? {} : _container$props$styl, className = _container$props.className;
					return /* @__PURE__ */ (0, import_react.cloneElement)(container, _objectSpread$19(_objectSpread$19({}, others), {}, {
						style: _objectSpread$19(_objectSpread$19({}, style), stateStyle),
						className
					}));
				};
				if (count === 1) return cloneContainer(import_react.Children.only(children));
				return /* @__PURE__ */ import_react.createElement("div", null, import_react.Children.map(children, function(child) {
					return cloneContainer(child);
				}));
			}
		}
	]);
	return Animate$1;
}(import_react.PureComponent);
Animate.displayName = "Animate";
Animate.defaultProps = {
	begin: 0,
	duration: 1e3,
	from: "",
	to: "",
	attributeName: "",
	easing: "ease",
	isActive: true,
	canBegin: true,
	steps: [],
	onAnimationEnd: function onAnimationEnd() {},
	onAnimationStart: function onAnimationStart() {}
};
Animate.propTypes = {
	from: import_prop_types.default.oneOfType([import_prop_types.default.object, import_prop_types.default.string]),
	to: import_prop_types.default.oneOfType([import_prop_types.default.object, import_prop_types.default.string]),
	attributeName: import_prop_types.default.string,
	duration: import_prop_types.default.number,
	begin: import_prop_types.default.number,
	easing: import_prop_types.default.oneOfType([import_prop_types.default.string, import_prop_types.default.func]),
	steps: import_prop_types.default.arrayOf(import_prop_types.default.shape({
		duration: import_prop_types.default.number.isRequired,
		style: import_prop_types.default.object.isRequired,
		easing: import_prop_types.default.oneOfType([import_prop_types.default.oneOf([
			"ease",
			"ease-in",
			"ease-out",
			"ease-in-out",
			"linear"
		]), import_prop_types.default.func]),
		properties: import_prop_types.default.arrayOf("string"),
		onAnimationEnd: import_prop_types.default.func
	})),
	children: import_prop_types.default.oneOfType([import_prop_types.default.node, import_prop_types.default.func]),
	isActive: import_prop_types.default.bool,
	canBegin: import_prop_types.default.bool,
	onAnimationEnd: import_prop_types.default.func,
	shouldReAnimate: import_prop_types.default.bool,
	onAnimationStart: import_prop_types.default.func,
	onAnimationReStart: import_prop_types.default.func
};
var es6_default = Animate;
function _typeof$22(o$1) {
	"@babel/helpers - typeof";
	return _typeof$22 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$2) {
		return typeof o$2;
	} : function(o$2) {
		return o$2 && "function" == typeof Symbol && o$2.constructor === Symbol && o$2 !== Symbol.prototype ? "symbol" : typeof o$2;
	}, _typeof$22(o$1);
}
function _extends$16() {
	_extends$16 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i$2 = 1; i$2 < arguments.length; i$2++) {
			var source = arguments[i$2];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$16.apply(this, arguments);
}
function _slicedToArray$3(arr, i$2) {
	return _arrayWithHoles$3(arr) || _iterableToArrayLimit$3(arr, i$2) || _unsupportedIterableToArray$5(arr, i$2) || _nonIterableRest$3();
}
function _nonIterableRest$3() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$5(o$1, minLen) {
	if (!o$1) return;
	if (typeof o$1 === "string") return _arrayLikeToArray$5(o$1, minLen);
	var n$1 = Object.prototype.toString.call(o$1).slice(8, -1);
	if (n$1 === "Object" && o$1.constructor) n$1 = o$1.constructor.name;
	if (n$1 === "Map" || n$1 === "Set") return Array.from(o$1);
	if (n$1 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n$1)) return _arrayLikeToArray$5(o$1, minLen);
}
function _arrayLikeToArray$5(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i$2 = 0, arr2 = new Array(len); i$2 < len; i$2++) arr2[i$2] = arr[i$2];
	return arr2;
}
function _iterableToArrayLimit$3(r$1, l) {
	var t$1 = null == r$1 ? null : "undefined" != typeof Symbol && r$1[Symbol.iterator] || r$1["@@iterator"];
	if (null != t$1) {
		var e, n$1, i$2, u, a$2 = [], f = !0, o$1 = !1;
		try {
			if (i$2 = (t$1 = t$1.call(r$1)).next, 0 === l) {
				if (Object(t$1) !== t$1) return;
				f = !1;
			} else for (; !(f = (e = i$2.call(t$1)).done) && (a$2.push(e.value), a$2.length !== l); f = !0);
		} catch (r$2) {
			o$1 = !0, n$1 = r$2;
		} finally {
			try {
				if (!f && null != t$1["return"] && (u = t$1["return"](), Object(u) !== u)) return;
			} finally {
				if (o$1) throw n$1;
			}
		}
		return a$2;
	}
}
function _arrayWithHoles$3(arr) {
	if (Array.isArray(arr)) return arr;
}
function ownKeys$18(e, r$1) {
	var t$1 = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o$1 = Object.getOwnPropertySymbols(e);
		r$1 && (o$1 = o$1.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t$1.push.apply(t$1, o$1);
	}
	return t$1;
}
function _objectSpread$18(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t$1 = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$18(Object(t$1), !0).forEach(function(r$2) {
			_defineProperty$21(e, r$2, t$1[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t$1)) : ownKeys$18(Object(t$1)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t$1, r$2));
		});
	}
	return e;
}
function _defineProperty$21(obj, key, value) {
	key = _toPropertyKey$21(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$21(t$1) {
	var i$2 = _toPrimitive$21(t$1, "string");
	return "symbol" == _typeof$22(i$2) ? i$2 : i$2 + "";
}
function _toPrimitive$21(t$1, r$1) {
	if ("object" != _typeof$22(t$1) || !t$1) return t$1;
	var e = t$1[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i$2 = e.call(t$1, r$1 || "default");
		if ("object" != _typeof$22(i$2)) return i$2;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t$1);
}
var getRectanglePath = function getRectanglePath$1(x$1, y$1, width, height, radius) {
	var maxRadius = Math.min(Math.abs(width) / 2, Math.abs(height) / 2);
	var ySign = height >= 0 ? 1 : -1;
	var xSign = width >= 0 ? 1 : -1;
	var clockWise = height >= 0 && width >= 0 || height < 0 && width < 0 ? 1 : 0;
	var path$1;
	if (maxRadius > 0 && radius instanceof Array) {
		var newRadius = [
			0,
			0,
			0,
			0
		];
		for (var i$2 = 0, len = 4; i$2 < len; i$2++) newRadius[i$2] = radius[i$2] > maxRadius ? maxRadius : radius[i$2];
		path$1 = "M".concat(x$1, ",").concat(y$1 + ySign * newRadius[0]);
		if (newRadius[0] > 0) path$1 += "A ".concat(newRadius[0], ",").concat(newRadius[0], ",0,0,").concat(clockWise, ",").concat(x$1 + xSign * newRadius[0], ",").concat(y$1);
		path$1 += "L ".concat(x$1 + width - xSign * newRadius[1], ",").concat(y$1);
		if (newRadius[1] > 0) path$1 += "A ".concat(newRadius[1], ",").concat(newRadius[1], ",0,0,").concat(clockWise, ",\n        ").concat(x$1 + width, ",").concat(y$1 + ySign * newRadius[1]);
		path$1 += "L ".concat(x$1 + width, ",").concat(y$1 + height - ySign * newRadius[2]);
		if (newRadius[2] > 0) path$1 += "A ".concat(newRadius[2], ",").concat(newRadius[2], ",0,0,").concat(clockWise, ",\n        ").concat(x$1 + width - xSign * newRadius[2], ",").concat(y$1 + height);
		path$1 += "L ".concat(x$1 + xSign * newRadius[3], ",").concat(y$1 + height);
		if (newRadius[3] > 0) path$1 += "A ".concat(newRadius[3], ",").concat(newRadius[3], ",0,0,").concat(clockWise, ",\n        ").concat(x$1, ",").concat(y$1 + height - ySign * newRadius[3]);
		path$1 += "Z";
	} else if (maxRadius > 0 && radius === +radius && radius > 0) {
		var _newRadius = Math.min(maxRadius, radius);
		path$1 = "M ".concat(x$1, ",").concat(y$1 + ySign * _newRadius, "\n            A ").concat(_newRadius, ",").concat(_newRadius, ",0,0,").concat(clockWise, ",").concat(x$1 + xSign * _newRadius, ",").concat(y$1, "\n            L ").concat(x$1 + width - xSign * _newRadius, ",").concat(y$1, "\n            A ").concat(_newRadius, ",").concat(_newRadius, ",0,0,").concat(clockWise, ",").concat(x$1 + width, ",").concat(y$1 + ySign * _newRadius, "\n            L ").concat(x$1 + width, ",").concat(y$1 + height - ySign * _newRadius, "\n            A ").concat(_newRadius, ",").concat(_newRadius, ",0,0,").concat(clockWise, ",").concat(x$1 + width - xSign * _newRadius, ",").concat(y$1 + height, "\n            L ").concat(x$1 + xSign * _newRadius, ",").concat(y$1 + height, "\n            A ").concat(_newRadius, ",").concat(_newRadius, ",0,0,").concat(clockWise, ",").concat(x$1, ",").concat(y$1 + height - ySign * _newRadius, " Z");
	} else path$1 = "M ".concat(x$1, ",").concat(y$1, " h ").concat(width, " v ").concat(height, " h ").concat(-width, " Z");
	return path$1;
};
var isInRectangle = function isInRectangle$1(point$3, rect) {
	if (!point$3 || !rect) return false;
	var px = point$3.x, py = point$3.y;
	var x$1 = rect.x, y$1 = rect.y, width = rect.width, height = rect.height;
	if (Math.abs(width) > 0 && Math.abs(height) > 0) {
		var minX = Math.min(x$1, x$1 + width);
		var maxX = Math.max(x$1, x$1 + width);
		var minY = Math.min(y$1, y$1 + height);
		var maxY = Math.max(y$1, y$1 + height);
		return px >= minX && px <= maxX && py >= minY && py <= maxY;
	}
	return false;
};
var defaultProps$2 = {
	x: 0,
	y: 0,
	width: 0,
	height: 0,
	radius: 0,
	isAnimationActive: false,
	isUpdateAnimationActive: false,
	animationBegin: 0,
	animationDuration: 1500,
	animationEasing: "ease"
};
var Rectangle = function Rectangle$1(rectangleProps) {
	var props = _objectSpread$18(_objectSpread$18({}, defaultProps$2), rectangleProps);
	var pathRef = (0, import_react.useRef)();
	var _useState2 = _slicedToArray$3((0, import_react.useState)(-1), 2), totalLength = _useState2[0], setTotalLength = _useState2[1];
	(0, import_react.useEffect)(function() {
		if (pathRef.current && pathRef.current.getTotalLength) try {
			var pathTotalLength = pathRef.current.getTotalLength();
			if (pathTotalLength) setTotalLength(pathTotalLength);
		} catch (err) {}
	}, []);
	var x$1 = props.x, y$1 = props.y, width = props.width, height = props.height, radius = props.radius, className = props.className;
	var animationEasing = props.animationEasing, animationDuration = props.animationDuration, animationBegin = props.animationBegin, isAnimationActive = props.isAnimationActive, isUpdateAnimationActive = props.isUpdateAnimationActive;
	if (x$1 !== +x$1 || y$1 !== +y$1 || width !== +width || height !== +height || width === 0 || height === 0) return null;
	var layerClass = clsx_default("recharts-rectangle", className);
	if (!isUpdateAnimationActive) return /* @__PURE__ */ import_react.createElement("path", _extends$16({}, filterProps(props, true), {
		className: layerClass,
		d: getRectanglePath(x$1, y$1, width, height, radius)
	}));
	return /* @__PURE__ */ import_react.createElement(es6_default, {
		canBegin: totalLength > 0,
		from: {
			width,
			height,
			x: x$1,
			y: y$1
		},
		to: {
			width,
			height,
			x: x$1,
			y: y$1
		},
		duration: animationDuration,
		animationEasing,
		isActive: isUpdateAnimationActive
	}, function(_ref) {
		var currWidth = _ref.width, currHeight = _ref.height, currX = _ref.x, currY = _ref.y;
		return /* @__PURE__ */ import_react.createElement(es6_default, {
			canBegin: totalLength > 0,
			from: "0px ".concat(totalLength === -1 ? 1 : totalLength, "px"),
			to: "".concat(totalLength, "px 0px"),
			attributeName: "strokeDasharray",
			begin: animationBegin,
			duration: animationDuration,
			isActive: isAnimationActive,
			easing: animationEasing
		}, /* @__PURE__ */ import_react.createElement("path", _extends$16({}, filterProps(props, true), {
			className: layerClass,
			d: getRectanglePath(currX, currY, currWidth, currHeight, radius),
			ref: pathRef
		})));
	});
};
function _extends$15() {
	_extends$15 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i$2 = 1; i$2 < arguments.length; i$2++) {
			var source = arguments[i$2];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$15.apply(this, arguments);
}
var Dot = function Dot$1(props) {
	var cx = props.cx, cy = props.cy, r$1 = props.r, className = props.className;
	var layerClass = clsx_default("recharts-dot", className);
	if (cx === +cx && cy === +cy && r$1 === +r$1) return /* @__PURE__ */ import_react.createElement("circle", _extends$15({}, filterProps(props, false), adaptEventHandlers(props), {
		className: layerClass,
		cx,
		cy,
		r: r$1
	}));
	return null;
};
function _typeof$21(o$1) {
	"@babel/helpers - typeof";
	return _typeof$21 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$2) {
		return typeof o$2;
	} : function(o$2) {
		return o$2 && "function" == typeof Symbol && o$2.constructor === Symbol && o$2 !== Symbol.prototype ? "symbol" : typeof o$2;
	}, _typeof$21(o$1);
}
var _excluded$8 = [
	"x",
	"y",
	"top",
	"left",
	"width",
	"height",
	"className"
];
function _extends$14() {
	_extends$14 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i$2 = 1; i$2 < arguments.length; i$2++) {
			var source = arguments[i$2];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$14.apply(this, arguments);
}
function ownKeys$17(e, r$1) {
	var t$1 = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o$1 = Object.getOwnPropertySymbols(e);
		r$1 && (o$1 = o$1.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t$1.push.apply(t$1, o$1);
	}
	return t$1;
}
function _objectSpread$17(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t$1 = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$17(Object(t$1), !0).forEach(function(r$2) {
			_defineProperty$20(e, r$2, t$1[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t$1)) : ownKeys$17(Object(t$1)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t$1, r$2));
		});
	}
	return e;
}
function _defineProperty$20(obj, key, value) {
	key = _toPropertyKey$20(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$20(t$1) {
	var i$2 = _toPrimitive$20(t$1, "string");
	return "symbol" == _typeof$21(i$2) ? i$2 : i$2 + "";
}
function _toPrimitive$20(t$1, r$1) {
	if ("object" != _typeof$21(t$1) || !t$1) return t$1;
	var e = t$1[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i$2 = e.call(t$1, r$1 || "default");
		if ("object" != _typeof$21(i$2)) return i$2;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t$1);
}
function _objectWithoutProperties$8(source, excluded) {
	if (source == null) return {};
	var target = _objectWithoutPropertiesLoose$8(source, excluded);
	var key, i$2;
	if (Object.getOwnPropertySymbols) {
		var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
		for (i$2 = 0; i$2 < sourceSymbolKeys.length; i$2++) {
			key = sourceSymbolKeys[i$2];
			if (excluded.indexOf(key) >= 0) continue;
			if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
			target[key] = source[key];
		}
	}
	return target;
}
function _objectWithoutPropertiesLoose$8(source, excluded) {
	if (source == null) return {};
	var target = {};
	for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) {
		if (excluded.indexOf(key) >= 0) continue;
		target[key] = source[key];
	}
	return target;
}
var getPath = function getPath$2(x$1, y$1, width, height, top, left) {
	return "M".concat(x$1, ",").concat(top, "v").concat(height, "M").concat(left, ",").concat(y$1, "h").concat(width);
};
var Cross = function Cross$1(_ref) {
	var _ref$x = _ref.x, x$1 = _ref$x === void 0 ? 0 : _ref$x, _ref$y = _ref.y, y$1 = _ref$y === void 0 ? 0 : _ref$y, _ref$top = _ref.top, top = _ref$top === void 0 ? 0 : _ref$top, _ref$left = _ref.left, left = _ref$left === void 0 ? 0 : _ref$left, _ref$width = _ref.width, width = _ref$width === void 0 ? 0 : _ref$width, _ref$height = _ref.height, height = _ref$height === void 0 ? 0 : _ref$height, className = _ref.className, rest = _objectWithoutProperties$8(_ref, _excluded$8);
	var props = _objectSpread$17({
		x: x$1,
		y: y$1,
		top,
		left,
		width,
		height
	}, rest);
	if (!isNumber(x$1) || !isNumber(y$1) || !isNumber(width) || !isNumber(height) || !isNumber(top) || !isNumber(left)) return null;
	return /* @__PURE__ */ import_react.createElement("path", _extends$14({}, filterProps(props, true), {
		className: clsx_default("recharts-cross", className),
		d: getPath(x$1, y$1, width, height, top, left)
	}));
};
var require__getPrototype = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = require__overArg()(Object.getPrototypeOf, Object);
}));
var require_isPlainObject = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseGetTag$1 = require__baseGetTag(), getPrototype = require__getPrototype(), isObjectLike$1 = require_isObjectLike();
	var objectTag = "[object Object]";
	var funcProto = Function.prototype, objectProto = Object.prototype;
	var funcToString = funcProto.toString;
	var hasOwnProperty = objectProto.hasOwnProperty;
	var objectCtorString = funcToString.call(Object);
	function isPlainObject$1(value) {
		if (!isObjectLike$1(value) || baseGetTag$1(value) != objectTag) return false;
		var proto = getPrototype(value);
		if (proto === null) return true;
		var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
		return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
	}
	module.exports = isPlainObject$1;
}));
var require_isBoolean = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseGetTag = require__baseGetTag(), isObjectLike = require_isObjectLike();
	var boolTag = "[object Boolean]";
	function isBoolean$1(value) {
		return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
	}
	module.exports = isBoolean$1;
}));
function _typeof$20(o$1) {
	"@babel/helpers - typeof";
	return _typeof$20 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$2) {
		return typeof o$2;
	} : function(o$2) {
		return o$2 && "function" == typeof Symbol && o$2.constructor === Symbol && o$2 !== Symbol.prototype ? "symbol" : typeof o$2;
	}, _typeof$20(o$1);
}
function _extends$13() {
	_extends$13 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i$2 = 1; i$2 < arguments.length; i$2++) {
			var source = arguments[i$2];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$13.apply(this, arguments);
}
function _slicedToArray$2(arr, i$2) {
	return _arrayWithHoles$2(arr) || _iterableToArrayLimit$2(arr, i$2) || _unsupportedIterableToArray$4(arr, i$2) || _nonIterableRest$2();
}
function _nonIterableRest$2() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$4(o$1, minLen) {
	if (!o$1) return;
	if (typeof o$1 === "string") return _arrayLikeToArray$4(o$1, minLen);
	var n$1 = Object.prototype.toString.call(o$1).slice(8, -1);
	if (n$1 === "Object" && o$1.constructor) n$1 = o$1.constructor.name;
	if (n$1 === "Map" || n$1 === "Set") return Array.from(o$1);
	if (n$1 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n$1)) return _arrayLikeToArray$4(o$1, minLen);
}
function _arrayLikeToArray$4(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i$2 = 0, arr2 = new Array(len); i$2 < len; i$2++) arr2[i$2] = arr[i$2];
	return arr2;
}
function _iterableToArrayLimit$2(r$1, l) {
	var t$1 = null == r$1 ? null : "undefined" != typeof Symbol && r$1[Symbol.iterator] || r$1["@@iterator"];
	if (null != t$1) {
		var e, n$1, i$2, u, a$2 = [], f = !0, o$1 = !1;
		try {
			if (i$2 = (t$1 = t$1.call(r$1)).next, 0 === l) {
				if (Object(t$1) !== t$1) return;
				f = !1;
			} else for (; !(f = (e = i$2.call(t$1)).done) && (a$2.push(e.value), a$2.length !== l); f = !0);
		} catch (r$2) {
			o$1 = !0, n$1 = r$2;
		} finally {
			try {
				if (!f && null != t$1["return"] && (u = t$1["return"](), Object(u) !== u)) return;
			} finally {
				if (o$1) throw n$1;
			}
		}
		return a$2;
	}
}
function _arrayWithHoles$2(arr) {
	if (Array.isArray(arr)) return arr;
}
function ownKeys$16(e, r$1) {
	var t$1 = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o$1 = Object.getOwnPropertySymbols(e);
		r$1 && (o$1 = o$1.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t$1.push.apply(t$1, o$1);
	}
	return t$1;
}
function _objectSpread$16(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t$1 = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$16(Object(t$1), !0).forEach(function(r$2) {
			_defineProperty$19(e, r$2, t$1[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t$1)) : ownKeys$16(Object(t$1)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t$1, r$2));
		});
	}
	return e;
}
function _defineProperty$19(obj, key, value) {
	key = _toPropertyKey$19(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$19(t$1) {
	var i$2 = _toPrimitive$19(t$1, "string");
	return "symbol" == _typeof$20(i$2) ? i$2 : i$2 + "";
}
function _toPrimitive$19(t$1, r$1) {
	if ("object" != _typeof$20(t$1) || !t$1) return t$1;
	var e = t$1[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i$2 = e.call(t$1, r$1 || "default");
		if ("object" != _typeof$20(i$2)) return i$2;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t$1);
}
var getTrapezoidPath = function getTrapezoidPath$1(x$1, y$1, upperWidth, lowerWidth, height) {
	var widthGap = upperWidth - lowerWidth;
	var path$1 = "M ".concat(x$1, ",").concat(y$1);
	path$1 += "L ".concat(x$1 + upperWidth, ",").concat(y$1);
	path$1 += "L ".concat(x$1 + upperWidth - widthGap / 2, ",").concat(y$1 + height);
	path$1 += "L ".concat(x$1 + upperWidth - widthGap / 2 - lowerWidth, ",").concat(y$1 + height);
	path$1 += "L ".concat(x$1, ",").concat(y$1, " Z");
	return path$1;
};
var defaultProps$1 = {
	x: 0,
	y: 0,
	upperWidth: 0,
	lowerWidth: 0,
	height: 0,
	isUpdateAnimationActive: false,
	animationBegin: 0,
	animationDuration: 1500,
	animationEasing: "ease"
};
var Trapezoid = function Trapezoid$1(props) {
	var trapezoidProps = _objectSpread$16(_objectSpread$16({}, defaultProps$1), props);
	var pathRef = (0, import_react.useRef)();
	var _useState2 = _slicedToArray$2((0, import_react.useState)(-1), 2), totalLength = _useState2[0], setTotalLength = _useState2[1];
	(0, import_react.useEffect)(function() {
		if (pathRef.current && pathRef.current.getTotalLength) try {
			var pathTotalLength = pathRef.current.getTotalLength();
			if (pathTotalLength) setTotalLength(pathTotalLength);
		} catch (err) {}
	}, []);
	var x$1 = trapezoidProps.x, y$1 = trapezoidProps.y, upperWidth = trapezoidProps.upperWidth, lowerWidth = trapezoidProps.lowerWidth, height = trapezoidProps.height, className = trapezoidProps.className;
	var animationEasing = trapezoidProps.animationEasing, animationDuration = trapezoidProps.animationDuration, animationBegin = trapezoidProps.animationBegin, isUpdateAnimationActive = trapezoidProps.isUpdateAnimationActive;
	if (x$1 !== +x$1 || y$1 !== +y$1 || upperWidth !== +upperWidth || lowerWidth !== +lowerWidth || height !== +height || upperWidth === 0 && lowerWidth === 0 || height === 0) return null;
	var layerClass = clsx_default("recharts-trapezoid", className);
	if (!isUpdateAnimationActive) return /* @__PURE__ */ import_react.createElement("g", null, /* @__PURE__ */ import_react.createElement("path", _extends$13({}, filterProps(trapezoidProps, true), {
		className: layerClass,
		d: getTrapezoidPath(x$1, y$1, upperWidth, lowerWidth, height)
	})));
	return /* @__PURE__ */ import_react.createElement(es6_default, {
		canBegin: totalLength > 0,
		from: {
			upperWidth: 0,
			lowerWidth: 0,
			height,
			x: x$1,
			y: y$1
		},
		to: {
			upperWidth,
			lowerWidth,
			height,
			x: x$1,
			y: y$1
		},
		duration: animationDuration,
		animationEasing,
		isActive: isUpdateAnimationActive
	}, function(_ref) {
		var currUpperWidth = _ref.upperWidth, currLowerWidth = _ref.lowerWidth, currHeight = _ref.height, currX = _ref.x, currY = _ref.y;
		return /* @__PURE__ */ import_react.createElement(es6_default, {
			canBegin: totalLength > 0,
			from: "0px ".concat(totalLength === -1 ? 1 : totalLength, "px"),
			to: "".concat(totalLength, "px 0px"),
			attributeName: "strokeDasharray",
			begin: animationBegin,
			duration: animationDuration,
			easing: animationEasing
		}, /* @__PURE__ */ import_react.createElement("path", _extends$13({}, filterProps(trapezoidProps, true), {
			className: layerClass,
			d: getTrapezoidPath(currX, currY, currUpperWidth, currLowerWidth, currHeight),
			ref: pathRef
		})));
	});
};
var import_isFunction$10 = /* @__PURE__ */ __toESM(require_isFunction());
var import_isPlainObject = /* @__PURE__ */ __toESM(require_isPlainObject());
var import_isBoolean = /* @__PURE__ */ __toESM(require_isBoolean());
var import_isEqual$3 = /* @__PURE__ */ __toESM(require_isEqual());
var _excluded$7 = [
	"option",
	"shapeType",
	"propTransformer",
	"activeClassName",
	"isActive"
];
function _typeof$19(o$1) {
	"@babel/helpers - typeof";
	return _typeof$19 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$2) {
		return typeof o$2;
	} : function(o$2) {
		return o$2 && "function" == typeof Symbol && o$2.constructor === Symbol && o$2 !== Symbol.prototype ? "symbol" : typeof o$2;
	}, _typeof$19(o$1);
}
function _objectWithoutProperties$7(source, excluded) {
	if (source == null) return {};
	var target = _objectWithoutPropertiesLoose$7(source, excluded);
	var key, i$2;
	if (Object.getOwnPropertySymbols) {
		var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
		for (i$2 = 0; i$2 < sourceSymbolKeys.length; i$2++) {
			key = sourceSymbolKeys[i$2];
			if (excluded.indexOf(key) >= 0) continue;
			if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
			target[key] = source[key];
		}
	}
	return target;
}
function _objectWithoutPropertiesLoose$7(source, excluded) {
	if (source == null) return {};
	var target = {};
	for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) {
		if (excluded.indexOf(key) >= 0) continue;
		target[key] = source[key];
	}
	return target;
}
function ownKeys$15(e, r$1) {
	var t$1 = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o$1 = Object.getOwnPropertySymbols(e);
		r$1 && (o$1 = o$1.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t$1.push.apply(t$1, o$1);
	}
	return t$1;
}
function _objectSpread$15(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t$1 = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$15(Object(t$1), !0).forEach(function(r$2) {
			_defineProperty$18(e, r$2, t$1[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t$1)) : ownKeys$15(Object(t$1)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t$1, r$2));
		});
	}
	return e;
}
function _defineProperty$18(obj, key, value) {
	key = _toPropertyKey$18(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$18(t$1) {
	var i$2 = _toPrimitive$18(t$1, "string");
	return "symbol" == _typeof$19(i$2) ? i$2 : i$2 + "";
}
function _toPrimitive$18(t$1, r$1) {
	if ("object" != _typeof$19(t$1) || !t$1) return t$1;
	var e = t$1[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i$2 = e.call(t$1, r$1 || "default");
		if ("object" != _typeof$19(i$2)) return i$2;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t$1);
}
function defaultPropTransformer(option, props) {
	return _objectSpread$15(_objectSpread$15({}, props), option);
}
function isSymbolsProps(shapeType, _elementProps) {
	return shapeType === "symbols";
}
function ShapeSelector(_ref) {
	var shapeType = _ref.shapeType, elementProps = _ref.elementProps;
	switch (shapeType) {
		case "rectangle": return /* @__PURE__ */ import_react.createElement(Rectangle, elementProps);
		case "trapezoid": return /* @__PURE__ */ import_react.createElement(Trapezoid, elementProps);
		case "sector": return /* @__PURE__ */ import_react.createElement(Sector, elementProps);
		case "symbols":
			if (isSymbolsProps(shapeType, elementProps)) return /* @__PURE__ */ import_react.createElement(Symbols, elementProps);
			break;
		default: return null;
	}
}
function getPropsFromShapeOption(option) {
	if (/* @__PURE__ */ (0, import_react.isValidElement)(option)) return option.props;
	return option;
}
function Shape(_ref2) {
	var option = _ref2.option, shapeType = _ref2.shapeType, _ref2$propTransformer = _ref2.propTransformer, propTransformer = _ref2$propTransformer === void 0 ? defaultPropTransformer : _ref2$propTransformer, _ref2$activeClassName = _ref2.activeClassName, activeClassName = _ref2$activeClassName === void 0 ? "recharts-active-shape" : _ref2$activeClassName, isActive = _ref2.isActive, props = _objectWithoutProperties$7(_ref2, _excluded$7);
	var shape;
	if (/* @__PURE__ */ (0, import_react.isValidElement)(option)) shape = /* @__PURE__ */ (0, import_react.cloneElement)(option, _objectSpread$15(_objectSpread$15({}, props), getPropsFromShapeOption(option)));
	else if ((0, import_isFunction$10.default)(option)) shape = option(props);
	else if ((0, import_isPlainObject.default)(option) && !(0, import_isBoolean.default)(option)) {
		var nextProps = propTransformer(option, props);
		shape = /* @__PURE__ */ import_react.createElement(ShapeSelector, {
			shapeType,
			elementProps: nextProps
		});
	} else {
		var elementProps = props;
		shape = /* @__PURE__ */ import_react.createElement(ShapeSelector, {
			shapeType,
			elementProps
		});
	}
	if (isActive) return /* @__PURE__ */ import_react.createElement(Layer, { className: activeClassName }, shape);
	return shape;
}
function isFunnel(graphicalItem, _item) {
	return _item != null && "trapezoids" in graphicalItem.props;
}
function isPie(graphicalItem, _item) {
	return _item != null && "sectors" in graphicalItem.props;
}
function isScatter(graphicalItem, _item) {
	return _item != null && "points" in graphicalItem.props;
}
function compareFunnel(shapeData, activeTooltipItem) {
	var _activeTooltipItem$la, _activeTooltipItem$la2;
	var xMatches = shapeData.x === (activeTooltipItem === null || activeTooltipItem === void 0 || (_activeTooltipItem$la = activeTooltipItem.labelViewBox) === null || _activeTooltipItem$la === void 0 ? void 0 : _activeTooltipItem$la.x) || shapeData.x === activeTooltipItem.x;
	var yMatches = shapeData.y === (activeTooltipItem === null || activeTooltipItem === void 0 || (_activeTooltipItem$la2 = activeTooltipItem.labelViewBox) === null || _activeTooltipItem$la2 === void 0 ? void 0 : _activeTooltipItem$la2.y) || shapeData.y === activeTooltipItem.y;
	return xMatches && yMatches;
}
function comparePie(shapeData, activeTooltipItem) {
	var startAngleMatches = shapeData.endAngle === activeTooltipItem.endAngle;
	var endAngleMatches = shapeData.startAngle === activeTooltipItem.startAngle;
	return startAngleMatches && endAngleMatches;
}
function compareScatter(shapeData, activeTooltipItem) {
	var xMatches = shapeData.x === activeTooltipItem.x;
	var yMatches = shapeData.y === activeTooltipItem.y;
	var zMatches = shapeData.z === activeTooltipItem.z;
	return xMatches && yMatches && zMatches;
}
function getComparisonFn(graphicalItem, activeItem) {
	var comparison;
	if (isFunnel(graphicalItem, activeItem)) comparison = compareFunnel;
	else if (isPie(graphicalItem, activeItem)) comparison = comparePie;
	else if (isScatter(graphicalItem, activeItem)) comparison = compareScatter;
	return comparison;
}
function getShapeDataKey(graphicalItem, activeItem) {
	var shapeKey;
	if (isFunnel(graphicalItem, activeItem)) shapeKey = "trapezoids";
	else if (isPie(graphicalItem, activeItem)) shapeKey = "sectors";
	else if (isScatter(graphicalItem, activeItem)) shapeKey = "points";
	return shapeKey;
}
function getActiveShapeTooltipPayload(graphicalItem, activeItem) {
	if (isFunnel(graphicalItem, activeItem)) {
		var _activeItem$tooltipPa;
		return (_activeItem$tooltipPa = activeItem.tooltipPayload) === null || _activeItem$tooltipPa === void 0 || (_activeItem$tooltipPa = _activeItem$tooltipPa[0]) === null || _activeItem$tooltipPa === void 0 || (_activeItem$tooltipPa = _activeItem$tooltipPa.payload) === null || _activeItem$tooltipPa === void 0 ? void 0 : _activeItem$tooltipPa.payload;
	}
	if (isPie(graphicalItem, activeItem)) {
		var _activeItem$tooltipPa2;
		return (_activeItem$tooltipPa2 = activeItem.tooltipPayload) === null || _activeItem$tooltipPa2 === void 0 || (_activeItem$tooltipPa2 = _activeItem$tooltipPa2[0]) === null || _activeItem$tooltipPa2 === void 0 || (_activeItem$tooltipPa2 = _activeItem$tooltipPa2.payload) === null || _activeItem$tooltipPa2 === void 0 ? void 0 : _activeItem$tooltipPa2.payload;
	}
	if (isScatter(graphicalItem, activeItem)) return activeItem.payload;
	return {};
}
function getActiveShapeIndexForTooltip(_ref3) {
	var activeTooltipItem = _ref3.activeTooltipItem, graphicalItem = _ref3.graphicalItem, itemData = _ref3.itemData;
	var shapeKey = getShapeDataKey(graphicalItem, activeTooltipItem);
	var tooltipPayload = getActiveShapeTooltipPayload(graphicalItem, activeTooltipItem);
	var activeItemMatches = itemData.filter(function(datum, dataIndex) {
		var valuesMatch = (0, import_isEqual$3.default)(tooltipPayload, datum);
		var mouseCoordinateMatches = graphicalItem.props[shapeKey].filter(function(shapeData) {
			return getComparisonFn(graphicalItem, activeTooltipItem)(shapeData, activeTooltipItem);
		});
		var coordinatesMatch = dataIndex === graphicalItem.props[shapeKey].indexOf(mouseCoordinateMatches[mouseCoordinateMatches.length - 1]);
		return valuesMatch && coordinatesMatch;
	});
	return itemData.indexOf(activeItemMatches[activeItemMatches.length - 1]);
}
var require__baseRange = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var nativeCeil = Math.ceil, nativeMax$1 = Math.max;
	function baseRange$1(start, end, step, fromRight) {
		var index = -1, length = nativeMax$1(nativeCeil((end - start) / (step || 1)), 0), result = Array(length);
		while (length--) {
			result[fromRight ? length : ++index] = start;
			start += step;
		}
		return result;
	}
	module.exports = baseRange$1;
}));
var require_toFinite = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var toNumber = require_toNumber();
	var INFINITY = Infinity, MAX_INTEGER = 17976931348623157e292;
	function toFinite$2(value) {
		if (!value) return value === 0 ? value : 0;
		value = toNumber(value);
		if (value === INFINITY || value === -INFINITY) return (value < 0 ? -1 : 1) * MAX_INTEGER;
		return value === value ? value : 0;
	}
	module.exports = toFinite$2;
}));
var require__createRange = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseRange = require__baseRange(), isIterateeCall$2 = require__isIterateeCall(), toFinite$1 = require_toFinite();
	function createRange(fromRight) {
		return function(start, end, step) {
			if (step && typeof step != "number" && isIterateeCall$2(start, end, step)) end = step = void 0;
			start = toFinite$1(start);
			if (end === void 0) {
				end = start;
				start = 0;
			} else end = toFinite$1(end);
			step = step === void 0 ? start < end ? 1 : -1 : toFinite$1(step);
			return baseRange(start, end, step, fromRight);
		};
	}
	module.exports = createRange;
}));
var require_range = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = require__createRange()();
}));
function _typeof$18(o$1) {
	"@babel/helpers - typeof";
	return _typeof$18 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$2) {
		return typeof o$2;
	} : function(o$2) {
		return o$2 && "function" == typeof Symbol && o$2.constructor === Symbol && o$2 !== Symbol.prototype ? "symbol" : typeof o$2;
	}, _typeof$18(o$1);
}
function ownKeys$14(e, r$1) {
	var t$1 = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o$1 = Object.getOwnPropertySymbols(e);
		r$1 && (o$1 = o$1.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t$1.push.apply(t$1, o$1);
	}
	return t$1;
}
function _objectSpread$14(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t$1 = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$14(Object(t$1), !0).forEach(function(r$2) {
			_defineProperty$17(e, r$2, t$1[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t$1)) : ownKeys$14(Object(t$1)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t$1, r$2));
		});
	}
	return e;
}
function _defineProperty$17(obj, key, value) {
	key = _toPropertyKey$17(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$17(t$1) {
	var i$2 = _toPrimitive$17(t$1, "string");
	return "symbol" == _typeof$18(i$2) ? i$2 : i$2 + "";
}
function _toPrimitive$17(t$1, r$1) {
	if ("object" != _typeof$18(t$1) || !t$1) return t$1;
	var e = t$1[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i$2 = e.call(t$1, r$1 || "default");
		if ("object" != _typeof$18(i$2)) return i$2;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t$1);
}
var PREFIX_LIST = [
	"Webkit",
	"Moz",
	"O",
	"ms"
];
var generatePrefixStyle = function generatePrefixStyle$1(name, value) {
	if (!name) return null;
	var camelName = name.replace(/(\w)/, function(v) {
		return v.toUpperCase();
	});
	var result = PREFIX_LIST.reduce(function(res, entry) {
		return _objectSpread$14(_objectSpread$14({}, res), {}, _defineProperty$17({}, entry + camelName, value));
	}, {});
	result[name] = value;
	return result;
};
var import_isFunction$9 = /* @__PURE__ */ __toESM(require_isFunction());
var import_range$1 = /* @__PURE__ */ __toESM(require_range());
function _typeof$17(o$1) {
	"@babel/helpers - typeof";
	return _typeof$17 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$2) {
		return typeof o$2;
	} : function(o$2) {
		return o$2 && "function" == typeof Symbol && o$2.constructor === Symbol && o$2 !== Symbol.prototype ? "symbol" : typeof o$2;
	}, _typeof$17(o$1);
}
function _extends$12() {
	_extends$12 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i$2 = 1; i$2 < arguments.length; i$2++) {
			var source = arguments[i$2];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$12.apply(this, arguments);
}
function ownKeys$13(e, r$1) {
	var t$1 = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o$1 = Object.getOwnPropertySymbols(e);
		r$1 && (o$1 = o$1.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t$1.push.apply(t$1, o$1);
	}
	return t$1;
}
function _objectSpread$13(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t$1 = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$13(Object(t$1), !0).forEach(function(r$2) {
			_defineProperty$16(e, r$2, t$1[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t$1)) : ownKeys$13(Object(t$1)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t$1, r$2));
		});
	}
	return e;
}
function _classCallCheck$12(instance, Constructor) {
	if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties$12(target, props) {
	for (var i$2 = 0; i$2 < props.length; i$2++) {
		var descriptor = props[i$2];
		descriptor.enumerable = descriptor.enumerable || false;
		descriptor.configurable = true;
		if ("value" in descriptor) descriptor.writable = true;
		Object.defineProperty(target, _toPropertyKey$16(descriptor.key), descriptor);
	}
}
function _createClass$12(Constructor, protoProps, staticProps) {
	if (protoProps) _defineProperties$12(Constructor.prototype, protoProps);
	if (staticProps) _defineProperties$12(Constructor, staticProps);
	Object.defineProperty(Constructor, "prototype", { writable: false });
	return Constructor;
}
function _callSuper$10(t$1, o$1, e) {
	return o$1 = _getPrototypeOf$10(o$1), _possibleConstructorReturn$10(t$1, _isNativeReflectConstruct$10() ? Reflect.construct(o$1, e || [], _getPrototypeOf$10(t$1).constructor) : o$1.apply(t$1, e));
}
function _possibleConstructorReturn$10(self$1, call) {
	if (call && (_typeof$17(call) === "object" || typeof call === "function")) return call;
	else if (call !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
	return _assertThisInitialized$10(self$1);
}
function _assertThisInitialized$10(self$1) {
	if (self$1 === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	return self$1;
}
function _isNativeReflectConstruct$10() {
	try {
		var t$1 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
	} catch (t$2) {}
	return (_isNativeReflectConstruct$10 = function _isNativeReflectConstruct$17() {
		return !!t$1;
	})();
}
function _getPrototypeOf$10(o$1) {
	_getPrototypeOf$10 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf$17(o$2) {
		return o$2.__proto__ || Object.getPrototypeOf(o$2);
	};
	return _getPrototypeOf$10(o$1);
}
function _inherits$10(subClass, superClass) {
	if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
	subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: {
		value: subClass,
		writable: true,
		configurable: true
	} });
	Object.defineProperty(subClass, "prototype", { writable: false });
	if (superClass) _setPrototypeOf$10(subClass, superClass);
}
function _setPrototypeOf$10(o$1, p) {
	_setPrototypeOf$10 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf$17(o$2, p$1) {
		o$2.__proto__ = p$1;
		return o$2;
	};
	return _setPrototypeOf$10(o$1, p);
}
function _defineProperty$16(obj, key, value) {
	key = _toPropertyKey$16(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$16(t$1) {
	var i$2 = _toPrimitive$16(t$1, "string");
	return "symbol" == _typeof$17(i$2) ? i$2 : i$2 + "";
}
function _toPrimitive$16(t$1, r$1) {
	if ("object" != _typeof$17(t$1) || !t$1) return t$1;
	var e = t$1[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i$2 = e.call(t$1, r$1 || "default");
		if ("object" != _typeof$17(i$2)) return i$2;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t$1);
}
var createScale = function createScale$1(_ref) {
	var data = _ref.data, startIndex = _ref.startIndex, endIndex = _ref.endIndex, x$1 = _ref.x, width = _ref.width, travellerWidth = _ref.travellerWidth;
	if (!data || !data.length) return {};
	var len = data.length;
	var scale = point().domain((0, import_range$1.default)(0, len)).range([x$1, x$1 + width - travellerWidth]);
	var scaleValues = scale.domain().map(function(entry) {
		return scale(entry);
	});
	return {
		isTextActive: false,
		isSlideMoving: false,
		isTravellerMoving: false,
		isTravellerFocused: false,
		startX: scale(startIndex),
		endX: scale(endIndex),
		scale,
		scaleValues
	};
};
var isTouch = function isTouch$1(e) {
	return e.changedTouches && !!e.changedTouches.length;
};
var Brush = /* @__PURE__ */ function(_PureComponent) {
	function Brush$1(props) {
		var _this;
		_classCallCheck$12(this, Brush$1);
		_this = _callSuper$10(this, Brush$1, [props]);
		_defineProperty$16(_this, "handleDrag", function(e) {
			if (_this.leaveTimer) {
				clearTimeout(_this.leaveTimer);
				_this.leaveTimer = null;
			}
			if (_this.state.isTravellerMoving) _this.handleTravellerMove(e);
			else if (_this.state.isSlideMoving) _this.handleSlideDrag(e);
		});
		_defineProperty$16(_this, "handleTouchMove", function(e) {
			if (e.changedTouches != null && e.changedTouches.length > 0) _this.handleDrag(e.changedTouches[0]);
		});
		_defineProperty$16(_this, "handleDragEnd", function() {
			_this.setState({
				isTravellerMoving: false,
				isSlideMoving: false
			}, function() {
				var _this$props = _this.props, endIndex = _this$props.endIndex, onDragEnd = _this$props.onDragEnd, startIndex = _this$props.startIndex;
				onDragEnd === null || onDragEnd === void 0 || onDragEnd({
					endIndex,
					startIndex
				});
			});
			_this.detachDragEndListener();
		});
		_defineProperty$16(_this, "handleLeaveWrapper", function() {
			if (_this.state.isTravellerMoving || _this.state.isSlideMoving) _this.leaveTimer = window.setTimeout(_this.handleDragEnd, _this.props.leaveTimeOut);
		});
		_defineProperty$16(_this, "handleEnterSlideOrTraveller", function() {
			_this.setState({ isTextActive: true });
		});
		_defineProperty$16(_this, "handleLeaveSlideOrTraveller", function() {
			_this.setState({ isTextActive: false });
		});
		_defineProperty$16(_this, "handleSlideDragStart", function(e) {
			var event = isTouch(e) ? e.changedTouches[0] : e;
			_this.setState({
				isTravellerMoving: false,
				isSlideMoving: true,
				slideMoveStartX: event.pageX
			});
			_this.attachDragEndListener();
		});
		_this.travellerDragStartHandlers = {
			startX: _this.handleTravellerDragStart.bind(_this, "startX"),
			endX: _this.handleTravellerDragStart.bind(_this, "endX")
		};
		_this.state = {};
		return _this;
	}
	_inherits$10(Brush$1, _PureComponent);
	return _createClass$12(Brush$1, [
		{
			key: "componentWillUnmount",
			value: function componentWillUnmount() {
				if (this.leaveTimer) {
					clearTimeout(this.leaveTimer);
					this.leaveTimer = null;
				}
				this.detachDragEndListener();
			}
		},
		{
			key: "getIndex",
			value: function getIndex(_ref2) {
				var startX = _ref2.startX, endX = _ref2.endX;
				var scaleValues = this.state.scaleValues;
				var _this$props2 = this.props, gap = _this$props2.gap;
				var lastIndex = _this$props2.data.length - 1;
				var min$3 = Math.min(startX, endX);
				var max$4 = Math.max(startX, endX);
				var minIndex = Brush$1.getIndexInRange(scaleValues, min$3);
				var maxIndex = Brush$1.getIndexInRange(scaleValues, max$4);
				return {
					startIndex: minIndex - minIndex % gap,
					endIndex: maxIndex === lastIndex ? lastIndex : maxIndex - maxIndex % gap
				};
			}
		},
		{
			key: "getTextOfTick",
			value: function getTextOfTick(index) {
				var _this$props3 = this.props, data = _this$props3.data, tickFormatter = _this$props3.tickFormatter, dataKey = _this$props3.dataKey;
				var text = getValueByDataKey(data[index], dataKey, index);
				return (0, import_isFunction$9.default)(tickFormatter) ? tickFormatter(text, index) : text;
			}
		},
		{
			key: "attachDragEndListener",
			value: function attachDragEndListener() {
				window.addEventListener("mouseup", this.handleDragEnd, true);
				window.addEventListener("touchend", this.handleDragEnd, true);
				window.addEventListener("mousemove", this.handleDrag, true);
			}
		},
		{
			key: "detachDragEndListener",
			value: function detachDragEndListener() {
				window.removeEventListener("mouseup", this.handleDragEnd, true);
				window.removeEventListener("touchend", this.handleDragEnd, true);
				window.removeEventListener("mousemove", this.handleDrag, true);
			}
		},
		{
			key: "handleSlideDrag",
			value: function handleSlideDrag(e) {
				var _this$state = this.state, slideMoveStartX = _this$state.slideMoveStartX, startX = _this$state.startX, endX = _this$state.endX;
				var _this$props4 = this.props, x$1 = _this$props4.x, width = _this$props4.width, travellerWidth = _this$props4.travellerWidth, startIndex = _this$props4.startIndex, endIndex = _this$props4.endIndex, onChange = _this$props4.onChange;
				var delta = e.pageX - slideMoveStartX;
				if (delta > 0) delta = Math.min(delta, x$1 + width - travellerWidth - endX, x$1 + width - travellerWidth - startX);
				else if (delta < 0) delta = Math.max(delta, x$1 - startX, x$1 - endX);
				var newIndex = this.getIndex({
					startX: startX + delta,
					endX: endX + delta
				});
				if ((newIndex.startIndex !== startIndex || newIndex.endIndex !== endIndex) && onChange) onChange(newIndex);
				this.setState({
					startX: startX + delta,
					endX: endX + delta,
					slideMoveStartX: e.pageX
				});
			}
		},
		{
			key: "handleTravellerDragStart",
			value: function handleTravellerDragStart(id, e) {
				var event = isTouch(e) ? e.changedTouches[0] : e;
				this.setState({
					isSlideMoving: false,
					isTravellerMoving: true,
					movingTravellerId: id,
					brushMoveStartX: event.pageX
				});
				this.attachDragEndListener();
			}
		},
		{
			key: "handleTravellerMove",
			value: function handleTravellerMove(e) {
				var _this$state2 = this.state, brushMoveStartX = _this$state2.brushMoveStartX, movingTravellerId = _this$state2.movingTravellerId, endX = _this$state2.endX, startX = _this$state2.startX;
				var prevValue = this.state[movingTravellerId];
				var _this$props5 = this.props, x$1 = _this$props5.x, width = _this$props5.width, travellerWidth = _this$props5.travellerWidth, onChange = _this$props5.onChange, gap = _this$props5.gap, data = _this$props5.data;
				var params = {
					startX: this.state.startX,
					endX: this.state.endX
				};
				var delta = e.pageX - brushMoveStartX;
				if (delta > 0) delta = Math.min(delta, x$1 + width - travellerWidth - prevValue);
				else if (delta < 0) delta = Math.max(delta, x$1 - prevValue);
				params[movingTravellerId] = prevValue + delta;
				var newIndex = this.getIndex(params);
				var startIndex = newIndex.startIndex, endIndex = newIndex.endIndex;
				var isFullGap = function isFullGap$1() {
					var lastIndex = data.length - 1;
					if (movingTravellerId === "startX" && (endX > startX ? startIndex % gap === 0 : endIndex % gap === 0) || endX < startX && endIndex === lastIndex || movingTravellerId === "endX" && (endX > startX ? endIndex % gap === 0 : startIndex % gap === 0) || endX > startX && endIndex === lastIndex) return true;
					return false;
				};
				this.setState(_defineProperty$16(_defineProperty$16({}, movingTravellerId, prevValue + delta), "brushMoveStartX", e.pageX), function() {
					if (onChange) {
						if (isFullGap()) onChange(newIndex);
					}
				});
			}
		},
		{
			key: "handleTravellerMoveKeyboard",
			value: function handleTravellerMoveKeyboard(direction, id) {
				var _this2 = this;
				var _this$state3 = this.state, scaleValues = _this$state3.scaleValues, startX = _this$state3.startX, endX = _this$state3.endX;
				var currentScaleValue = this.state[id];
				var currentIndex = scaleValues.indexOf(currentScaleValue);
				if (currentIndex === -1) return;
				var newIndex = currentIndex + direction;
				if (newIndex === -1 || newIndex >= scaleValues.length) return;
				var newScaleValue = scaleValues[newIndex];
				if (id === "startX" && newScaleValue >= endX || id === "endX" && newScaleValue <= startX) return;
				this.setState(_defineProperty$16({}, id, newScaleValue), function() {
					_this2.props.onChange(_this2.getIndex({
						startX: _this2.state.startX,
						endX: _this2.state.endX
					}));
				});
			}
		},
		{
			key: "renderBackground",
			value: function renderBackground() {
				var _this$props6 = this.props, x$1 = _this$props6.x, y$1 = _this$props6.y, width = _this$props6.width, height = _this$props6.height, fill = _this$props6.fill, stroke = _this$props6.stroke;
				return /* @__PURE__ */ import_react.createElement("rect", {
					stroke,
					fill,
					x: x$1,
					y: y$1,
					width,
					height
				});
			}
		},
		{
			key: "renderPanorama",
			value: function renderPanorama() {
				var _this$props7 = this.props, x$1 = _this$props7.x, y$1 = _this$props7.y, width = _this$props7.width, height = _this$props7.height, data = _this$props7.data, children = _this$props7.children, padding = _this$props7.padding;
				var chartElement = import_react.Children.only(children);
				if (!chartElement) return null;
				return /* @__PURE__ */ import_react.cloneElement(chartElement, {
					x: x$1,
					y: y$1,
					width,
					height,
					margin: padding,
					compact: true,
					data
				});
			}
		},
		{
			key: "renderTravellerLayer",
			value: function renderTravellerLayer(travellerX, id) {
				var _data$startIndex, _data$endIndex, _this3 = this;
				var _this$props8 = this.props, y$1 = _this$props8.y, travellerWidth = _this$props8.travellerWidth, height = _this$props8.height, traveller = _this$props8.traveller, ariaLabel = _this$props8.ariaLabel, data = _this$props8.data, startIndex = _this$props8.startIndex, endIndex = _this$props8.endIndex;
				var x$1 = Math.max(travellerX, this.props.x);
				var travellerProps = _objectSpread$13(_objectSpread$13({}, filterProps(this.props, false)), {}, {
					x: x$1,
					y: y$1,
					width: travellerWidth,
					height
				});
				var ariaLabelBrush = ariaLabel || "Min value: ".concat((_data$startIndex = data[startIndex]) === null || _data$startIndex === void 0 ? void 0 : _data$startIndex.name, ", Max value: ").concat((_data$endIndex = data[endIndex]) === null || _data$endIndex === void 0 ? void 0 : _data$endIndex.name);
				return /* @__PURE__ */ import_react.createElement(Layer, {
					tabIndex: 0,
					role: "slider",
					"aria-label": ariaLabelBrush,
					"aria-valuenow": travellerX,
					className: "recharts-brush-traveller",
					onMouseEnter: this.handleEnterSlideOrTraveller,
					onMouseLeave: this.handleLeaveSlideOrTraveller,
					onMouseDown: this.travellerDragStartHandlers[id],
					onTouchStart: this.travellerDragStartHandlers[id],
					onKeyDown: function onKeyDown(e) {
						if (!["ArrowLeft", "ArrowRight"].includes(e.key)) return;
						e.preventDefault();
						e.stopPropagation();
						_this3.handleTravellerMoveKeyboard(e.key === "ArrowRight" ? 1 : -1, id);
					},
					onFocus: function onFocus() {
						_this3.setState({ isTravellerFocused: true });
					},
					onBlur: function onBlur() {
						_this3.setState({ isTravellerFocused: false });
					},
					style: { cursor: "col-resize" }
				}, Brush$1.renderTraveller(traveller, travellerProps));
			}
		},
		{
			key: "renderSlide",
			value: function renderSlide(startX, endX) {
				var _this$props9 = this.props, y$1 = _this$props9.y, height = _this$props9.height, stroke = _this$props9.stroke, travellerWidth = _this$props9.travellerWidth;
				var x$1 = Math.min(startX, endX) + travellerWidth;
				var width = Math.max(Math.abs(endX - startX) - travellerWidth, 0);
				return /* @__PURE__ */ import_react.createElement("rect", {
					className: "recharts-brush-slide",
					onMouseEnter: this.handleEnterSlideOrTraveller,
					onMouseLeave: this.handleLeaveSlideOrTraveller,
					onMouseDown: this.handleSlideDragStart,
					onTouchStart: this.handleSlideDragStart,
					style: { cursor: "move" },
					stroke: "none",
					fill: stroke,
					fillOpacity: .2,
					x: x$1,
					y: y$1,
					width,
					height
				});
			}
		},
		{
			key: "renderText",
			value: function renderText() {
				var _this$props10 = this.props, startIndex = _this$props10.startIndex, endIndex = _this$props10.endIndex, y$1 = _this$props10.y, height = _this$props10.height, travellerWidth = _this$props10.travellerWidth, stroke = _this$props10.stroke;
				var _this$state4 = this.state, startX = _this$state4.startX, endX = _this$state4.endX;
				var offset = 5;
				var attrs = {
					pointerEvents: "none",
					fill: stroke
				};
				return /* @__PURE__ */ import_react.createElement(Layer, { className: "recharts-brush-texts" }, /* @__PURE__ */ import_react.createElement(Text, _extends$12({
					textAnchor: "end",
					verticalAnchor: "middle",
					x: Math.min(startX, endX) - offset,
					y: y$1 + height / 2
				}, attrs), this.getTextOfTick(startIndex)), /* @__PURE__ */ import_react.createElement(Text, _extends$12({
					textAnchor: "start",
					verticalAnchor: "middle",
					x: Math.max(startX, endX) + travellerWidth + offset,
					y: y$1 + height / 2
				}, attrs), this.getTextOfTick(endIndex)));
			}
		},
		{
			key: "render",
			value: function render() {
				var _this$props11 = this.props, data = _this$props11.data, className = _this$props11.className, children = _this$props11.children, x$1 = _this$props11.x, y$1 = _this$props11.y, width = _this$props11.width, height = _this$props11.height, alwaysShowText = _this$props11.alwaysShowText;
				var _this$state5 = this.state, startX = _this$state5.startX, endX = _this$state5.endX, isTextActive = _this$state5.isTextActive, isSlideMoving = _this$state5.isSlideMoving, isTravellerMoving = _this$state5.isTravellerMoving, isTravellerFocused = _this$state5.isTravellerFocused;
				if (!data || !data.length || !isNumber(x$1) || !isNumber(y$1) || !isNumber(width) || !isNumber(height) || width <= 0 || height <= 0) return null;
				var layerClass = clsx_default("recharts-brush", className);
				var isPanoramic = import_react.Children.count(children) === 1;
				var style = generatePrefixStyle("userSelect", "none");
				return /* @__PURE__ */ import_react.createElement(Layer, {
					className: layerClass,
					onMouseLeave: this.handleLeaveWrapper,
					onTouchMove: this.handleTouchMove,
					style
				}, this.renderBackground(), isPanoramic && this.renderPanorama(), this.renderSlide(startX, endX), this.renderTravellerLayer(startX, "startX"), this.renderTravellerLayer(endX, "endX"), (isTextActive || isSlideMoving || isTravellerMoving || isTravellerFocused || alwaysShowText) && this.renderText());
			}
		}
	], [
		{
			key: "renderDefaultTraveller",
			value: function renderDefaultTraveller(props) {
				var x$1 = props.x, y$1 = props.y, width = props.width, height = props.height, stroke = props.stroke;
				var lineY = Math.floor(y$1 + height / 2) - 1;
				return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement("rect", {
					x: x$1,
					y: y$1,
					width,
					height,
					fill: stroke,
					stroke: "none"
				}), /* @__PURE__ */ import_react.createElement("line", {
					x1: x$1 + 1,
					y1: lineY,
					x2: x$1 + width - 1,
					y2: lineY,
					fill: "none",
					stroke: "#fff"
				}), /* @__PURE__ */ import_react.createElement("line", {
					x1: x$1 + 1,
					y1: lineY + 2,
					x2: x$1 + width - 1,
					y2: lineY + 2,
					fill: "none",
					stroke: "#fff"
				}));
			}
		},
		{
			key: "renderTraveller",
			value: function renderTraveller(option, props) {
				var rectangle;
				if (/* @__PURE__ */ import_react.isValidElement(option)) rectangle = /* @__PURE__ */ import_react.cloneElement(option, props);
				else if ((0, import_isFunction$9.default)(option)) rectangle = option(props);
				else rectangle = Brush$1.renderDefaultTraveller(props);
				return rectangle;
			}
		},
		{
			key: "getDerivedStateFromProps",
			value: function getDerivedStateFromProps(nextProps, prevState) {
				var data = nextProps.data, width = nextProps.width, x$1 = nextProps.x, travellerWidth = nextProps.travellerWidth, updateId = nextProps.updateId, startIndex = nextProps.startIndex, endIndex = nextProps.endIndex;
				if (data !== prevState.prevData || updateId !== prevState.prevUpdateId) return _objectSpread$13({
					prevData: data,
					prevTravellerWidth: travellerWidth,
					prevUpdateId: updateId,
					prevX: x$1,
					prevWidth: width
				}, data && data.length ? createScale({
					data,
					width,
					x: x$1,
					travellerWidth,
					startIndex,
					endIndex
				}) : {
					scale: null,
					scaleValues: null
				});
				if (prevState.scale && (width !== prevState.prevWidth || x$1 !== prevState.prevX || travellerWidth !== prevState.prevTravellerWidth)) {
					prevState.scale.range([x$1, x$1 + width - travellerWidth]);
					var scaleValues = prevState.scale.domain().map(function(entry) {
						return prevState.scale(entry);
					});
					return {
						prevData: data,
						prevTravellerWidth: travellerWidth,
						prevUpdateId: updateId,
						prevX: x$1,
						prevWidth: width,
						startX: prevState.scale(nextProps.startIndex),
						endX: prevState.scale(nextProps.endIndex),
						scaleValues
					};
				}
				return null;
			}
		},
		{
			key: "getIndexInRange",
			value: function getIndexInRange(valueRange, x$1) {
				var len = valueRange.length;
				var start = 0;
				var end = len - 1;
				while (end - start > 1) {
					var middle = Math.floor((start + end) / 2);
					if (valueRange[middle] > x$1) end = middle;
					else start = middle;
				}
				return x$1 >= valueRange[end] ? end : start;
			}
		}
	]);
}(import_react.PureComponent);
_defineProperty$16(Brush, "displayName", "Brush");
_defineProperty$16(Brush, "defaultProps", {
	height: 40,
	travellerWidth: 5,
	gap: 1,
	fill: "#fff",
	stroke: "#666",
	padding: {
		top: 1,
		right: 1,
		bottom: 1,
		left: 1
	},
	leaveTimeOut: 1e3,
	alwaysShowText: false
});
var require__baseSome = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseEach$1 = require__baseEach();
	function baseSome$1(collection, predicate) {
		var result;
		baseEach$1(collection, function(value, index, collection$1) {
			result = predicate(value, index, collection$1);
			return !result;
		});
		return !!result;
	}
	module.exports = baseSome$1;
}));
var require_some = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var arraySome = require__arraySome(), baseIteratee$4 = require__baseIteratee(), baseSome = require__baseSome(), isArray$1 = require_isArray(), isIterateeCall$1 = require__isIterateeCall();
	function some$1(collection, predicate, guard) {
		var func = isArray$1(collection) ? arraySome : baseSome;
		if (guard && isIterateeCall$1(collection, predicate, guard)) predicate = void 0;
		return func(collection, baseIteratee$4(predicate, 3));
	}
	module.exports = some$1;
}));
var ifOverflowMatches = function ifOverflowMatches$1(props, value) {
	var alwaysShow = props.alwaysShow;
	var ifOverflow = props.ifOverflow;
	if (alwaysShow) ifOverflow = "extendDomain";
	return ifOverflow === value;
};
var require__baseAssignValue = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var defineProperty = require__defineProperty();
	function baseAssignValue$1(object$1, key, value) {
		if (key == "__proto__" && defineProperty) defineProperty(object$1, key, {
			"configurable": true,
			"enumerable": true,
			"value": value,
			"writable": true
		});
		else object$1[key] = value;
	}
	module.exports = baseAssignValue$1;
}));
var require_mapValues = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseAssignValue = require__baseAssignValue(), baseForOwn = require__baseForOwn(), baseIteratee$3 = require__baseIteratee();
	function mapValues$1(object$1, iteratee) {
		var result = {};
		iteratee = baseIteratee$3(iteratee, 3);
		baseForOwn(object$1, function(value, key, object$2) {
			baseAssignValue(result, key, iteratee(value, key, object$2));
		});
		return result;
	}
	module.exports = mapValues$1;
}));
var require__arrayEvery = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function arrayEvery$1(array$1, predicate) {
		var index = -1, length = array$1 == null ? 0 : array$1.length;
		while (++index < length) if (!predicate(array$1[index], index, array$1)) return false;
		return true;
	}
	module.exports = arrayEvery$1;
}));
var require__baseEvery = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseEach = require__baseEach();
	function baseEvery$1(collection, predicate) {
		var result = true;
		baseEach(collection, function(value, index, collection$1) {
			result = !!predicate(value, index, collection$1);
			return result;
		});
		return result;
	}
	module.exports = baseEvery$1;
}));
var require_every = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var arrayEvery = require__arrayEvery(), baseEvery = require__baseEvery(), baseIteratee$2 = require__baseIteratee(), isArray = require_isArray(), isIterateeCall = require__isIterateeCall();
	function every$2(collection, predicate, guard) {
		var func = isArray(collection) ? arrayEvery : baseEvery;
		if (guard && isIterateeCall(collection, predicate, guard)) predicate = void 0;
		return func(collection, baseIteratee$2(predicate, 3));
	}
	module.exports = every$2;
}));
var _excluded$6 = ["x", "y"];
function _typeof$16(o$1) {
	"@babel/helpers - typeof";
	return _typeof$16 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$2) {
		return typeof o$2;
	} : function(o$2) {
		return o$2 && "function" == typeof Symbol && o$2.constructor === Symbol && o$2 !== Symbol.prototype ? "symbol" : typeof o$2;
	}, _typeof$16(o$1);
}
function _extends$11() {
	_extends$11 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i$2 = 1; i$2 < arguments.length; i$2++) {
			var source = arguments[i$2];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$11.apply(this, arguments);
}
function ownKeys$12(e, r$1) {
	var t$1 = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o$1 = Object.getOwnPropertySymbols(e);
		r$1 && (o$1 = o$1.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t$1.push.apply(t$1, o$1);
	}
	return t$1;
}
function _objectSpread$12(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t$1 = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$12(Object(t$1), !0).forEach(function(r$2) {
			_defineProperty$15(e, r$2, t$1[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t$1)) : ownKeys$12(Object(t$1)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t$1, r$2));
		});
	}
	return e;
}
function _defineProperty$15(obj, key, value) {
	key = _toPropertyKey$15(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$15(t$1) {
	var i$2 = _toPrimitive$15(t$1, "string");
	return "symbol" == _typeof$16(i$2) ? i$2 : i$2 + "";
}
function _toPrimitive$15(t$1, r$1) {
	if ("object" != _typeof$16(t$1) || !t$1) return t$1;
	var e = t$1[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i$2 = e.call(t$1, r$1 || "default");
		if ("object" != _typeof$16(i$2)) return i$2;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t$1);
}
function _objectWithoutProperties$6(source, excluded) {
	if (source == null) return {};
	var target = _objectWithoutPropertiesLoose$6(source, excluded);
	var key, i$2;
	if (Object.getOwnPropertySymbols) {
		var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
		for (i$2 = 0; i$2 < sourceSymbolKeys.length; i$2++) {
			key = sourceSymbolKeys[i$2];
			if (excluded.indexOf(key) >= 0) continue;
			if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
			target[key] = source[key];
		}
	}
	return target;
}
function _objectWithoutPropertiesLoose$6(source, excluded) {
	if (source == null) return {};
	var target = {};
	for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) {
		if (excluded.indexOf(key) >= 0) continue;
		target[key] = source[key];
	}
	return target;
}
function typeguardBarRectangleProps(_ref, props) {
	var xProp = _ref.x, yProp = _ref.y, option = _objectWithoutProperties$6(_ref, _excluded$6);
	var xValue = "".concat(xProp);
	var x$1 = parseInt(xValue, 10);
	var yValue = "".concat(yProp);
	var y$1 = parseInt(yValue, 10);
	var heightValue = "".concat(props.height || option.height);
	var height = parseInt(heightValue, 10);
	var widthValue = "".concat(props.width || option.width);
	var width = parseInt(widthValue, 10);
	return _objectSpread$12(_objectSpread$12(_objectSpread$12(_objectSpread$12(_objectSpread$12({}, props), option), x$1 ? { x: x$1 } : {}), y$1 ? { y: y$1 } : {}), {}, {
		height,
		width,
		name: props.name,
		radius: props.radius
	});
}
function BarRectangle(props) {
	return /* @__PURE__ */ import_react.createElement(Shape, _extends$11({
		shapeType: "rectangle",
		propTransformer: typeguardBarRectangleProps,
		activeClassName: "recharts-active-bar"
	}, props));
}
var minPointSizeCallback = function minPointSizeCallback$1(minPointSize) {
	var defaultValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
	return function(value, index) {
		if (typeof minPointSize === "number") return minPointSize;
		var isValueNumberOrNil = isNumber(value) || isNullish(value);
		if (isValueNumberOrNil) return minPointSize(value, index);
		!isValueNumberOrNil && invariant(false, "minPointSize callback function received a value with type of ".concat(_typeof$16(value), ". Currently only numbers or null/undefined are supported."));
		return defaultValue;
	};
};
var import_isEqual$2 = /* @__PURE__ */ __toESM(require_isEqual());
var import_isNil$3 = /* @__PURE__ */ __toESM(require_isNil());
var _excluded$5 = ["value", "background"];
var _Bar;
function _typeof$15(o$1) {
	"@babel/helpers - typeof";
	return _typeof$15 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$2) {
		return typeof o$2;
	} : function(o$2) {
		return o$2 && "function" == typeof Symbol && o$2.constructor === Symbol && o$2 !== Symbol.prototype ? "symbol" : typeof o$2;
	}, _typeof$15(o$1);
}
function _objectWithoutProperties$5(source, excluded) {
	if (source == null) return {};
	var target = _objectWithoutPropertiesLoose$5(source, excluded);
	var key, i$2;
	if (Object.getOwnPropertySymbols) {
		var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
		for (i$2 = 0; i$2 < sourceSymbolKeys.length; i$2++) {
			key = sourceSymbolKeys[i$2];
			if (excluded.indexOf(key) >= 0) continue;
			if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
			target[key] = source[key];
		}
	}
	return target;
}
function _objectWithoutPropertiesLoose$5(source, excluded) {
	if (source == null) return {};
	var target = {};
	for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) {
		if (excluded.indexOf(key) >= 0) continue;
		target[key] = source[key];
	}
	return target;
}
function _extends$10() {
	_extends$10 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i$2 = 1; i$2 < arguments.length; i$2++) {
			var source = arguments[i$2];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$10.apply(this, arguments);
}
function ownKeys$11(e, r$1) {
	var t$1 = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o$1 = Object.getOwnPropertySymbols(e);
		r$1 && (o$1 = o$1.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t$1.push.apply(t$1, o$1);
	}
	return t$1;
}
function _objectSpread$11(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t$1 = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$11(Object(t$1), !0).forEach(function(r$2) {
			_defineProperty$14(e, r$2, t$1[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t$1)) : ownKeys$11(Object(t$1)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t$1, r$2));
		});
	}
	return e;
}
function _classCallCheck$11(instance, Constructor) {
	if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties$11(target, props) {
	for (var i$2 = 0; i$2 < props.length; i$2++) {
		var descriptor = props[i$2];
		descriptor.enumerable = descriptor.enumerable || false;
		descriptor.configurable = true;
		if ("value" in descriptor) descriptor.writable = true;
		Object.defineProperty(target, _toPropertyKey$14(descriptor.key), descriptor);
	}
}
function _createClass$11(Constructor, protoProps, staticProps) {
	if (protoProps) _defineProperties$11(Constructor.prototype, protoProps);
	if (staticProps) _defineProperties$11(Constructor, staticProps);
	Object.defineProperty(Constructor, "prototype", { writable: false });
	return Constructor;
}
function _callSuper$9(t$1, o$1, e) {
	return o$1 = _getPrototypeOf$9(o$1), _possibleConstructorReturn$9(t$1, _isNativeReflectConstruct$9() ? Reflect.construct(o$1, e || [], _getPrototypeOf$9(t$1).constructor) : o$1.apply(t$1, e));
}
function _possibleConstructorReturn$9(self$1, call) {
	if (call && (_typeof$15(call) === "object" || typeof call === "function")) return call;
	else if (call !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
	return _assertThisInitialized$9(self$1);
}
function _assertThisInitialized$9(self$1) {
	if (self$1 === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	return self$1;
}
function _isNativeReflectConstruct$9() {
	try {
		var t$1 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
	} catch (t$2) {}
	return (_isNativeReflectConstruct$9 = function _isNativeReflectConstruct$17() {
		return !!t$1;
	})();
}
function _getPrototypeOf$9(o$1) {
	_getPrototypeOf$9 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf$17(o$2) {
		return o$2.__proto__ || Object.getPrototypeOf(o$2);
	};
	return _getPrototypeOf$9(o$1);
}
function _inherits$9(subClass, superClass) {
	if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
	subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: {
		value: subClass,
		writable: true,
		configurable: true
	} });
	Object.defineProperty(subClass, "prototype", { writable: false });
	if (superClass) _setPrototypeOf$9(subClass, superClass);
}
function _setPrototypeOf$9(o$1, p) {
	_setPrototypeOf$9 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf$17(o$2, p$1) {
		o$2.__proto__ = p$1;
		return o$2;
	};
	return _setPrototypeOf$9(o$1, p);
}
function _defineProperty$14(obj, key, value) {
	key = _toPropertyKey$14(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$14(t$1) {
	var i$2 = _toPrimitive$14(t$1, "string");
	return "symbol" == _typeof$15(i$2) ? i$2 : i$2 + "";
}
function _toPrimitive$14(t$1, r$1) {
	if ("object" != _typeof$15(t$1) || !t$1) return t$1;
	var e = t$1[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i$2 = e.call(t$1, r$1 || "default");
		if ("object" != _typeof$15(i$2)) return i$2;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t$1);
}
var Bar = /* @__PURE__ */ function(_PureComponent) {
	function Bar$1() {
		var _this;
		_classCallCheck$11(this, Bar$1);
		for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
		_this = _callSuper$9(this, Bar$1, [].concat(args));
		_defineProperty$14(_this, "state", { isAnimationFinished: false });
		_defineProperty$14(_this, "id", uniqueId("recharts-bar-"));
		_defineProperty$14(_this, "handleAnimationEnd", function() {
			var onAnimationEnd = _this.props.onAnimationEnd;
			_this.setState({ isAnimationFinished: true });
			if (onAnimationEnd) onAnimationEnd();
		});
		_defineProperty$14(_this, "handleAnimationStart", function() {
			var onAnimationStart = _this.props.onAnimationStart;
			_this.setState({ isAnimationFinished: false });
			if (onAnimationStart) onAnimationStart();
		});
		return _this;
	}
	_inherits$9(Bar$1, _PureComponent);
	return _createClass$11(Bar$1, [
		{
			key: "renderRectanglesStatically",
			value: function renderRectanglesStatically(data) {
				var _this2 = this;
				var _this$props = this.props, shape = _this$props.shape, dataKey = _this$props.dataKey, activeIndex = _this$props.activeIndex, activeBar = _this$props.activeBar;
				var baseProps = filterProps(this.props, false);
				return data && data.map(function(entry, i$2) {
					var isActive = i$2 === activeIndex;
					var option = isActive ? activeBar : shape;
					var props = _objectSpread$11(_objectSpread$11(_objectSpread$11({}, baseProps), entry), {}, {
						isActive,
						option,
						index: i$2,
						dataKey,
						onAnimationStart: _this2.handleAnimationStart,
						onAnimationEnd: _this2.handleAnimationEnd
					});
					return /* @__PURE__ */ import_react.createElement(Layer, _extends$10({ className: "recharts-bar-rectangle" }, adaptEventsOfChild(_this2.props, entry, i$2), { key: "rectangle-".concat(entry === null || entry === void 0 ? void 0 : entry.x, "-").concat(entry === null || entry === void 0 ? void 0 : entry.y, "-").concat(entry === null || entry === void 0 ? void 0 : entry.value, "-").concat(i$2) }), /* @__PURE__ */ import_react.createElement(BarRectangle, props));
				});
			}
		},
		{
			key: "renderRectanglesWithAnimation",
			value: function renderRectanglesWithAnimation() {
				var _this3 = this;
				var _this$props2 = this.props, data = _this$props2.data, layout = _this$props2.layout, isAnimationActive = _this$props2.isAnimationActive, animationBegin = _this$props2.animationBegin, animationDuration = _this$props2.animationDuration, animationEasing = _this$props2.animationEasing, animationId = _this$props2.animationId;
				var prevData = this.state.prevData;
				return /* @__PURE__ */ import_react.createElement(es6_default, {
					begin: animationBegin,
					duration: animationDuration,
					isActive: isAnimationActive,
					easing: animationEasing,
					from: { t: 0 },
					to: { t: 1 },
					key: "bar-".concat(animationId),
					onAnimationEnd: this.handleAnimationEnd,
					onAnimationStart: this.handleAnimationStart
				}, function(_ref) {
					var t$1 = _ref.t;
					var stepData = data.map(function(entry, index) {
						var prev = prevData && prevData[index];
						if (prev) {
							var interpolatorX = interpolateNumber(prev.x, entry.x);
							var interpolatorY = interpolateNumber(prev.y, entry.y);
							var interpolatorWidth = interpolateNumber(prev.width, entry.width);
							var interpolatorHeight = interpolateNumber(prev.height, entry.height);
							return _objectSpread$11(_objectSpread$11({}, entry), {}, {
								x: interpolatorX(t$1),
								y: interpolatorY(t$1),
								width: interpolatorWidth(t$1),
								height: interpolatorHeight(t$1)
							});
						}
						if (layout === "horizontal") {
							var h = interpolateNumber(0, entry.height)(t$1);
							return _objectSpread$11(_objectSpread$11({}, entry), {}, {
								y: entry.y + entry.height - h,
								height: h
							});
						}
						var w = interpolateNumber(0, entry.width)(t$1);
						return _objectSpread$11(_objectSpread$11({}, entry), {}, { width: w });
					});
					return /* @__PURE__ */ import_react.createElement(Layer, null, _this3.renderRectanglesStatically(stepData));
				});
			}
		},
		{
			key: "renderRectangles",
			value: function renderRectangles() {
				var _this$props3 = this.props, data = _this$props3.data, isAnimationActive = _this$props3.isAnimationActive;
				var prevData = this.state.prevData;
				if (isAnimationActive && data && data.length && (!prevData || !(0, import_isEqual$2.default)(prevData, data))) return this.renderRectanglesWithAnimation();
				return this.renderRectanglesStatically(data);
			}
		},
		{
			key: "renderBackground",
			value: function renderBackground() {
				var _this4 = this;
				var _this$props4 = this.props, data = _this$props4.data, dataKey = _this$props4.dataKey, activeIndex = _this$props4.activeIndex;
				var backgroundProps = filterProps(this.props.background, false);
				return data.map(function(entry, i$2) {
					entry.value;
					var background = entry.background, rest = _objectWithoutProperties$5(entry, _excluded$5);
					if (!background) return null;
					var props = _objectSpread$11(_objectSpread$11(_objectSpread$11(_objectSpread$11(_objectSpread$11({}, rest), {}, { fill: "#eee" }, background), backgroundProps), adaptEventsOfChild(_this4.props, entry, i$2)), {}, {
						onAnimationStart: _this4.handleAnimationStart,
						onAnimationEnd: _this4.handleAnimationEnd,
						dataKey,
						index: i$2,
						className: "recharts-bar-background-rectangle"
					});
					return /* @__PURE__ */ import_react.createElement(BarRectangle, _extends$10({
						key: "background-bar-".concat(i$2),
						option: _this4.props.background,
						isActive: i$2 === activeIndex
					}, props));
				});
			}
		},
		{
			key: "renderErrorBar",
			value: function renderErrorBar(needClip, clipPathId) {
				if (this.props.isAnimationActive && !this.state.isAnimationFinished) return null;
				var _this$props5 = this.props, data = _this$props5.data, xAxis = _this$props5.xAxis, yAxis = _this$props5.yAxis, layout = _this$props5.layout, children = _this$props5.children;
				var errorBarItems = findAllByType(children, ErrorBar);
				if (!errorBarItems) return null;
				var offset = layout === "vertical" ? data[0].height / 2 : data[0].width / 2;
				var dataPointFormatter = function dataPointFormatter$1(dataPoint, dataKey) {
					var value = Array.isArray(dataPoint.value) ? dataPoint.value[1] : dataPoint.value;
					return {
						x: dataPoint.x,
						y: dataPoint.y,
						value,
						errorVal: getValueByDataKey(dataPoint, dataKey)
					};
				};
				var errorBarProps = { clipPath: needClip ? "url(#clipPath-".concat(clipPathId, ")") : null };
				return /* @__PURE__ */ import_react.createElement(Layer, errorBarProps, errorBarItems.map(function(item) {
					return /* @__PURE__ */ import_react.cloneElement(item, {
						key: "error-bar-".concat(clipPathId, "-").concat(item.props.dataKey),
						data,
						xAxis,
						yAxis,
						layout,
						offset,
						dataPointFormatter
					});
				}));
			}
		},
		{
			key: "render",
			value: function render() {
				var _this$props6 = this.props, hide = _this$props6.hide, data = _this$props6.data, className = _this$props6.className, xAxis = _this$props6.xAxis, yAxis = _this$props6.yAxis, left = _this$props6.left, top = _this$props6.top, width = _this$props6.width, height = _this$props6.height, isAnimationActive = _this$props6.isAnimationActive, background = _this$props6.background, id = _this$props6.id;
				if (hide || !data || !data.length) return null;
				var isAnimationFinished = this.state.isAnimationFinished;
				var layerClass = clsx_default("recharts-bar", className);
				var needClipX = xAxis && xAxis.allowDataOverflow;
				var needClipY = yAxis && yAxis.allowDataOverflow;
				var needClip = needClipX || needClipY;
				var clipPathId = (0, import_isNil$3.default)(id) ? this.id : id;
				return /* @__PURE__ */ import_react.createElement(Layer, { className: layerClass }, needClipX || needClipY ? /* @__PURE__ */ import_react.createElement("defs", null, /* @__PURE__ */ import_react.createElement("clipPath", { id: "clipPath-".concat(clipPathId) }, /* @__PURE__ */ import_react.createElement("rect", {
					x: needClipX ? left : left - width / 2,
					y: needClipY ? top : top - height / 2,
					width: needClipX ? width : width * 2,
					height: needClipY ? height : height * 2
				}))) : null, /* @__PURE__ */ import_react.createElement(Layer, {
					className: "recharts-bar-rectangles",
					clipPath: needClip ? "url(#clipPath-".concat(clipPathId, ")") : null
				}, background ? this.renderBackground() : null, this.renderRectangles()), this.renderErrorBar(needClip, clipPathId), (!isAnimationActive || isAnimationFinished) && LabelList.renderCallByParent(this.props, data));
			}
		}
	], [{
		key: "getDerivedStateFromProps",
		value: function getDerivedStateFromProps(nextProps, prevState) {
			if (nextProps.animationId !== prevState.prevAnimationId) return {
				prevAnimationId: nextProps.animationId,
				curData: nextProps.data,
				prevData: prevState.curData
			};
			if (nextProps.data !== prevState.curData) return { curData: nextProps.data };
			return null;
		}
	}]);
}(import_react.PureComponent);
_Bar = Bar;
_defineProperty$14(Bar, "displayName", "Bar");
_defineProperty$14(Bar, "defaultProps", {
	xAxisId: 0,
	yAxisId: 0,
	legendType: "rect",
	minPointSize: 0,
	hide: false,
	data: [],
	layout: "vertical",
	activeBar: false,
	isAnimationActive: !Global.isSsr,
	animationBegin: 0,
	animationDuration: 400,
	animationEasing: "ease"
});
_defineProperty$14(Bar, "getComposedData", function(_ref2) {
	var props = _ref2.props, item = _ref2.item, barPosition = _ref2.barPosition, bandSize = _ref2.bandSize, xAxis = _ref2.xAxis, yAxis = _ref2.yAxis, xAxisTicks = _ref2.xAxisTicks, yAxisTicks = _ref2.yAxisTicks, stackedData = _ref2.stackedData, dataStartIndex = _ref2.dataStartIndex, displayedData = _ref2.displayedData, offset = _ref2.offset;
	var pos = findPositionOfBar(barPosition, item);
	if (!pos) return null;
	var layout = props.layout;
	var itemDefaultProps = item.type.defaultProps;
	var itemProps = itemDefaultProps !== void 0 ? _objectSpread$11(_objectSpread$11({}, itemDefaultProps), item.props) : item.props;
	var dataKey = itemProps.dataKey, children = itemProps.children, minPointSizeProp = itemProps.minPointSize;
	var numericAxis = layout === "horizontal" ? yAxis : xAxis;
	var stackedDomain = stackedData ? numericAxis.scale.domain() : null;
	var baseValue = getBaseValueOfBar({ numericAxis });
	var cells = findAllByType(children, Cell);
	return _objectSpread$11({
		data: displayedData.map(function(entry, index) {
			var value, x$1, y$1, width, height, background;
			if (stackedData) value = truncateByDomain(stackedData[dataStartIndex + index], stackedDomain);
			else {
				value = getValueByDataKey(entry, dataKey);
				if (!Array.isArray(value)) value = [baseValue, value];
			}
			var minPointSize = minPointSizeCallback(minPointSizeProp, _Bar.defaultProps.minPointSize)(value[1], index);
			if (layout === "horizontal") {
				var _ref4;
				var _ref3 = [yAxis.scale(value[0]), yAxis.scale(value[1])], baseValueScale = _ref3[0], currentValueScale = _ref3[1];
				x$1 = getCateCoordinateOfBar({
					axis: xAxis,
					ticks: xAxisTicks,
					bandSize,
					offset: pos.offset,
					entry,
					index
				});
				y$1 = (_ref4 = currentValueScale !== null && currentValueScale !== void 0 ? currentValueScale : baseValueScale) !== null && _ref4 !== void 0 ? _ref4 : void 0;
				width = pos.size;
				var computedHeight = baseValueScale - currentValueScale;
				height = Number.isNaN(computedHeight) ? 0 : computedHeight;
				background = {
					x: x$1,
					y: yAxis.y,
					width,
					height: yAxis.height
				};
				if (Math.abs(minPointSize) > 0 && Math.abs(height) < Math.abs(minPointSize)) {
					var delta = mathSign(height || minPointSize) * (Math.abs(minPointSize) - Math.abs(height));
					y$1 -= delta;
					height += delta;
				}
			} else {
				var _ref5 = [xAxis.scale(value[0]), xAxis.scale(value[1])], _baseValueScale = _ref5[0], _currentValueScale = _ref5[1];
				x$1 = _baseValueScale;
				y$1 = getCateCoordinateOfBar({
					axis: yAxis,
					ticks: yAxisTicks,
					bandSize,
					offset: pos.offset,
					entry,
					index
				});
				width = _currentValueScale - _baseValueScale;
				height = pos.size;
				background = {
					x: xAxis.x,
					y: y$1,
					width: xAxis.width,
					height
				};
				if (Math.abs(minPointSize) > 0 && Math.abs(width) < Math.abs(minPointSize)) {
					var _delta = mathSign(width || minPointSize) * (Math.abs(minPointSize) - Math.abs(width));
					width += _delta;
				}
			}
			return _objectSpread$11(_objectSpread$11(_objectSpread$11({}, entry), {}, {
				x: x$1,
				y: y$1,
				width,
				height,
				value: stackedData ? value : value[1],
				payload: entry,
				background
			}, cells && cells[index] && cells[index].props), {}, {
				tooltipPayload: [getTooltipItem(item, entry)],
				tooltipPosition: {
					x: x$1 + width / 2,
					y: y$1 + height / 2
				}
			});
		}),
		layout
	}, offset);
});
var import_mapValues = /* @__PURE__ */ __toESM(require_mapValues());
var import_every$1 = /* @__PURE__ */ __toESM(require_every());
function _typeof$14(o$1) {
	"@babel/helpers - typeof";
	return _typeof$14 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$2) {
		return typeof o$2;
	} : function(o$2) {
		return o$2 && "function" == typeof Symbol && o$2.constructor === Symbol && o$2 !== Symbol.prototype ? "symbol" : typeof o$2;
	}, _typeof$14(o$1);
}
function _classCallCheck$10(instance, Constructor) {
	if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties$10(target, props) {
	for (var i$2 = 0; i$2 < props.length; i$2++) {
		var descriptor = props[i$2];
		descriptor.enumerable = descriptor.enumerable || false;
		descriptor.configurable = true;
		if ("value" in descriptor) descriptor.writable = true;
		Object.defineProperty(target, _toPropertyKey$13(descriptor.key), descriptor);
	}
}
function _createClass$10(Constructor, protoProps, staticProps) {
	if (protoProps) _defineProperties$10(Constructor.prototype, protoProps);
	if (staticProps) _defineProperties$10(Constructor, staticProps);
	Object.defineProperty(Constructor, "prototype", { writable: false });
	return Constructor;
}
function ownKeys$10(e, r$1) {
	var t$1 = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o$1 = Object.getOwnPropertySymbols(e);
		r$1 && (o$1 = o$1.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t$1.push.apply(t$1, o$1);
	}
	return t$1;
}
function _objectSpread$10(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t$1 = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$10(Object(t$1), !0).forEach(function(r$2) {
			_defineProperty$13(e, r$2, t$1[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t$1)) : ownKeys$10(Object(t$1)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t$1, r$2));
		});
	}
	return e;
}
function _defineProperty$13(obj, key, value) {
	key = _toPropertyKey$13(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$13(t$1) {
	var i$2 = _toPrimitive$13(t$1, "string");
	return "symbol" == _typeof$14(i$2) ? i$2 : i$2 + "";
}
function _toPrimitive$13(t$1, r$1) {
	if ("object" != _typeof$14(t$1) || !t$1) return t$1;
	var e = t$1[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i$2 = e.call(t$1, r$1 || "default");
		if ("object" != _typeof$14(i$2)) return i$2;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t$1);
}
var formatAxisMap = function formatAxisMap$1(props, axisMap, offset, axisType, chartName) {
	var width = props.width, height = props.height, layout = props.layout, children = props.children;
	var ids = Object.keys(axisMap);
	var steps = {
		left: offset.left,
		leftMirror: offset.left,
		right: width - offset.right,
		rightMirror: width - offset.right,
		top: offset.top,
		topMirror: offset.top,
		bottom: height - offset.bottom,
		bottomMirror: height - offset.bottom
	};
	var hasBar = !!findChildByType(children, Bar);
	return ids.reduce(function(result, id) {
		var axis = axisMap[id];
		var orientation = axis.orientation, domain = axis.domain, _axis$padding = axis.padding, padding = _axis$padding === void 0 ? {} : _axis$padding, mirror = axis.mirror, reversed = axis.reversed;
		var offsetKey = "".concat(orientation).concat(mirror ? "Mirror" : "");
		var calculatedPadding, range$5, x$1, y$1, needSpace;
		if (axis.type === "number" && (axis.padding === "gap" || axis.padding === "no-gap")) {
			var diff = domain[1] - domain[0];
			var smallestDistanceBetweenValues = Infinity;
			var sortedValues = axis.categoricalDomain.sort(compareValues);
			sortedValues.forEach(function(value, index) {
				if (index > 0) smallestDistanceBetweenValues = Math.min((value || 0) - (sortedValues[index - 1] || 0), smallestDistanceBetweenValues);
			});
			if (Number.isFinite(smallestDistanceBetweenValues)) {
				var smallestDistanceInPercent = smallestDistanceBetweenValues / diff;
				var rangeWidth = axis.layout === "vertical" ? offset.height : offset.width;
				if (axis.padding === "gap") calculatedPadding = smallestDistanceInPercent * rangeWidth / 2;
				if (axis.padding === "no-gap") {
					var gap = getPercentValue(props.barCategoryGap, smallestDistanceInPercent * rangeWidth);
					var halfBand = smallestDistanceInPercent * rangeWidth / 2;
					calculatedPadding = halfBand - gap - (halfBand - gap) / rangeWidth * gap;
				}
			}
		}
		if (axisType === "xAxis") range$5 = [offset.left + (padding.left || 0) + (calculatedPadding || 0), offset.left + offset.width - (padding.right || 0) - (calculatedPadding || 0)];
		else if (axisType === "yAxis") range$5 = layout === "horizontal" ? [offset.top + offset.height - (padding.bottom || 0), offset.top + (padding.top || 0)] : [offset.top + (padding.top || 0) + (calculatedPadding || 0), offset.top + offset.height - (padding.bottom || 0) - (calculatedPadding || 0)];
		else range$5 = axis.range;
		if (reversed) range$5 = [range$5[1], range$5[0]];
		var _parseScale = parseScale(axis, chartName, hasBar), scale = _parseScale.scale, realScaleType = _parseScale.realScaleType;
		scale.domain(domain).range(range$5);
		checkDomainOfScale(scale);
		var ticks$1 = getTicksOfScale(scale, _objectSpread$10(_objectSpread$10({}, axis), {}, { realScaleType }));
		if (axisType === "xAxis") {
			needSpace = orientation === "top" && !mirror || orientation === "bottom" && mirror;
			x$1 = offset.left;
			y$1 = steps[offsetKey] - needSpace * axis.height;
		} else if (axisType === "yAxis") {
			needSpace = orientation === "left" && !mirror || orientation === "right" && mirror;
			x$1 = steps[offsetKey] - needSpace * axis.width;
			y$1 = offset.top;
		}
		var finalAxis = _objectSpread$10(_objectSpread$10(_objectSpread$10({}, axis), ticks$1), {}, {
			realScaleType,
			x: x$1,
			y: y$1,
			scale,
			width: axisType === "xAxis" ? offset.width : axis.width,
			height: axisType === "yAxis" ? offset.height : axis.height
		});
		finalAxis.bandSize = getBandSizeOfAxis(finalAxis, ticks$1);
		if (!axis.hide && axisType === "xAxis") steps[offsetKey] += (needSpace ? -1 : 1) * finalAxis.height;
		else if (!axis.hide) steps[offsetKey] += (needSpace ? -1 : 1) * finalAxis.width;
		return _objectSpread$10(_objectSpread$10({}, result), {}, _defineProperty$13({}, id, finalAxis));
	}, {});
};
var rectWithPoints = function rectWithPoints$1(_ref, _ref2) {
	var x1 = _ref.x, y1 = _ref.y;
	var x2 = _ref2.x, y2 = _ref2.y;
	return {
		x: Math.min(x1, x2),
		y: Math.min(y1, y2),
		width: Math.abs(x2 - x1),
		height: Math.abs(y2 - y1)
	};
};
var rectWithCoords = function rectWithCoords$1(_ref3) {
	var x1 = _ref3.x1, y1 = _ref3.y1, x2 = _ref3.x2, y2 = _ref3.y2;
	return rectWithPoints({
		x: x1,
		y: y1
	}, {
		x: x2,
		y: y2
	});
};
var ScaleHelper = /* @__PURE__ */ function() {
	function ScaleHelper$1(scale) {
		_classCallCheck$10(this, ScaleHelper$1);
		this.scale = scale;
	}
	return _createClass$10(ScaleHelper$1, [
		{
			key: "domain",
			get: function get$8() {
				return this.scale.domain;
			}
		},
		{
			key: "range",
			get: function get$8() {
				return this.scale.range;
			}
		},
		{
			key: "rangeMin",
			get: function get$8() {
				return this.range()[0];
			}
		},
		{
			key: "rangeMax",
			get: function get$8() {
				return this.range()[1];
			}
		},
		{
			key: "bandwidth",
			get: function get$8() {
				return this.scale.bandwidth;
			}
		},
		{
			key: "apply",
			value: function apply$2(value) {
				var _ref4 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, bandAware = _ref4.bandAware, position = _ref4.position;
				if (value === void 0) return;
				if (position) switch (position) {
					case "start": return this.scale(value);
					case "middle":
						var offset = this.bandwidth ? this.bandwidth() / 2 : 0;
						return this.scale(value) + offset;
					case "end":
						var _offset = this.bandwidth ? this.bandwidth() : 0;
						return this.scale(value) + _offset;
					default: return this.scale(value);
				}
				if (bandAware) {
					var _offset2 = this.bandwidth ? this.bandwidth() / 2 : 0;
					return this.scale(value) + _offset2;
				}
				return this.scale(value);
			}
		},
		{
			key: "isInRange",
			value: function isInRange(value) {
				var range$5 = this.range();
				var first = range$5[0];
				var last$2 = range$5[range$5.length - 1];
				return first <= last$2 ? value >= first && value <= last$2 : value >= last$2 && value <= first;
			}
		}
	], [{
		key: "create",
		value: function create(obj) {
			return new ScaleHelper$1(obj);
		}
	}]);
}();
_defineProperty$13(ScaleHelper, "EPS", 1e-4);
var createLabeledScales = function createLabeledScales$1(options) {
	var scales = Object.keys(options).reduce(function(res, key) {
		return _objectSpread$10(_objectSpread$10({}, res), {}, _defineProperty$13({}, key, ScaleHelper.create(options[key])));
	}, {});
	return _objectSpread$10(_objectSpread$10({}, scales), {}, {
		apply: function apply$2(coord) {
			var _ref5 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, bandAware = _ref5.bandAware, position = _ref5.position;
			return (0, import_mapValues.default)(coord, function(value, label) {
				return scales[label].apply(value, {
					bandAware,
					position
				});
			});
		},
		isInRange: function isInRange(coord) {
			return (0, import_every$1.default)(coord, function(value, label) {
				return scales[label].isInRange(value);
			});
		}
	});
};
function normalizeAngle(angle) {
	return (angle % 180 + 180) % 180;
}
var getAngledRectangleWidth = function getAngledRectangleWidth$1(_ref6) {
	var width = _ref6.width, height = _ref6.height;
	var angleRadians = normalizeAngle(arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0) * Math.PI / 180;
	var angleThreshold = Math.atan(height / width);
	var angledWidth = angleRadians > angleThreshold && angleRadians < Math.PI - angleThreshold ? height / Math.sin(angleRadians) : width / Math.cos(angleRadians);
	return Math.abs(angledWidth);
};
var require__createFind = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseIteratee$1 = require__baseIteratee(), isArrayLike = require_isArrayLike(), keys = require_keys();
	function createFind(findIndexFunc) {
		return function(collection, predicate, fromIndex) {
			var iterable = Object(collection);
			if (!isArrayLike(collection)) {
				var iteratee = baseIteratee$1(predicate, 3);
				collection = keys(collection);
				predicate = function(key) {
					return iteratee(iterable[key], key, iterable);
				};
			}
			var index = findIndexFunc(collection, predicate, fromIndex);
			return index > -1 ? iterable[iteratee ? collection[index] : index] : void 0;
		};
	}
	module.exports = createFind;
}));
var require_toInteger = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var toFinite = require_toFinite();
	function toInteger$1(value) {
		var result = toFinite(value), remainder = result % 1;
		return result === result ? remainder ? result - remainder : result : 0;
	}
	module.exports = toInteger$1;
}));
var require_findIndex = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseFindIndex = require__baseFindIndex(), baseIteratee = require__baseIteratee(), toInteger = require_toInteger();
	var nativeMax = Math.max;
	function findIndex(array$1, predicate, fromIndex) {
		var length = array$1 == null ? 0 : array$1.length;
		if (!length) return -1;
		var index = fromIndex == null ? 0 : toInteger(fromIndex);
		if (index < 0) index = nativeMax(length + index, 0);
		return baseFindIndex(array$1, baseIteratee(predicate, 3), index);
	}
	module.exports = findIndex;
}));
var require_find = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = require__createFind()(require_findIndex());
}));
var calculateViewBox = (0, (/* @__PURE__ */ __toESM(require_memoize())).default)(function(offset) {
	return {
		x: offset.left,
		y: offset.top,
		width: offset.width,
		height: offset.height
	};
}, function(offset) {
	return [
		"l",
		offset.left,
		"t",
		offset.top,
		"w",
		offset.width,
		"h",
		offset.height
	].join("");
});
var import_find = /* @__PURE__ */ __toESM(require_find());
var import_every = /* @__PURE__ */ __toESM(require_every());
function _typeof$13(o$1) {
	"@babel/helpers - typeof";
	return _typeof$13 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$2) {
		return typeof o$2;
	} : function(o$2) {
		return o$2 && "function" == typeof Symbol && o$2.constructor === Symbol && o$2 !== Symbol.prototype ? "symbol" : typeof o$2;
	}, _typeof$13(o$1);
}
var XAxisContext = /* @__PURE__ */ (0, import_react.createContext)(void 0);
var YAxisContext = /* @__PURE__ */ (0, import_react.createContext)(void 0);
var ViewBoxContext = /* @__PURE__ */ (0, import_react.createContext)(void 0);
var OffsetContext = /* @__PURE__ */ (0, import_react.createContext)({});
var ClipPathIdContext = /* @__PURE__ */ (0, import_react.createContext)(void 0);
var ChartHeightContext = /* @__PURE__ */ (0, import_react.createContext)(0);
var ChartWidthContext = /* @__PURE__ */ (0, import_react.createContext)(0);
var ChartLayoutContextProvider = function ChartLayoutContextProvider$1(props) {
	var _props$state = props.state, xAxisMap = _props$state.xAxisMap, yAxisMap = _props$state.yAxisMap, offset = _props$state.offset, clipPathId = props.clipPathId, children = props.children, width = props.width, height = props.height;
	var viewBox = calculateViewBox(offset);
	return /* @__PURE__ */ import_react.createElement(XAxisContext.Provider, { value: xAxisMap }, /* @__PURE__ */ import_react.createElement(YAxisContext.Provider, { value: yAxisMap }, /* @__PURE__ */ import_react.createElement(OffsetContext.Provider, { value: offset }, /* @__PURE__ */ import_react.createElement(ViewBoxContext.Provider, { value: viewBox }, /* @__PURE__ */ import_react.createElement(ClipPathIdContext.Provider, { value: clipPathId }, /* @__PURE__ */ import_react.createElement(ChartHeightContext.Provider, { value: height }, /* @__PURE__ */ import_react.createElement(ChartWidthContext.Provider, { value: width }, children)))))));
};
var useClipPathId = function useClipPathId$1() {
	return (0, import_react.useContext)(ClipPathIdContext);
};
function getKeysForDebug(object$1) {
	var keys$6 = Object.keys(object$1);
	if (keys$6.length === 0) return "There are no available ids.";
	return "Available ids are: ".concat(keys$6, ".");
}
var useXAxisOrThrow = function useXAxisOrThrow$1(xAxisId) {
	var xAxisMap = (0, import_react.useContext)(XAxisContext);
	!(xAxisMap != null) && invariant(false, "Could not find Recharts context; are you sure this is rendered inside a Recharts wrapper component?");
	var xAxis = xAxisMap[xAxisId];
	!(xAxis != null) && invariant(false, "Could not find xAxis by id \"".concat(xAxisId, "\" [").concat(_typeof$13(xAxisId), "]. ").concat(getKeysForDebug(xAxisMap)));
	return xAxis;
};
var useArbitraryXAxis = function useArbitraryXAxis$1() {
	return getAnyElementOfObject((0, import_react.useContext)(XAxisContext));
};
var useYAxisWithFiniteDomainOrRandom = function useYAxisWithFiniteDomainOrRandom$1() {
	var yAxisMap = (0, import_react.useContext)(YAxisContext);
	return (0, import_find.default)(yAxisMap, function(axis) {
		return (0, import_every.default)(axis.domain, Number.isFinite);
	}) || getAnyElementOfObject(yAxisMap);
};
var useYAxisOrThrow = function useYAxisOrThrow$1(yAxisId) {
	var yAxisMap = (0, import_react.useContext)(YAxisContext);
	!(yAxisMap != null) && invariant(false, "Could not find Recharts context; are you sure this is rendered inside a Recharts wrapper component?");
	var yAxis = yAxisMap[yAxisId];
	!(yAxis != null) && invariant(false, "Could not find yAxis by id \"".concat(yAxisId, "\" [").concat(_typeof$13(yAxisId), "]. ").concat(getKeysForDebug(yAxisMap)));
	return yAxis;
};
var useViewBox = function useViewBox$1() {
	return (0, import_react.useContext)(ViewBoxContext);
};
var useOffset = function useOffset$1() {
	return (0, import_react.useContext)(OffsetContext);
};
var useChartWidth = function useChartWidth$1() {
	return (0, import_react.useContext)(ChartWidthContext);
};
var useChartHeight = function useChartHeight$1() {
	return (0, import_react.useContext)(ChartHeightContext);
};
var import_isFunction$8 = /* @__PURE__ */ __toESM(require_isFunction());
var import_some = /* @__PURE__ */ __toESM(require_some());
function _typeof$12(o$1) {
	"@babel/helpers - typeof";
	return _typeof$12 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$2) {
		return typeof o$2;
	} : function(o$2) {
		return o$2 && "function" == typeof Symbol && o$2.constructor === Symbol && o$2 !== Symbol.prototype ? "symbol" : typeof o$2;
	}, _typeof$12(o$1);
}
function _classCallCheck$9(instance, Constructor) {
	if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties$9(target, props) {
	for (var i$2 = 0; i$2 < props.length; i$2++) {
		var descriptor = props[i$2];
		descriptor.enumerable = descriptor.enumerable || false;
		descriptor.configurable = true;
		if ("value" in descriptor) descriptor.writable = true;
		Object.defineProperty(target, _toPropertyKey$12(descriptor.key), descriptor);
	}
}
function _createClass$9(Constructor, protoProps, staticProps) {
	if (protoProps) _defineProperties$9(Constructor.prototype, protoProps);
	if (staticProps) _defineProperties$9(Constructor, staticProps);
	Object.defineProperty(Constructor, "prototype", { writable: false });
	return Constructor;
}
function _callSuper$8(t$1, o$1, e) {
	return o$1 = _getPrototypeOf$8(o$1), _possibleConstructorReturn$8(t$1, _isNativeReflectConstruct$8() ? Reflect.construct(o$1, e || [], _getPrototypeOf$8(t$1).constructor) : o$1.apply(t$1, e));
}
function _possibleConstructorReturn$8(self$1, call) {
	if (call && (_typeof$12(call) === "object" || typeof call === "function")) return call;
	else if (call !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
	return _assertThisInitialized$8(self$1);
}
function _assertThisInitialized$8(self$1) {
	if (self$1 === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	return self$1;
}
function _isNativeReflectConstruct$8() {
	try {
		var t$1 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
	} catch (t$2) {}
	return (_isNativeReflectConstruct$8 = function _isNativeReflectConstruct$17() {
		return !!t$1;
	})();
}
function _getPrototypeOf$8(o$1) {
	_getPrototypeOf$8 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf$17(o$2) {
		return o$2.__proto__ || Object.getPrototypeOf(o$2);
	};
	return _getPrototypeOf$8(o$1);
}
function _inherits$8(subClass, superClass) {
	if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
	subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: {
		value: subClass,
		writable: true,
		configurable: true
	} });
	Object.defineProperty(subClass, "prototype", { writable: false });
	if (superClass) _setPrototypeOf$8(subClass, superClass);
}
function _setPrototypeOf$8(o$1, p) {
	_setPrototypeOf$8 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf$17(o$2, p$1) {
		o$2.__proto__ = p$1;
		return o$2;
	};
	return _setPrototypeOf$8(o$1, p);
}
function ownKeys$9(e, r$1) {
	var t$1 = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o$1 = Object.getOwnPropertySymbols(e);
		r$1 && (o$1 = o$1.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t$1.push.apply(t$1, o$1);
	}
	return t$1;
}
function _objectSpread$9(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t$1 = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$9(Object(t$1), !0).forEach(function(r$2) {
			_defineProperty$12(e, r$2, t$1[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t$1)) : ownKeys$9(Object(t$1)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t$1, r$2));
		});
	}
	return e;
}
function _defineProperty$12(obj, key, value) {
	key = _toPropertyKey$12(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$12(t$1) {
	var i$2 = _toPrimitive$12(t$1, "string");
	return "symbol" == _typeof$12(i$2) ? i$2 : i$2 + "";
}
function _toPrimitive$12(t$1, r$1) {
	if ("object" != _typeof$12(t$1) || !t$1) return t$1;
	var e = t$1[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i$2 = e.call(t$1, r$1 || "default");
		if ("object" != _typeof$12(i$2)) return i$2;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t$1);
}
function _slicedToArray$1(arr, i$2) {
	return _arrayWithHoles$1(arr) || _iterableToArrayLimit$1(arr, i$2) || _unsupportedIterableToArray$3(arr, i$2) || _nonIterableRest$1();
}
function _nonIterableRest$1() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$3(o$1, minLen) {
	if (!o$1) return;
	if (typeof o$1 === "string") return _arrayLikeToArray$3(o$1, minLen);
	var n$1 = Object.prototype.toString.call(o$1).slice(8, -1);
	if (n$1 === "Object" && o$1.constructor) n$1 = o$1.constructor.name;
	if (n$1 === "Map" || n$1 === "Set") return Array.from(o$1);
	if (n$1 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n$1)) return _arrayLikeToArray$3(o$1, minLen);
}
function _arrayLikeToArray$3(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i$2 = 0, arr2 = new Array(len); i$2 < len; i$2++) arr2[i$2] = arr[i$2];
	return arr2;
}
function _iterableToArrayLimit$1(r$1, l) {
	var t$1 = null == r$1 ? null : "undefined" != typeof Symbol && r$1[Symbol.iterator] || r$1["@@iterator"];
	if (null != t$1) {
		var e, n$1, i$2, u, a$2 = [], f = !0, o$1 = !1;
		try {
			if (i$2 = (t$1 = t$1.call(r$1)).next, 0 === l) {
				if (Object(t$1) !== t$1) return;
				f = !1;
			} else for (; !(f = (e = i$2.call(t$1)).done) && (a$2.push(e.value), a$2.length !== l); f = !0);
		} catch (r$2) {
			o$1 = !0, n$1 = r$2;
		} finally {
			try {
				if (!f && null != t$1["return"] && (u = t$1["return"](), Object(u) !== u)) return;
			} finally {
				if (o$1) throw n$1;
			}
		}
		return a$2;
	}
}
function _arrayWithHoles$1(arr) {
	if (Array.isArray(arr)) return arr;
}
function _extends$9() {
	_extends$9 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i$2 = 1; i$2 < arguments.length; i$2++) {
			var source = arguments[i$2];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$9.apply(this, arguments);
}
var renderLine = function renderLine$1(option, props) {
	var line;
	if (/* @__PURE__ */ import_react.isValidElement(option)) line = /* @__PURE__ */ import_react.cloneElement(option, props);
	else if ((0, import_isFunction$8.default)(option)) line = option(props);
	else line = /* @__PURE__ */ import_react.createElement("line", _extends$9({}, props, { className: "recharts-reference-line-line" }));
	return line;
};
var getEndPoints = function getEndPoints$1(scales, isFixedX, isFixedY, isSegment, viewBox, position, xAxisOrientation, yAxisOrientation, props) {
	var x$1 = viewBox.x, y$1 = viewBox.y, width = viewBox.width, height = viewBox.height;
	if (isFixedY) {
		var yCoord = props.y;
		var coord = scales.y.apply(yCoord, { position });
		if (ifOverflowMatches(props, "discard") && !scales.y.isInRange(coord)) return null;
		var points = [{
			x: x$1 + width,
			y: coord
		}, {
			x: x$1,
			y: coord
		}];
		return yAxisOrientation === "left" ? points.reverse() : points;
	}
	if (isFixedX) {
		var xCoord = props.x;
		var _coord = scales.x.apply(xCoord, { position });
		if (ifOverflowMatches(props, "discard") && !scales.x.isInRange(_coord)) return null;
		var _points = [{
			x: _coord,
			y: y$1 + height
		}, {
			x: _coord,
			y: y$1
		}];
		return xAxisOrientation === "top" ? _points.reverse() : _points;
	}
	if (isSegment) {
		var _points2 = props.segment.map(function(p) {
			return scales.apply(p, { position });
		});
		if (ifOverflowMatches(props, "discard") && (0, import_some.default)(_points2, function(p) {
			return !scales.isInRange(p);
		})) return null;
		return _points2;
	}
	return null;
};
function ReferenceLineImpl(props) {
	var fixedX = props.x, fixedY = props.y, segment = props.segment, xAxisId = props.xAxisId, yAxisId = props.yAxisId, shape = props.shape, className = props.className, alwaysShow = props.alwaysShow;
	var clipPathId = useClipPathId();
	var xAxis = useXAxisOrThrow(xAxisId);
	var yAxis = useYAxisOrThrow(yAxisId);
	var viewBox = useViewBox();
	if (!clipPathId || !viewBox) return null;
	warn(alwaysShow === void 0, "The alwaysShow prop is deprecated. Please use ifOverflow=\"extendDomain\" instead.");
	var endPoints = getEndPoints(createLabeledScales({
		x: xAxis.scale,
		y: yAxis.scale
	}), isNumOrStr(fixedX), isNumOrStr(fixedY), segment && segment.length === 2, viewBox, props.position, xAxis.orientation, yAxis.orientation, props);
	if (!endPoints) return null;
	var _endPoints = _slicedToArray$1(endPoints, 2), _endPoints$ = _endPoints[0], x1 = _endPoints$.x, y1 = _endPoints$.y, _endPoints$2 = _endPoints[1], x2 = _endPoints$2.x, y2 = _endPoints$2.y;
	var lineProps = _objectSpread$9(_objectSpread$9({ clipPath: ifOverflowMatches(props, "hidden") ? "url(#".concat(clipPathId, ")") : void 0 }, filterProps(props, true)), {}, {
		x1,
		y1,
		x2,
		y2
	});
	return /* @__PURE__ */ import_react.createElement(Layer, { className: clsx_default("recharts-reference-line", className) }, renderLine(shape, lineProps), Label.renderCallByParent(props, rectWithCoords({
		x1,
		y1,
		x2,
		y2
	})));
}
var ReferenceLine = /* @__PURE__ */ function(_React$Component) {
	function ReferenceLine$1() {
		_classCallCheck$9(this, ReferenceLine$1);
		return _callSuper$8(this, ReferenceLine$1, arguments);
	}
	_inherits$8(ReferenceLine$1, _React$Component);
	return _createClass$9(ReferenceLine$1, [{
		key: "render",
		value: function render() {
			return /* @__PURE__ */ import_react.createElement(ReferenceLineImpl, this.props);
		}
	}]);
}(import_react.Component);
_defineProperty$12(ReferenceLine, "displayName", "ReferenceLine");
_defineProperty$12(ReferenceLine, "defaultProps", {
	isFront: false,
	ifOverflow: "discard",
	xAxisId: 0,
	yAxisId: 0,
	fill: "none",
	stroke: "#ccc",
	fillOpacity: 1,
	strokeWidth: 1,
	position: "middle"
});
var import_isFunction$7 = /* @__PURE__ */ __toESM(require_isFunction());
function _extends$8() {
	_extends$8 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i$2 = 1; i$2 < arguments.length; i$2++) {
			var source = arguments[i$2];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$8.apply(this, arguments);
}
function _typeof$11(o$1) {
	"@babel/helpers - typeof";
	return _typeof$11 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$2) {
		return typeof o$2;
	} : function(o$2) {
		return o$2 && "function" == typeof Symbol && o$2.constructor === Symbol && o$2 !== Symbol.prototype ? "symbol" : typeof o$2;
	}, _typeof$11(o$1);
}
function ownKeys$8(e, r$1) {
	var t$1 = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o$1 = Object.getOwnPropertySymbols(e);
		r$1 && (o$1 = o$1.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t$1.push.apply(t$1, o$1);
	}
	return t$1;
}
function _objectSpread$8(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t$1 = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$8(Object(t$1), !0).forEach(function(r$2) {
			_defineProperty$11(e, r$2, t$1[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t$1)) : ownKeys$8(Object(t$1)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t$1, r$2));
		});
	}
	return e;
}
function _classCallCheck$8(instance, Constructor) {
	if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties$8(target, props) {
	for (var i$2 = 0; i$2 < props.length; i$2++) {
		var descriptor = props[i$2];
		descriptor.enumerable = descriptor.enumerable || false;
		descriptor.configurable = true;
		if ("value" in descriptor) descriptor.writable = true;
		Object.defineProperty(target, _toPropertyKey$11(descriptor.key), descriptor);
	}
}
function _createClass$8(Constructor, protoProps, staticProps) {
	if (protoProps) _defineProperties$8(Constructor.prototype, protoProps);
	if (staticProps) _defineProperties$8(Constructor, staticProps);
	Object.defineProperty(Constructor, "prototype", { writable: false });
	return Constructor;
}
function _callSuper$7(t$1, o$1, e) {
	return o$1 = _getPrototypeOf$7(o$1), _possibleConstructorReturn$7(t$1, _isNativeReflectConstruct$7() ? Reflect.construct(o$1, e || [], _getPrototypeOf$7(t$1).constructor) : o$1.apply(t$1, e));
}
function _possibleConstructorReturn$7(self$1, call) {
	if (call && (_typeof$11(call) === "object" || typeof call === "function")) return call;
	else if (call !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
	return _assertThisInitialized$7(self$1);
}
function _assertThisInitialized$7(self$1) {
	if (self$1 === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	return self$1;
}
function _isNativeReflectConstruct$7() {
	try {
		var t$1 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
	} catch (t$2) {}
	return (_isNativeReflectConstruct$7 = function _isNativeReflectConstruct$17() {
		return !!t$1;
	})();
}
function _getPrototypeOf$7(o$1) {
	_getPrototypeOf$7 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf$17(o$2) {
		return o$2.__proto__ || Object.getPrototypeOf(o$2);
	};
	return _getPrototypeOf$7(o$1);
}
function _inherits$7(subClass, superClass) {
	if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
	subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: {
		value: subClass,
		writable: true,
		configurable: true
	} });
	Object.defineProperty(subClass, "prototype", { writable: false });
	if (superClass) _setPrototypeOf$7(subClass, superClass);
}
function _setPrototypeOf$7(o$1, p) {
	_setPrototypeOf$7 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf$17(o$2, p$1) {
		o$2.__proto__ = p$1;
		return o$2;
	};
	return _setPrototypeOf$7(o$1, p);
}
function _defineProperty$11(obj, key, value) {
	key = _toPropertyKey$11(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$11(t$1) {
	var i$2 = _toPrimitive$11(t$1, "string");
	return "symbol" == _typeof$11(i$2) ? i$2 : i$2 + "";
}
function _toPrimitive$11(t$1, r$1) {
	if ("object" != _typeof$11(t$1) || !t$1) return t$1;
	var e = t$1[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i$2 = e.call(t$1, r$1 || "default");
		if ("object" != _typeof$11(i$2)) return i$2;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t$1);
}
var getCoordinate = function getCoordinate$1(props) {
	var x$1 = props.x, y$1 = props.y, xAxis = props.xAxis, yAxis = props.yAxis;
	var scales = createLabeledScales({
		x: xAxis.scale,
		y: yAxis.scale
	});
	var result = scales.apply({
		x: x$1,
		y: y$1
	}, { bandAware: true });
	if (ifOverflowMatches(props, "discard") && !scales.isInRange(result)) return null;
	return result;
};
var ReferenceDot = /* @__PURE__ */ function(_React$Component) {
	function ReferenceDot$1() {
		_classCallCheck$8(this, ReferenceDot$1);
		return _callSuper$7(this, ReferenceDot$1, arguments);
	}
	_inherits$7(ReferenceDot$1, _React$Component);
	return _createClass$8(ReferenceDot$1, [{
		key: "render",
		value: function render() {
			var _this$props = this.props, x$1 = _this$props.x, y$1 = _this$props.y, r$1 = _this$props.r, alwaysShow = _this$props.alwaysShow, clipPathId = _this$props.clipPathId;
			var isX = isNumOrStr(x$1);
			var isY = isNumOrStr(y$1);
			warn(alwaysShow === void 0, "The alwaysShow prop is deprecated. Please use ifOverflow=\"extendDomain\" instead.");
			if (!isX || !isY) return null;
			var coordinate = getCoordinate(this.props);
			if (!coordinate) return null;
			var cx = coordinate.x, cy = coordinate.y;
			var _this$props2 = this.props, shape = _this$props2.shape, className = _this$props2.className;
			var dotProps = _objectSpread$8(_objectSpread$8({ clipPath: ifOverflowMatches(this.props, "hidden") ? "url(#".concat(clipPathId, ")") : void 0 }, filterProps(this.props, true)), {}, {
				cx,
				cy
			});
			return /* @__PURE__ */ import_react.createElement(Layer, { className: clsx_default("recharts-reference-dot", className) }, ReferenceDot$1.renderDot(shape, dotProps), Label.renderCallByParent(this.props, {
				x: cx - r$1,
				y: cy - r$1,
				width: 2 * r$1,
				height: 2 * r$1
			}));
		}
	}]);
}(import_react.Component);
_defineProperty$11(ReferenceDot, "displayName", "ReferenceDot");
_defineProperty$11(ReferenceDot, "defaultProps", {
	isFront: false,
	ifOverflow: "discard",
	xAxisId: 0,
	yAxisId: 0,
	r: 10,
	fill: "#fff",
	stroke: "#ccc",
	fillOpacity: 1,
	strokeWidth: 1
});
_defineProperty$11(ReferenceDot, "renderDot", function(option, props) {
	var dot;
	if (/* @__PURE__ */ import_react.isValidElement(option)) dot = /* @__PURE__ */ import_react.cloneElement(option, props);
	else if ((0, import_isFunction$7.default)(option)) dot = option(props);
	else dot = /* @__PURE__ */ import_react.createElement(Dot, _extends$8({}, props, {
		cx: props.cx,
		cy: props.cy,
		className: "recharts-reference-dot-dot"
	}));
	return dot;
});
var import_isFunction$6 = /* @__PURE__ */ __toESM(require_isFunction());
function _extends$7() {
	_extends$7 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i$2 = 1; i$2 < arguments.length; i$2++) {
			var source = arguments[i$2];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$7.apply(this, arguments);
}
function _typeof$10(o$1) {
	"@babel/helpers - typeof";
	return _typeof$10 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$2) {
		return typeof o$2;
	} : function(o$2) {
		return o$2 && "function" == typeof Symbol && o$2.constructor === Symbol && o$2 !== Symbol.prototype ? "symbol" : typeof o$2;
	}, _typeof$10(o$1);
}
function ownKeys$7(e, r$1) {
	var t$1 = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o$1 = Object.getOwnPropertySymbols(e);
		r$1 && (o$1 = o$1.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t$1.push.apply(t$1, o$1);
	}
	return t$1;
}
function _objectSpread$7(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t$1 = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$7(Object(t$1), !0).forEach(function(r$2) {
			_defineProperty$10(e, r$2, t$1[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t$1)) : ownKeys$7(Object(t$1)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t$1, r$2));
		});
	}
	return e;
}
function _classCallCheck$7(instance, Constructor) {
	if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties$7(target, props) {
	for (var i$2 = 0; i$2 < props.length; i$2++) {
		var descriptor = props[i$2];
		descriptor.enumerable = descriptor.enumerable || false;
		descriptor.configurable = true;
		if ("value" in descriptor) descriptor.writable = true;
		Object.defineProperty(target, _toPropertyKey$10(descriptor.key), descriptor);
	}
}
function _createClass$7(Constructor, protoProps, staticProps) {
	if (protoProps) _defineProperties$7(Constructor.prototype, protoProps);
	if (staticProps) _defineProperties$7(Constructor, staticProps);
	Object.defineProperty(Constructor, "prototype", { writable: false });
	return Constructor;
}
function _callSuper$6(t$1, o$1, e) {
	return o$1 = _getPrototypeOf$6(o$1), _possibleConstructorReturn$6(t$1, _isNativeReflectConstruct$6() ? Reflect.construct(o$1, e || [], _getPrototypeOf$6(t$1).constructor) : o$1.apply(t$1, e));
}
function _possibleConstructorReturn$6(self$1, call) {
	if (call && (_typeof$10(call) === "object" || typeof call === "function")) return call;
	else if (call !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
	return _assertThisInitialized$6(self$1);
}
function _assertThisInitialized$6(self$1) {
	if (self$1 === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	return self$1;
}
function _isNativeReflectConstruct$6() {
	try {
		var t$1 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
	} catch (t$2) {}
	return (_isNativeReflectConstruct$6 = function _isNativeReflectConstruct$17() {
		return !!t$1;
	})();
}
function _getPrototypeOf$6(o$1) {
	_getPrototypeOf$6 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf$17(o$2) {
		return o$2.__proto__ || Object.getPrototypeOf(o$2);
	};
	return _getPrototypeOf$6(o$1);
}
function _inherits$6(subClass, superClass) {
	if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
	subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: {
		value: subClass,
		writable: true,
		configurable: true
	} });
	Object.defineProperty(subClass, "prototype", { writable: false });
	if (superClass) _setPrototypeOf$6(subClass, superClass);
}
function _setPrototypeOf$6(o$1, p) {
	_setPrototypeOf$6 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf$17(o$2, p$1) {
		o$2.__proto__ = p$1;
		return o$2;
	};
	return _setPrototypeOf$6(o$1, p);
}
function _defineProperty$10(obj, key, value) {
	key = _toPropertyKey$10(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$10(t$1) {
	var i$2 = _toPrimitive$10(t$1, "string");
	return "symbol" == _typeof$10(i$2) ? i$2 : i$2 + "";
}
function _toPrimitive$10(t$1, r$1) {
	if ("object" != _typeof$10(t$1) || !t$1) return t$1;
	var e = t$1[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i$2 = e.call(t$1, r$1 || "default");
		if ("object" != _typeof$10(i$2)) return i$2;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t$1);
}
var getRect = function getRect$1(hasX1, hasX2, hasY1, hasY2, props) {
	var xValue1 = props.x1, xValue2 = props.x2, yValue1 = props.y1, yValue2 = props.y2, xAxis = props.xAxis, yAxis = props.yAxis;
	if (!xAxis || !yAxis) return null;
	var scales = createLabeledScales({
		x: xAxis.scale,
		y: yAxis.scale
	});
	var p1 = {
		x: hasX1 ? scales.x.apply(xValue1, { position: "start" }) : scales.x.rangeMin,
		y: hasY1 ? scales.y.apply(yValue1, { position: "start" }) : scales.y.rangeMin
	};
	var p2 = {
		x: hasX2 ? scales.x.apply(xValue2, { position: "end" }) : scales.x.rangeMax,
		y: hasY2 ? scales.y.apply(yValue2, { position: "end" }) : scales.y.rangeMax
	};
	if (ifOverflowMatches(props, "discard") && (!scales.isInRange(p1) || !scales.isInRange(p2))) return null;
	return rectWithPoints(p1, p2);
};
var ReferenceArea = /* @__PURE__ */ function(_React$Component) {
	function ReferenceArea$1() {
		_classCallCheck$7(this, ReferenceArea$1);
		return _callSuper$6(this, ReferenceArea$1, arguments);
	}
	_inherits$6(ReferenceArea$1, _React$Component);
	return _createClass$7(ReferenceArea$1, [{
		key: "render",
		value: function render() {
			var _this$props = this.props, x1 = _this$props.x1, x2 = _this$props.x2, y1 = _this$props.y1, y2 = _this$props.y2, className = _this$props.className, alwaysShow = _this$props.alwaysShow, clipPathId = _this$props.clipPathId;
			warn(alwaysShow === void 0, "The alwaysShow prop is deprecated. Please use ifOverflow=\"extendDomain\" instead.");
			var hasX1 = isNumOrStr(x1);
			var hasX2 = isNumOrStr(x2);
			var hasY1 = isNumOrStr(y1);
			var hasY2 = isNumOrStr(y2);
			var shape = this.props.shape;
			if (!hasX1 && !hasX2 && !hasY1 && !hasY2 && !shape) return null;
			var rect = getRect(hasX1, hasX2, hasY1, hasY2, this.props);
			if (!rect && !shape) return null;
			var clipPath = ifOverflowMatches(this.props, "hidden") ? "url(#".concat(clipPathId, ")") : void 0;
			return /* @__PURE__ */ import_react.createElement(Layer, { className: clsx_default("recharts-reference-area", className) }, ReferenceArea$1.renderRect(shape, _objectSpread$7(_objectSpread$7({ clipPath }, filterProps(this.props, true)), rect)), Label.renderCallByParent(this.props, rect));
		}
	}]);
}(import_react.Component);
_defineProperty$10(ReferenceArea, "displayName", "ReferenceArea");
_defineProperty$10(ReferenceArea, "defaultProps", {
	isFront: false,
	ifOverflow: "discard",
	xAxisId: 0,
	yAxisId: 0,
	r: 10,
	fill: "#ccc",
	fillOpacity: .5,
	stroke: "none",
	strokeWidth: 1
});
_defineProperty$10(ReferenceArea, "renderRect", function(option, props) {
	var rect;
	if (/* @__PURE__ */ import_react.isValidElement(option)) rect = /* @__PURE__ */ import_react.cloneElement(option, props);
	else if ((0, import_isFunction$6.default)(option)) rect = option(props);
	else rect = /* @__PURE__ */ import_react.createElement(Rectangle, _extends$7({}, props, { className: "recharts-reference-area-rect" }));
	return rect;
});
function getEveryNthWithCondition(array$1, n$1, isValid) {
	if (n$1 < 1) return [];
	if (n$1 === 1 && isValid === void 0) return array$1;
	var result = [];
	for (var i$2 = 0; i$2 < array$1.length; i$2 += n$1) if (isValid === void 0 || isValid(array$1[i$2]) === true) result.push(array$1[i$2]);
	else return;
	return result;
}
function getAngledTickWidth(contentSize, unitSize, angle) {
	return getAngledRectangleWidth({
		width: contentSize.width + unitSize.width,
		height: contentSize.height + unitSize.height
	}, angle);
}
function getTickBoundaries(viewBox, sign$1, sizeKey) {
	var isWidth = sizeKey === "width";
	var x$1 = viewBox.x, y$1 = viewBox.y, width = viewBox.width, height = viewBox.height;
	if (sign$1 === 1) return {
		start: isWidth ? x$1 : y$1,
		end: isWidth ? x$1 + width : y$1 + height
	};
	return {
		start: isWidth ? x$1 + width : y$1 + height,
		end: isWidth ? x$1 : y$1
	};
}
function isVisible(sign$1, tickPosition, getSize, start, end) {
	if (sign$1 * tickPosition < sign$1 * start || sign$1 * tickPosition > sign$1 * end) return false;
	var size = getSize();
	return sign$1 * (tickPosition - sign$1 * size / 2 - start) >= 0 && sign$1 * (tickPosition + sign$1 * size / 2 - end) <= 0;
}
function getNumberIntervalTicks(ticks$1, interval) {
	return getEveryNthWithCondition(ticks$1, interval + 1);
}
function getEquidistantTicks(sign$1, boundaries, getTickSize, ticks$1, minTickGap) {
	var result = (ticks$1 || []).slice();
	var initialStart = boundaries.start, end = boundaries.end;
	var index = 0;
	var stepsize = 1;
	var start = initialStart;
	var _loop = function _loop$1() {
		var entry = ticks$1 === null || ticks$1 === void 0 ? void 0 : ticks$1[index];
		if (entry === void 0) return { v: getEveryNthWithCondition(ticks$1, stepsize) };
		var i$2 = index;
		var size;
		var getSize = function getSize$1() {
			if (size === void 0) size = getTickSize(entry, i$2);
			return size;
		};
		var tickCoord = entry.coordinate;
		var isShow = index === 0 || isVisible(sign$1, tickCoord, getSize, start, end);
		if (!isShow) {
			index = 0;
			start = initialStart;
			stepsize += 1;
		}
		if (isShow) {
			start = tickCoord + sign$1 * (getSize() / 2 + minTickGap);
			index += stepsize;
		}
	}, _ret;
	while (stepsize <= result.length) {
		_ret = _loop();
		if (_ret) return _ret.v;
	}
	return [];
}
var import_isFunction$5 = /* @__PURE__ */ __toESM(require_isFunction());
function _typeof$9(o$1) {
	"@babel/helpers - typeof";
	return _typeof$9 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$2) {
		return typeof o$2;
	} : function(o$2) {
		return o$2 && "function" == typeof Symbol && o$2.constructor === Symbol && o$2 !== Symbol.prototype ? "symbol" : typeof o$2;
	}, _typeof$9(o$1);
}
function ownKeys$6(e, r$1) {
	var t$1 = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o$1 = Object.getOwnPropertySymbols(e);
		r$1 && (o$1 = o$1.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t$1.push.apply(t$1, o$1);
	}
	return t$1;
}
function _objectSpread$6(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t$1 = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$6(Object(t$1), !0).forEach(function(r$2) {
			_defineProperty$9(e, r$2, t$1[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t$1)) : ownKeys$6(Object(t$1)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t$1, r$2));
		});
	}
	return e;
}
function _defineProperty$9(obj, key, value) {
	key = _toPropertyKey$9(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$9(t$1) {
	var i$2 = _toPrimitive$9(t$1, "string");
	return "symbol" == _typeof$9(i$2) ? i$2 : i$2 + "";
}
function _toPrimitive$9(t$1, r$1) {
	if ("object" != _typeof$9(t$1) || !t$1) return t$1;
	var e = t$1[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i$2 = e.call(t$1, r$1 || "default");
		if ("object" != _typeof$9(i$2)) return i$2;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t$1);
}
function getTicksEnd(sign$1, boundaries, getTickSize, ticks$1, minTickGap) {
	var result = (ticks$1 || []).slice();
	var len = result.length;
	var start = boundaries.start;
	var end = boundaries.end;
	var _loop = function _loop$1(i$3) {
		var entry = result[i$3];
		var size;
		var getSize = function getSize$1() {
			if (size === void 0) size = getTickSize(entry, i$3);
			return size;
		};
		if (i$3 === len - 1) {
			var gap = sign$1 * (entry.coordinate + sign$1 * getSize() / 2 - end);
			result[i$3] = entry = _objectSpread$6(_objectSpread$6({}, entry), {}, { tickCoord: gap > 0 ? entry.coordinate - gap * sign$1 : entry.coordinate });
		} else result[i$3] = entry = _objectSpread$6(_objectSpread$6({}, entry), {}, { tickCoord: entry.coordinate });
		if (isVisible(sign$1, entry.tickCoord, getSize, start, end)) {
			end = entry.tickCoord - sign$1 * (getSize() / 2 + minTickGap);
			result[i$3] = _objectSpread$6(_objectSpread$6({}, entry), {}, { isShow: true });
		}
	};
	for (var i$2 = len - 1; i$2 >= 0; i$2--) _loop(i$2);
	return result;
}
function getTicksStart(sign$1, boundaries, getTickSize, ticks$1, minTickGap, preserveEnd) {
	var result = (ticks$1 || []).slice();
	var len = result.length;
	var start = boundaries.start, end = boundaries.end;
	if (preserveEnd) {
		var tail = ticks$1[len - 1];
		var tailSize = getTickSize(tail, len - 1);
		var tailGap = sign$1 * (tail.coordinate + sign$1 * tailSize / 2 - end);
		result[len - 1] = tail = _objectSpread$6(_objectSpread$6({}, tail), {}, { tickCoord: tailGap > 0 ? tail.coordinate - tailGap * sign$1 : tail.coordinate });
		if (isVisible(sign$1, tail.tickCoord, function() {
			return tailSize;
		}, start, end)) {
			end = tail.tickCoord - sign$1 * (tailSize / 2 + minTickGap);
			result[len - 1] = _objectSpread$6(_objectSpread$6({}, tail), {}, { isShow: true });
		}
	}
	var count = preserveEnd ? len - 1 : len;
	var _loop2 = function _loop2$1(i$3) {
		var entry = result[i$3];
		var size;
		var getSize = function getSize$1() {
			if (size === void 0) size = getTickSize(entry, i$3);
			return size;
		};
		if (i$3 === 0) {
			var gap = sign$1 * (entry.coordinate - sign$1 * getSize() / 2 - start);
			result[i$3] = entry = _objectSpread$6(_objectSpread$6({}, entry), {}, { tickCoord: gap < 0 ? entry.coordinate - gap * sign$1 : entry.coordinate });
		} else result[i$3] = entry = _objectSpread$6(_objectSpread$6({}, entry), {}, { tickCoord: entry.coordinate });
		if (isVisible(sign$1, entry.tickCoord, getSize, start, end)) {
			start = entry.tickCoord + sign$1 * (getSize() / 2 + minTickGap);
			result[i$3] = _objectSpread$6(_objectSpread$6({}, entry), {}, { isShow: true });
		}
	};
	for (var i$2 = 0; i$2 < count; i$2++) _loop2(i$2);
	return result;
}
function getTicks(props, fontSize, letterSpacing) {
	var tick = props.tick, ticks$1 = props.ticks, viewBox = props.viewBox, minTickGap = props.minTickGap, orientation = props.orientation, interval = props.interval, tickFormatter = props.tickFormatter, unit$1 = props.unit, angle = props.angle;
	if (!ticks$1 || !ticks$1.length || !tick) return [];
	if (isNumber(interval) || Global.isSsr) return getNumberIntervalTicks(ticks$1, typeof interval === "number" && isNumber(interval) ? interval : 0);
	var candidates = [];
	var sizeKey = orientation === "top" || orientation === "bottom" ? "width" : "height";
	var unitSize = unit$1 && sizeKey === "width" ? getStringSize(unit$1, {
		fontSize,
		letterSpacing
	}) : {
		width: 0,
		height: 0
	};
	var getTickSize = function getTickSize$1(content, index) {
		var value = (0, import_isFunction$5.default)(tickFormatter) ? tickFormatter(content.value, index) : content.value;
		return sizeKey === "width" ? getAngledTickWidth(getStringSize(value, {
			fontSize,
			letterSpacing
		}), unitSize, angle) : getStringSize(value, {
			fontSize,
			letterSpacing
		})[sizeKey];
	};
	var sign$1 = ticks$1.length >= 2 ? mathSign(ticks$1[1].coordinate - ticks$1[0].coordinate) : 1;
	var boundaries = getTickBoundaries(viewBox, sign$1, sizeKey);
	if (interval === "equidistantPreserveStart") return getEquidistantTicks(sign$1, boundaries, getTickSize, ticks$1, minTickGap);
	if (interval === "preserveStart" || interval === "preserveStartEnd") candidates = getTicksStart(sign$1, boundaries, getTickSize, ticks$1, minTickGap, interval === "preserveStartEnd");
	else candidates = getTicksEnd(sign$1, boundaries, getTickSize, ticks$1, minTickGap);
	return candidates.filter(function(entry) {
		return entry.isShow;
	});
}
var import_isFunction$4 = /* @__PURE__ */ __toESM(require_isFunction());
var import_get$1 = /* @__PURE__ */ __toESM(require_get());
var _excluded$4 = ["viewBox"], _excluded2$4 = ["viewBox"], _excluded3 = ["ticks"];
function _typeof$8(o$1) {
	"@babel/helpers - typeof";
	return _typeof$8 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$2) {
		return typeof o$2;
	} : function(o$2) {
		return o$2 && "function" == typeof Symbol && o$2.constructor === Symbol && o$2 !== Symbol.prototype ? "symbol" : typeof o$2;
	}, _typeof$8(o$1);
}
function _extends$6() {
	_extends$6 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i$2 = 1; i$2 < arguments.length; i$2++) {
			var source = arguments[i$2];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$6.apply(this, arguments);
}
function ownKeys$5(e, r$1) {
	var t$1 = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o$1 = Object.getOwnPropertySymbols(e);
		r$1 && (o$1 = o$1.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t$1.push.apply(t$1, o$1);
	}
	return t$1;
}
function _objectSpread$5(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t$1 = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$5(Object(t$1), !0).forEach(function(r$2) {
			_defineProperty$8(e, r$2, t$1[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t$1)) : ownKeys$5(Object(t$1)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t$1, r$2));
		});
	}
	return e;
}
function _objectWithoutProperties$4(source, excluded) {
	if (source == null) return {};
	var target = _objectWithoutPropertiesLoose$4(source, excluded);
	var key, i$2;
	if (Object.getOwnPropertySymbols) {
		var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
		for (i$2 = 0; i$2 < sourceSymbolKeys.length; i$2++) {
			key = sourceSymbolKeys[i$2];
			if (excluded.indexOf(key) >= 0) continue;
			if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
			target[key] = source[key];
		}
	}
	return target;
}
function _objectWithoutPropertiesLoose$4(source, excluded) {
	if (source == null) return {};
	var target = {};
	for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) {
		if (excluded.indexOf(key) >= 0) continue;
		target[key] = source[key];
	}
	return target;
}
function _classCallCheck$6(instance, Constructor) {
	if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties$6(target, props) {
	for (var i$2 = 0; i$2 < props.length; i$2++) {
		var descriptor = props[i$2];
		descriptor.enumerable = descriptor.enumerable || false;
		descriptor.configurable = true;
		if ("value" in descriptor) descriptor.writable = true;
		Object.defineProperty(target, _toPropertyKey$8(descriptor.key), descriptor);
	}
}
function _createClass$6(Constructor, protoProps, staticProps) {
	if (protoProps) _defineProperties$6(Constructor.prototype, protoProps);
	if (staticProps) _defineProperties$6(Constructor, staticProps);
	Object.defineProperty(Constructor, "prototype", { writable: false });
	return Constructor;
}
function _callSuper$5(t$1, o$1, e) {
	return o$1 = _getPrototypeOf$5(o$1), _possibleConstructorReturn$5(t$1, _isNativeReflectConstruct$5() ? Reflect.construct(o$1, e || [], _getPrototypeOf$5(t$1).constructor) : o$1.apply(t$1, e));
}
function _possibleConstructorReturn$5(self$1, call) {
	if (call && (_typeof$8(call) === "object" || typeof call === "function")) return call;
	else if (call !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
	return _assertThisInitialized$5(self$1);
}
function _assertThisInitialized$5(self$1) {
	if (self$1 === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	return self$1;
}
function _isNativeReflectConstruct$5() {
	try {
		var t$1 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
	} catch (t$2) {}
	return (_isNativeReflectConstruct$5 = function _isNativeReflectConstruct$17() {
		return !!t$1;
	})();
}
function _getPrototypeOf$5(o$1) {
	_getPrototypeOf$5 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf$17(o$2) {
		return o$2.__proto__ || Object.getPrototypeOf(o$2);
	};
	return _getPrototypeOf$5(o$1);
}
function _inherits$5(subClass, superClass) {
	if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
	subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: {
		value: subClass,
		writable: true,
		configurable: true
	} });
	Object.defineProperty(subClass, "prototype", { writable: false });
	if (superClass) _setPrototypeOf$5(subClass, superClass);
}
function _setPrototypeOf$5(o$1, p) {
	_setPrototypeOf$5 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf$17(o$2, p$1) {
		o$2.__proto__ = p$1;
		return o$2;
	};
	return _setPrototypeOf$5(o$1, p);
}
function _defineProperty$8(obj, key, value) {
	key = _toPropertyKey$8(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$8(t$1) {
	var i$2 = _toPrimitive$8(t$1, "string");
	return "symbol" == _typeof$8(i$2) ? i$2 : i$2 + "";
}
function _toPrimitive$8(t$1, r$1) {
	if ("object" != _typeof$8(t$1) || !t$1) return t$1;
	var e = t$1[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i$2 = e.call(t$1, r$1 || "default");
		if ("object" != _typeof$8(i$2)) return i$2;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t$1);
}
var CartesianAxis = /* @__PURE__ */ function(_Component) {
	function CartesianAxis$1(props) {
		var _this;
		_classCallCheck$6(this, CartesianAxis$1);
		_this = _callSuper$5(this, CartesianAxis$1, [props]);
		_this.state = {
			fontSize: "",
			letterSpacing: ""
		};
		return _this;
	}
	_inherits$5(CartesianAxis$1, _Component);
	return _createClass$6(CartesianAxis$1, [
		{
			key: "shouldComponentUpdate",
			value: function shouldComponentUpdate(_ref, nextState) {
				var viewBox = _ref.viewBox, restProps = _objectWithoutProperties$4(_ref, _excluded$4);
				var _this$props = this.props, viewBoxOld = _this$props.viewBox, restPropsOld = _objectWithoutProperties$4(_this$props, _excluded2$4);
				return !shallowEqual(viewBox, viewBoxOld) || !shallowEqual(restProps, restPropsOld) || !shallowEqual(nextState, this.state);
			}
		},
		{
			key: "componentDidMount",
			value: function componentDidMount() {
				var htmlLayer = this.layerReference;
				if (!htmlLayer) return;
				var tick = htmlLayer.getElementsByClassName("recharts-cartesian-axis-tick-value")[0];
				if (tick) this.setState({
					fontSize: window.getComputedStyle(tick).fontSize,
					letterSpacing: window.getComputedStyle(tick).letterSpacing
				});
			}
		},
		{
			key: "getTickLineCoord",
			value: function getTickLineCoord(data) {
				var _this$props2 = this.props, x$1 = _this$props2.x, y$1 = _this$props2.y, width = _this$props2.width, height = _this$props2.height, orientation = _this$props2.orientation, tickSize = _this$props2.tickSize, mirror = _this$props2.mirror, tickMargin = _this$props2.tickMargin;
				var x1, x2, y1, y2, tx, ty;
				var sign$1 = mirror ? -1 : 1;
				var finalTickSize = data.tickSize || tickSize;
				var tickCoord = isNumber(data.tickCoord) ? data.tickCoord : data.coordinate;
				switch (orientation) {
					case "top":
						x1 = x2 = data.coordinate;
						y2 = y$1 + +!mirror * height;
						y1 = y2 - sign$1 * finalTickSize;
						ty = y1 - sign$1 * tickMargin;
						tx = tickCoord;
						break;
					case "left":
						y1 = y2 = data.coordinate;
						x2 = x$1 + +!mirror * width;
						x1 = x2 - sign$1 * finalTickSize;
						tx = x1 - sign$1 * tickMargin;
						ty = tickCoord;
						break;
					case "right":
						y1 = y2 = data.coordinate;
						x2 = x$1 + +mirror * width;
						x1 = x2 + sign$1 * finalTickSize;
						tx = x1 + sign$1 * tickMargin;
						ty = tickCoord;
						break;
					default:
						x1 = x2 = data.coordinate;
						y2 = y$1 + +mirror * height;
						y1 = y2 + sign$1 * finalTickSize;
						ty = y1 + sign$1 * tickMargin;
						tx = tickCoord;
						break;
				}
				return {
					line: {
						x1,
						y1,
						x2,
						y2
					},
					tick: {
						x: tx,
						y: ty
					}
				};
			}
		},
		{
			key: "getTickTextAnchor",
			value: function getTickTextAnchor() {
				var _this$props3 = this.props, orientation = _this$props3.orientation, mirror = _this$props3.mirror;
				var textAnchor;
				switch (orientation) {
					case "left":
						textAnchor = mirror ? "start" : "end";
						break;
					case "right":
						textAnchor = mirror ? "end" : "start";
						break;
					default:
						textAnchor = "middle";
						break;
				}
				return textAnchor;
			}
		},
		{
			key: "getTickVerticalAnchor",
			value: function getTickVerticalAnchor() {
				var _this$props4 = this.props, orientation = _this$props4.orientation, mirror = _this$props4.mirror;
				var verticalAnchor = "end";
				switch (orientation) {
					case "left":
					case "right":
						verticalAnchor = "middle";
						break;
					case "top":
						verticalAnchor = mirror ? "start" : "end";
						break;
					default:
						verticalAnchor = mirror ? "end" : "start";
						break;
				}
				return verticalAnchor;
			}
		},
		{
			key: "renderAxisLine",
			value: function renderAxisLine() {
				var _this$props5 = this.props, x$1 = _this$props5.x, y$1 = _this$props5.y, width = _this$props5.width, height = _this$props5.height, orientation = _this$props5.orientation, mirror = _this$props5.mirror, axisLine = _this$props5.axisLine;
				var props = _objectSpread$5(_objectSpread$5(_objectSpread$5({}, filterProps(this.props, false)), filterProps(axisLine, false)), {}, { fill: "none" });
				if (orientation === "top" || orientation === "bottom") {
					var needHeight = +(orientation === "top" && !mirror || orientation === "bottom" && mirror);
					props = _objectSpread$5(_objectSpread$5({}, props), {}, {
						x1: x$1,
						y1: y$1 + needHeight * height,
						x2: x$1 + width,
						y2: y$1 + needHeight * height
					});
				} else {
					var needWidth = +(orientation === "left" && !mirror || orientation === "right" && mirror);
					props = _objectSpread$5(_objectSpread$5({}, props), {}, {
						x1: x$1 + needWidth * width,
						y1: y$1,
						x2: x$1 + needWidth * width,
						y2: y$1 + height
					});
				}
				return /* @__PURE__ */ import_react.createElement("line", _extends$6({}, props, { className: clsx_default("recharts-cartesian-axis-line", (0, import_get$1.default)(axisLine, "className")) }));
			}
		},
		{
			key: "renderTicks",
			value: function renderTicks(ticks$1, fontSize, letterSpacing) {
				var _this2 = this;
				var _this$props6 = this.props, tickLine = _this$props6.tickLine, stroke = _this$props6.stroke, tick = _this$props6.tick, tickFormatter = _this$props6.tickFormatter, unit$1 = _this$props6.unit;
				var finalTicks = getTicks(_objectSpread$5(_objectSpread$5({}, this.props), {}, { ticks: ticks$1 }), fontSize, letterSpacing);
				var textAnchor = this.getTickTextAnchor();
				var verticalAnchor = this.getTickVerticalAnchor();
				var axisProps = filterProps(this.props, false);
				var customTickProps = filterProps(tick, false);
				var tickLineProps = _objectSpread$5(_objectSpread$5({}, axisProps), {}, { fill: "none" }, filterProps(tickLine, false));
				var items = finalTicks.map(function(entry, i$2) {
					var _this2$getTickLineCoo = _this2.getTickLineCoord(entry), lineCoord = _this2$getTickLineCoo.line, tickCoord = _this2$getTickLineCoo.tick;
					var tickProps = _objectSpread$5(_objectSpread$5(_objectSpread$5(_objectSpread$5({
						textAnchor,
						verticalAnchor
					}, axisProps), {}, {
						stroke: "none",
						fill: stroke
					}, customTickProps), tickCoord), {}, {
						index: i$2,
						payload: entry,
						visibleTicksCount: finalTicks.length,
						tickFormatter
					});
					return /* @__PURE__ */ import_react.createElement(Layer, _extends$6({
						className: "recharts-cartesian-axis-tick",
						key: "tick-".concat(entry.value, "-").concat(entry.coordinate, "-").concat(entry.tickCoord)
					}, adaptEventsOfChild(_this2.props, entry, i$2)), tickLine && /* @__PURE__ */ import_react.createElement("line", _extends$6({}, tickLineProps, lineCoord, { className: clsx_default("recharts-cartesian-axis-tick-line", (0, import_get$1.default)(tickLine, "className")) })), tick && CartesianAxis$1.renderTickItem(tick, tickProps, "".concat((0, import_isFunction$4.default)(tickFormatter) ? tickFormatter(entry.value, i$2) : entry.value).concat(unit$1 || "")));
				});
				return /* @__PURE__ */ import_react.createElement("g", { className: "recharts-cartesian-axis-ticks" }, items);
			}
		},
		{
			key: "render",
			value: function render() {
				var _this3 = this;
				var _this$props7 = this.props, axisLine = _this$props7.axisLine, width = _this$props7.width, height = _this$props7.height, ticksGenerator = _this$props7.ticksGenerator, className = _this$props7.className;
				if (_this$props7.hide) return null;
				var _this$props8 = this.props, ticks$1 = _this$props8.ticks, noTicksProps = _objectWithoutProperties$4(_this$props8, _excluded3);
				var finalTicks = ticks$1;
				if ((0, import_isFunction$4.default)(ticksGenerator)) finalTicks = ticks$1 && ticks$1.length > 0 ? ticksGenerator(this.props) : ticksGenerator(noTicksProps);
				if (width <= 0 || height <= 0 || !finalTicks || !finalTicks.length) return null;
				return /* @__PURE__ */ import_react.createElement(Layer, {
					className: clsx_default("recharts-cartesian-axis", className),
					ref: function ref(_ref2) {
						_this3.layerReference = _ref2;
					}
				}, axisLine && this.renderAxisLine(), this.renderTicks(finalTicks, this.state.fontSize, this.state.letterSpacing), Label.renderCallByParent(this.props));
			}
		}
	], [{
		key: "renderTickItem",
		value: function renderTickItem(option, props, value) {
			var tickItem;
			var combinedClassName = clsx_default(props.className, "recharts-cartesian-axis-tick-value");
			if (/* @__PURE__ */ import_react.isValidElement(option)) tickItem = /* @__PURE__ */ import_react.cloneElement(option, _objectSpread$5(_objectSpread$5({}, props), {}, { className: combinedClassName }));
			else if ((0, import_isFunction$4.default)(option)) tickItem = option(_objectSpread$5(_objectSpread$5({}, props), {}, { className: combinedClassName }));
			else tickItem = /* @__PURE__ */ import_react.createElement(Text, _extends$6({}, props, { className: "recharts-cartesian-axis-tick-value" }), value);
			return tickItem;
		}
	}]);
}(import_react.Component);
_defineProperty$8(CartesianAxis, "displayName", "CartesianAxis");
_defineProperty$8(CartesianAxis, "defaultProps", {
	x: 0,
	y: 0,
	width: 0,
	height: 0,
	viewBox: {
		x: 0,
		y: 0,
		width: 0,
		height: 0
	},
	orientation: "bottom",
	ticks: [],
	stroke: "#666",
	tickLine: true,
	axisLine: true,
	tick: true,
	mirror: false,
	minTickGap: 5,
	tickSize: 6,
	tickMargin: 2,
	interval: "preserveEnd"
});
var import_isFunction$3 = /* @__PURE__ */ __toESM(require_isFunction());
var _excluded$3 = [
	"x1",
	"y1",
	"x2",
	"y2",
	"key"
], _excluded2$3 = ["offset"];
function _typeof$7(o$1) {
	"@babel/helpers - typeof";
	return _typeof$7 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$2) {
		return typeof o$2;
	} : function(o$2) {
		return o$2 && "function" == typeof Symbol && o$2.constructor === Symbol && o$2 !== Symbol.prototype ? "symbol" : typeof o$2;
	}, _typeof$7(o$1);
}
function ownKeys$4(e, r$1) {
	var t$1 = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o$1 = Object.getOwnPropertySymbols(e);
		r$1 && (o$1 = o$1.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t$1.push.apply(t$1, o$1);
	}
	return t$1;
}
function _objectSpread$4(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t$1 = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$4(Object(t$1), !0).forEach(function(r$2) {
			_defineProperty$7(e, r$2, t$1[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t$1)) : ownKeys$4(Object(t$1)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t$1, r$2));
		});
	}
	return e;
}
function _defineProperty$7(obj, key, value) {
	key = _toPropertyKey$7(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$7(t$1) {
	var i$2 = _toPrimitive$7(t$1, "string");
	return "symbol" == _typeof$7(i$2) ? i$2 : i$2 + "";
}
function _toPrimitive$7(t$1, r$1) {
	if ("object" != _typeof$7(t$1) || !t$1) return t$1;
	var e = t$1[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i$2 = e.call(t$1, r$1 || "default");
		if ("object" != _typeof$7(i$2)) return i$2;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t$1);
}
function _extends$5() {
	_extends$5 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i$2 = 1; i$2 < arguments.length; i$2++) {
			var source = arguments[i$2];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$5.apply(this, arguments);
}
function _objectWithoutProperties$3(source, excluded) {
	if (source == null) return {};
	var target = _objectWithoutPropertiesLoose$3(source, excluded);
	var key, i$2;
	if (Object.getOwnPropertySymbols) {
		var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
		for (i$2 = 0; i$2 < sourceSymbolKeys.length; i$2++) {
			key = sourceSymbolKeys[i$2];
			if (excluded.indexOf(key) >= 0) continue;
			if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
			target[key] = source[key];
		}
	}
	return target;
}
function _objectWithoutPropertiesLoose$3(source, excluded) {
	if (source == null) return {};
	var target = {};
	for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) {
		if (excluded.indexOf(key) >= 0) continue;
		target[key] = source[key];
	}
	return target;
}
var Background = function Background$1(props) {
	var fill = props.fill;
	if (!fill || fill === "none") return null;
	var fillOpacity = props.fillOpacity, x$1 = props.x, y$1 = props.y, width = props.width, height = props.height, ry = props.ry;
	return /* @__PURE__ */ import_react.createElement("rect", {
		x: x$1,
		y: y$1,
		ry,
		width,
		height,
		stroke: "none",
		fill,
		fillOpacity,
		className: "recharts-cartesian-grid-bg"
	});
};
function renderLineItem(option, props) {
	var lineItem;
	if (/* @__PURE__ */ import_react.isValidElement(option)) lineItem = /* @__PURE__ */ import_react.cloneElement(option, props);
	else if ((0, import_isFunction$3.default)(option)) lineItem = option(props);
	else {
		var x1 = props.x1, y1 = props.y1, x2 = props.x2, y2 = props.y2, key = props.key, _filterProps = filterProps(_objectWithoutProperties$3(props, _excluded$3), false);
		_filterProps.offset;
		var restOfFilteredProps = _objectWithoutProperties$3(_filterProps, _excluded2$3);
		lineItem = /* @__PURE__ */ import_react.createElement("line", _extends$5({}, restOfFilteredProps, {
			x1,
			y1,
			x2,
			y2,
			fill: "none",
			key
		}));
	}
	return lineItem;
}
function HorizontalGridLines(props) {
	var x$1 = props.x, width = props.width, _props$horizontal = props.horizontal, horizontal = _props$horizontal === void 0 ? true : _props$horizontal, horizontalPoints = props.horizontalPoints;
	if (!horizontal || !horizontalPoints || !horizontalPoints.length) return null;
	var items = horizontalPoints.map(function(entry, i$2) {
		return renderLineItem(horizontal, _objectSpread$4(_objectSpread$4({}, props), {}, {
			x1: x$1,
			y1: entry,
			x2: x$1 + width,
			y2: entry,
			key: "line-".concat(i$2),
			index: i$2
		}));
	});
	return /* @__PURE__ */ import_react.createElement("g", { className: "recharts-cartesian-grid-horizontal" }, items);
}
function VerticalGridLines(props) {
	var y$1 = props.y, height = props.height, _props$vertical = props.vertical, vertical = _props$vertical === void 0 ? true : _props$vertical, verticalPoints = props.verticalPoints;
	if (!vertical || !verticalPoints || !verticalPoints.length) return null;
	var items = verticalPoints.map(function(entry, i$2) {
		return renderLineItem(vertical, _objectSpread$4(_objectSpread$4({}, props), {}, {
			x1: entry,
			y1: y$1,
			x2: entry,
			y2: y$1 + height,
			key: "line-".concat(i$2),
			index: i$2
		}));
	});
	return /* @__PURE__ */ import_react.createElement("g", { className: "recharts-cartesian-grid-vertical" }, items);
}
function HorizontalStripes(props) {
	var horizontalFill = props.horizontalFill, fillOpacity = props.fillOpacity, x$1 = props.x, y$1 = props.y, width = props.width, height = props.height, horizontalPoints = props.horizontalPoints, _props$horizontal2 = props.horizontal;
	if (!(_props$horizontal2 === void 0 ? true : _props$horizontal2) || !horizontalFill || !horizontalFill.length) return null;
	var roundedSortedHorizontalPoints = horizontalPoints.map(function(e) {
		return Math.round(e + y$1 - y$1);
	}).sort(function(a$2, b) {
		return a$2 - b;
	});
	if (y$1 !== roundedSortedHorizontalPoints[0]) roundedSortedHorizontalPoints.unshift(0);
	var items = roundedSortedHorizontalPoints.map(function(entry, i$2) {
		var lineHeight = !roundedSortedHorizontalPoints[i$2 + 1] ? y$1 + height - entry : roundedSortedHorizontalPoints[i$2 + 1] - entry;
		if (lineHeight <= 0) return null;
		var colorIndex = i$2 % horizontalFill.length;
		return /* @__PURE__ */ import_react.createElement("rect", {
			key: "react-".concat(i$2),
			y: entry,
			x: x$1,
			height: lineHeight,
			width,
			stroke: "none",
			fill: horizontalFill[colorIndex],
			fillOpacity,
			className: "recharts-cartesian-grid-bg"
		});
	});
	return /* @__PURE__ */ import_react.createElement("g", { className: "recharts-cartesian-gridstripes-horizontal" }, items);
}
function VerticalStripes(props) {
	var _props$vertical2 = props.vertical, vertical = _props$vertical2 === void 0 ? true : _props$vertical2, verticalFill = props.verticalFill, fillOpacity = props.fillOpacity, x$1 = props.x, y$1 = props.y, width = props.width, height = props.height, verticalPoints = props.verticalPoints;
	if (!vertical || !verticalFill || !verticalFill.length) return null;
	var roundedSortedVerticalPoints = verticalPoints.map(function(e) {
		return Math.round(e + x$1 - x$1);
	}).sort(function(a$2, b) {
		return a$2 - b;
	});
	if (x$1 !== roundedSortedVerticalPoints[0]) roundedSortedVerticalPoints.unshift(0);
	var items = roundedSortedVerticalPoints.map(function(entry, i$2) {
		var lineWidth = !roundedSortedVerticalPoints[i$2 + 1] ? x$1 + width - entry : roundedSortedVerticalPoints[i$2 + 1] - entry;
		if (lineWidth <= 0) return null;
		var colorIndex = i$2 % verticalFill.length;
		return /* @__PURE__ */ import_react.createElement("rect", {
			key: "react-".concat(i$2),
			x: entry,
			y: y$1,
			width: lineWidth,
			height,
			stroke: "none",
			fill: verticalFill[colorIndex],
			fillOpacity,
			className: "recharts-cartesian-grid-bg"
		});
	});
	return /* @__PURE__ */ import_react.createElement("g", { className: "recharts-cartesian-gridstripes-vertical" }, items);
}
var defaultVerticalCoordinatesGenerator = function defaultVerticalCoordinatesGenerator$1(_ref, syncWithTicks) {
	var xAxis = _ref.xAxis, width = _ref.width, height = _ref.height, offset = _ref.offset;
	return getCoordinatesOfGrid(getTicks(_objectSpread$4(_objectSpread$4(_objectSpread$4({}, CartesianAxis.defaultProps), xAxis), {}, {
		ticks: getTicksOfAxis(xAxis, true),
		viewBox: {
			x: 0,
			y: 0,
			width,
			height
		}
	})), offset.left, offset.left + offset.width, syncWithTicks);
};
var defaultHorizontalCoordinatesGenerator = function defaultHorizontalCoordinatesGenerator$1(_ref2, syncWithTicks) {
	var yAxis = _ref2.yAxis, width = _ref2.width, height = _ref2.height, offset = _ref2.offset;
	return getCoordinatesOfGrid(getTicks(_objectSpread$4(_objectSpread$4(_objectSpread$4({}, CartesianAxis.defaultProps), yAxis), {}, {
		ticks: getTicksOfAxis(yAxis, true),
		viewBox: {
			x: 0,
			y: 0,
			width,
			height
		}
	})), offset.top, offset.top + offset.height, syncWithTicks);
};
var defaultProps = {
	horizontal: true,
	vertical: true,
	horizontalPoints: [],
	verticalPoints: [],
	stroke: "#ccc",
	fill: "none",
	verticalFill: [],
	horizontalFill: []
};
function CartesianGrid(props) {
	var _props$stroke, _props$fill, _props$horizontal3, _props$horizontalFill, _props$vertical3, _props$verticalFill;
	var chartWidth = useChartWidth();
	var chartHeight = useChartHeight();
	var offset = useOffset();
	var propsIncludingDefaults = _objectSpread$4(_objectSpread$4({}, props), {}, {
		stroke: (_props$stroke = props.stroke) !== null && _props$stroke !== void 0 ? _props$stroke : defaultProps.stroke,
		fill: (_props$fill = props.fill) !== null && _props$fill !== void 0 ? _props$fill : defaultProps.fill,
		horizontal: (_props$horizontal3 = props.horizontal) !== null && _props$horizontal3 !== void 0 ? _props$horizontal3 : defaultProps.horizontal,
		horizontalFill: (_props$horizontalFill = props.horizontalFill) !== null && _props$horizontalFill !== void 0 ? _props$horizontalFill : defaultProps.horizontalFill,
		vertical: (_props$vertical3 = props.vertical) !== null && _props$vertical3 !== void 0 ? _props$vertical3 : defaultProps.vertical,
		verticalFill: (_props$verticalFill = props.verticalFill) !== null && _props$verticalFill !== void 0 ? _props$verticalFill : defaultProps.verticalFill,
		x: isNumber(props.x) ? props.x : offset.left,
		y: isNumber(props.y) ? props.y : offset.top,
		width: isNumber(props.width) ? props.width : offset.width,
		height: isNumber(props.height) ? props.height : offset.height
	});
	var x$1 = propsIncludingDefaults.x, y$1 = propsIncludingDefaults.y, width = propsIncludingDefaults.width, height = propsIncludingDefaults.height, syncWithTicks = propsIncludingDefaults.syncWithTicks, horizontalValues = propsIncludingDefaults.horizontalValues, verticalValues = propsIncludingDefaults.verticalValues;
	var xAxis = useArbitraryXAxis();
	var yAxis = useYAxisWithFiniteDomainOrRandom();
	if (!isNumber(width) || width <= 0 || !isNumber(height) || height <= 0 || !isNumber(x$1) || x$1 !== +x$1 || !isNumber(y$1) || y$1 !== +y$1) return null;
	var verticalCoordinatesGenerator = propsIncludingDefaults.verticalCoordinatesGenerator || defaultVerticalCoordinatesGenerator;
	var horizontalCoordinatesGenerator = propsIncludingDefaults.horizontalCoordinatesGenerator || defaultHorizontalCoordinatesGenerator;
	var horizontalPoints = propsIncludingDefaults.horizontalPoints, verticalPoints = propsIncludingDefaults.verticalPoints;
	if ((!horizontalPoints || !horizontalPoints.length) && (0, import_isFunction$3.default)(horizontalCoordinatesGenerator)) {
		var isHorizontalValues = horizontalValues && horizontalValues.length;
		var generatorResult = horizontalCoordinatesGenerator({
			yAxis: yAxis ? _objectSpread$4(_objectSpread$4({}, yAxis), {}, { ticks: isHorizontalValues ? horizontalValues : yAxis.ticks }) : void 0,
			width: chartWidth,
			height: chartHeight,
			offset
		}, isHorizontalValues ? true : syncWithTicks);
		warn(Array.isArray(generatorResult), "horizontalCoordinatesGenerator should return Array but instead it returned [".concat(_typeof$7(generatorResult), "]"));
		if (Array.isArray(generatorResult)) horizontalPoints = generatorResult;
	}
	if ((!verticalPoints || !verticalPoints.length) && (0, import_isFunction$3.default)(verticalCoordinatesGenerator)) {
		var isVerticalValues = verticalValues && verticalValues.length;
		var _generatorResult = verticalCoordinatesGenerator({
			xAxis: xAxis ? _objectSpread$4(_objectSpread$4({}, xAxis), {}, { ticks: isVerticalValues ? verticalValues : xAxis.ticks }) : void 0,
			width: chartWidth,
			height: chartHeight,
			offset
		}, isVerticalValues ? true : syncWithTicks);
		warn(Array.isArray(_generatorResult), "verticalCoordinatesGenerator should return Array but instead it returned [".concat(_typeof$7(_generatorResult), "]"));
		if (Array.isArray(_generatorResult)) verticalPoints = _generatorResult;
	}
	return /* @__PURE__ */ import_react.createElement("g", { className: "recharts-cartesian-grid" }, /* @__PURE__ */ import_react.createElement(Background, {
		fill: propsIncludingDefaults.fill,
		fillOpacity: propsIncludingDefaults.fillOpacity,
		x: propsIncludingDefaults.x,
		y: propsIncludingDefaults.y,
		width: propsIncludingDefaults.width,
		height: propsIncludingDefaults.height,
		ry: propsIncludingDefaults.ry
	}), /* @__PURE__ */ import_react.createElement(HorizontalGridLines, _extends$5({}, propsIncludingDefaults, {
		offset,
		horizontalPoints,
		xAxis,
		yAxis
	})), /* @__PURE__ */ import_react.createElement(VerticalGridLines, _extends$5({}, propsIncludingDefaults, {
		offset,
		verticalPoints,
		xAxis,
		yAxis
	})), /* @__PURE__ */ import_react.createElement(HorizontalStripes, _extends$5({}, propsIncludingDefaults, { horizontalPoints })), /* @__PURE__ */ import_react.createElement(VerticalStripes, _extends$5({}, propsIncludingDefaults, { verticalPoints })));
}
CartesianGrid.displayName = "CartesianGrid";
var import_isFunction$2 = /* @__PURE__ */ __toESM(require_isFunction());
var import_isNil$2 = /* @__PURE__ */ __toESM(require_isNil());
var import_isEqual$1 = /* @__PURE__ */ __toESM(require_isEqual());
var _excluded$2 = [
	"type",
	"layout",
	"connectNulls",
	"ref"
], _excluded2$2 = ["key"];
function _typeof$6(o$1) {
	"@babel/helpers - typeof";
	return _typeof$6 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$2) {
		return typeof o$2;
	} : function(o$2) {
		return o$2 && "function" == typeof Symbol && o$2.constructor === Symbol && o$2 !== Symbol.prototype ? "symbol" : typeof o$2;
	}, _typeof$6(o$1);
}
function _objectWithoutProperties$2(source, excluded) {
	if (source == null) return {};
	var target = _objectWithoutPropertiesLoose$2(source, excluded);
	var key, i$2;
	if (Object.getOwnPropertySymbols) {
		var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
		for (i$2 = 0; i$2 < sourceSymbolKeys.length; i$2++) {
			key = sourceSymbolKeys[i$2];
			if (excluded.indexOf(key) >= 0) continue;
			if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
			target[key] = source[key];
		}
	}
	return target;
}
function _objectWithoutPropertiesLoose$2(source, excluded) {
	if (source == null) return {};
	var target = {};
	for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) {
		if (excluded.indexOf(key) >= 0) continue;
		target[key] = source[key];
	}
	return target;
}
function _extends$4() {
	_extends$4 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i$2 = 1; i$2 < arguments.length; i$2++) {
			var source = arguments[i$2];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$4.apply(this, arguments);
}
function ownKeys$3(e, r$1) {
	var t$1 = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o$1 = Object.getOwnPropertySymbols(e);
		r$1 && (o$1 = o$1.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t$1.push.apply(t$1, o$1);
	}
	return t$1;
}
function _objectSpread$3(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t$1 = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$3(Object(t$1), !0).forEach(function(r$2) {
			_defineProperty$6(e, r$2, t$1[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t$1)) : ownKeys$3(Object(t$1)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t$1, r$2));
		});
	}
	return e;
}
function _toConsumableArray$2(arr) {
	return _arrayWithoutHoles$2(arr) || _iterableToArray$2(arr) || _unsupportedIterableToArray$2(arr) || _nonIterableSpread$2();
}
function _nonIterableSpread$2() {
	throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$2(o$1, minLen) {
	if (!o$1) return;
	if (typeof o$1 === "string") return _arrayLikeToArray$2(o$1, minLen);
	var n$1 = Object.prototype.toString.call(o$1).slice(8, -1);
	if (n$1 === "Object" && o$1.constructor) n$1 = o$1.constructor.name;
	if (n$1 === "Map" || n$1 === "Set") return Array.from(o$1);
	if (n$1 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n$1)) return _arrayLikeToArray$2(o$1, minLen);
}
function _iterableToArray$2(iter) {
	if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles$2(arr) {
	if (Array.isArray(arr)) return _arrayLikeToArray$2(arr);
}
function _arrayLikeToArray$2(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i$2 = 0, arr2 = new Array(len); i$2 < len; i$2++) arr2[i$2] = arr[i$2];
	return arr2;
}
function _classCallCheck$5(instance, Constructor) {
	if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties$5(target, props) {
	for (var i$2 = 0; i$2 < props.length; i$2++) {
		var descriptor = props[i$2];
		descriptor.enumerable = descriptor.enumerable || false;
		descriptor.configurable = true;
		if ("value" in descriptor) descriptor.writable = true;
		Object.defineProperty(target, _toPropertyKey$6(descriptor.key), descriptor);
	}
}
function _createClass$5(Constructor, protoProps, staticProps) {
	if (protoProps) _defineProperties$5(Constructor.prototype, protoProps);
	if (staticProps) _defineProperties$5(Constructor, staticProps);
	Object.defineProperty(Constructor, "prototype", { writable: false });
	return Constructor;
}
function _callSuper$4(t$1, o$1, e) {
	return o$1 = _getPrototypeOf$4(o$1), _possibleConstructorReturn$4(t$1, _isNativeReflectConstruct$4() ? Reflect.construct(o$1, e || [], _getPrototypeOf$4(t$1).constructor) : o$1.apply(t$1, e));
}
function _possibleConstructorReturn$4(self$1, call) {
	if (call && (_typeof$6(call) === "object" || typeof call === "function")) return call;
	else if (call !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
	return _assertThisInitialized$4(self$1);
}
function _assertThisInitialized$4(self$1) {
	if (self$1 === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	return self$1;
}
function _isNativeReflectConstruct$4() {
	try {
		var t$1 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
	} catch (t$2) {}
	return (_isNativeReflectConstruct$4 = function _isNativeReflectConstruct$17() {
		return !!t$1;
	})();
}
function _getPrototypeOf$4(o$1) {
	_getPrototypeOf$4 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf$17(o$2) {
		return o$2.__proto__ || Object.getPrototypeOf(o$2);
	};
	return _getPrototypeOf$4(o$1);
}
function _inherits$4(subClass, superClass) {
	if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
	subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: {
		value: subClass,
		writable: true,
		configurable: true
	} });
	Object.defineProperty(subClass, "prototype", { writable: false });
	if (superClass) _setPrototypeOf$4(subClass, superClass);
}
function _setPrototypeOf$4(o$1, p) {
	_setPrototypeOf$4 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf$17(o$2, p$1) {
		o$2.__proto__ = p$1;
		return o$2;
	};
	return _setPrototypeOf$4(o$1, p);
}
function _defineProperty$6(obj, key, value) {
	key = _toPropertyKey$6(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$6(t$1) {
	var i$2 = _toPrimitive$6(t$1, "string");
	return "symbol" == _typeof$6(i$2) ? i$2 : i$2 + "";
}
function _toPrimitive$6(t$1, r$1) {
	if ("object" != _typeof$6(t$1) || !t$1) return t$1;
	var e = t$1[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i$2 = e.call(t$1, r$1 || "default");
		if ("object" != _typeof$6(i$2)) return i$2;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t$1);
}
var Line = /* @__PURE__ */ function(_PureComponent) {
	function Line$1() {
		var _this;
		_classCallCheck$5(this, Line$1);
		for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
		_this = _callSuper$4(this, Line$1, [].concat(args));
		_defineProperty$6(_this, "state", {
			isAnimationFinished: true,
			totalLength: 0
		});
		_defineProperty$6(_this, "generateSimpleStrokeDasharray", function(totalLength, length) {
			return "".concat(length, "px ").concat(totalLength - length, "px");
		});
		_defineProperty$6(_this, "getStrokeDasharray", function(length, totalLength, lines) {
			var lineLength = lines.reduce(function(pre, next) {
				return pre + next;
			});
			if (!lineLength) return _this.generateSimpleStrokeDasharray(totalLength, length);
			var count = Math.floor(length / lineLength);
			var remainLength = length % lineLength;
			var restLength = totalLength - length;
			var remainLines = [];
			for (var i$2 = 0, sum = 0; i$2 < lines.length; sum += lines[i$2], ++i$2) if (sum + lines[i$2] > remainLength) {
				remainLines = [].concat(_toConsumableArray$2(lines.slice(0, i$2)), [remainLength - sum]);
				break;
			}
			var emptyLines = remainLines.length % 2 === 0 ? [0, restLength] : [restLength];
			return [].concat(_toConsumableArray$2(Line$1.repeat(lines, count)), _toConsumableArray$2(remainLines), emptyLines).map(function(line) {
				return "".concat(line, "px");
			}).join(", ");
		});
		_defineProperty$6(_this, "id", uniqueId("recharts-line-"));
		_defineProperty$6(_this, "pathRef", function(node) {
			_this.mainCurve = node;
		});
		_defineProperty$6(_this, "handleAnimationEnd", function() {
			_this.setState({ isAnimationFinished: true });
			if (_this.props.onAnimationEnd) _this.props.onAnimationEnd();
		});
		_defineProperty$6(_this, "handleAnimationStart", function() {
			_this.setState({ isAnimationFinished: false });
			if (_this.props.onAnimationStart) _this.props.onAnimationStart();
		});
		return _this;
	}
	_inherits$4(Line$1, _PureComponent);
	return _createClass$5(Line$1, [
		{
			key: "componentDidMount",
			value: function componentDidMount() {
				if (!this.props.isAnimationActive) return;
				var totalLength = this.getTotalLength();
				this.setState({ totalLength });
			}
		},
		{
			key: "componentDidUpdate",
			value: function componentDidUpdate() {
				if (!this.props.isAnimationActive) return;
				var totalLength = this.getTotalLength();
				if (totalLength !== this.state.totalLength) this.setState({ totalLength });
			}
		},
		{
			key: "getTotalLength",
			value: function getTotalLength() {
				var curveDom = this.mainCurve;
				try {
					return curveDom && curveDom.getTotalLength && curveDom.getTotalLength() || 0;
				} catch (err) {
					return 0;
				}
			}
		},
		{
			key: "renderErrorBar",
			value: function renderErrorBar(needClip, clipPathId) {
				if (this.props.isAnimationActive && !this.state.isAnimationFinished) return null;
				var _this$props = this.props, points = _this$props.points, xAxis = _this$props.xAxis, yAxis = _this$props.yAxis, layout = _this$props.layout, children = _this$props.children;
				var errorBarItems = findAllByType(children, ErrorBar);
				if (!errorBarItems) return null;
				var dataPointFormatter = function dataPointFormatter$1(dataPoint, dataKey) {
					return {
						x: dataPoint.x,
						y: dataPoint.y,
						value: dataPoint.value,
						errorVal: getValueByDataKey(dataPoint.payload, dataKey)
					};
				};
				var errorBarProps = { clipPath: needClip ? "url(#clipPath-".concat(clipPathId, ")") : null };
				return /* @__PURE__ */ import_react.createElement(Layer, errorBarProps, errorBarItems.map(function(item) {
					return /* @__PURE__ */ import_react.cloneElement(item, {
						key: "bar-".concat(item.props.dataKey),
						data: points,
						xAxis,
						yAxis,
						layout,
						dataPointFormatter
					});
				}));
			}
		},
		{
			key: "renderDots",
			value: function renderDots(needClip, clipDot, clipPathId) {
				if (this.props.isAnimationActive && !this.state.isAnimationFinished) return null;
				var _this$props2 = this.props, dot = _this$props2.dot, points = _this$props2.points, dataKey = _this$props2.dataKey;
				var lineProps = filterProps(this.props, false);
				var customDotProps = filterProps(dot, true);
				var dots = points.map(function(entry, i$2) {
					var dotProps = _objectSpread$3(_objectSpread$3(_objectSpread$3({
						key: "dot-".concat(i$2),
						r: 3
					}, lineProps), customDotProps), {}, {
						index: i$2,
						cx: entry.x,
						cy: entry.y,
						value: entry.value,
						dataKey,
						payload: entry.payload,
						points
					});
					return Line$1.renderDotItem(dot, dotProps);
				});
				var dotsProps = { clipPath: needClip ? "url(#clipPath-".concat(clipDot ? "" : "dots-").concat(clipPathId, ")") : null };
				return /* @__PURE__ */ import_react.createElement(Layer, _extends$4({
					className: "recharts-line-dots",
					key: "dots"
				}, dotsProps), dots);
			}
		},
		{
			key: "renderCurveStatically",
			value: function renderCurveStatically(points, needClip, clipPathId, props) {
				var _this$props3 = this.props, type = _this$props3.type, layout = _this$props3.layout, connectNulls = _this$props3.connectNulls;
				_this$props3.ref;
				var curveProps = _objectSpread$3(_objectSpread$3(_objectSpread$3({}, filterProps(_objectWithoutProperties$2(_this$props3, _excluded$2), true)), {}, {
					fill: "none",
					className: "recharts-line-curve",
					clipPath: needClip ? "url(#clipPath-".concat(clipPathId, ")") : null,
					points
				}, props), {}, {
					type,
					layout,
					connectNulls
				});
				return /* @__PURE__ */ import_react.createElement(Curve, _extends$4({}, curveProps, { pathRef: this.pathRef }));
			}
		},
		{
			key: "renderCurveWithAnimation",
			value: function renderCurveWithAnimation(needClip, clipPathId) {
				var _this2 = this;
				var _this$props4 = this.props, points = _this$props4.points, strokeDasharray = _this$props4.strokeDasharray, isAnimationActive = _this$props4.isAnimationActive, animationBegin = _this$props4.animationBegin, animationDuration = _this$props4.animationDuration, animationEasing = _this$props4.animationEasing, animationId = _this$props4.animationId, animateNewValues = _this$props4.animateNewValues, width = _this$props4.width, height = _this$props4.height;
				var _this$state = this.state, prevPoints = _this$state.prevPoints, totalLength = _this$state.totalLength;
				return /* @__PURE__ */ import_react.createElement(es6_default, {
					begin: animationBegin,
					duration: animationDuration,
					isActive: isAnimationActive,
					easing: animationEasing,
					from: { t: 0 },
					to: { t: 1 },
					key: "line-".concat(animationId),
					onAnimationEnd: this.handleAnimationEnd,
					onAnimationStart: this.handleAnimationStart
				}, function(_ref) {
					var t$1 = _ref.t;
					if (prevPoints) {
						var prevPointsDiffFactor = prevPoints.length / points.length;
						var stepData = points.map(function(entry, index) {
							var prevPointIndex = Math.floor(index * prevPointsDiffFactor);
							if (prevPoints[prevPointIndex]) {
								var prev = prevPoints[prevPointIndex];
								var interpolatorX = interpolateNumber(prev.x, entry.x);
								var interpolatorY = interpolateNumber(prev.y, entry.y);
								return _objectSpread$3(_objectSpread$3({}, entry), {}, {
									x: interpolatorX(t$1),
									y: interpolatorY(t$1)
								});
							}
							if (animateNewValues) {
								var _interpolatorX = interpolateNumber(width * 2, entry.x);
								var _interpolatorY = interpolateNumber(height / 2, entry.y);
								return _objectSpread$3(_objectSpread$3({}, entry), {}, {
									x: _interpolatorX(t$1),
									y: _interpolatorY(t$1)
								});
							}
							return _objectSpread$3(_objectSpread$3({}, entry), {}, {
								x: entry.x,
								y: entry.y
							});
						});
						return _this2.renderCurveStatically(stepData, needClip, clipPathId);
					}
					var curLength = interpolateNumber(0, totalLength)(t$1);
					var currentStrokeDasharray;
					if (strokeDasharray) {
						var lines = "".concat(strokeDasharray).split(/[,\s]+/gim).map(function(num) {
							return parseFloat(num);
						});
						currentStrokeDasharray = _this2.getStrokeDasharray(curLength, totalLength, lines);
					} else currentStrokeDasharray = _this2.generateSimpleStrokeDasharray(totalLength, curLength);
					return _this2.renderCurveStatically(points, needClip, clipPathId, { strokeDasharray: currentStrokeDasharray });
				});
			}
		},
		{
			key: "renderCurve",
			value: function renderCurve(needClip, clipPathId) {
				var _this$props5 = this.props, points = _this$props5.points, isAnimationActive = _this$props5.isAnimationActive;
				var _this$state2 = this.state, prevPoints = _this$state2.prevPoints, totalLength = _this$state2.totalLength;
				if (isAnimationActive && points && points.length && (!prevPoints && totalLength > 0 || !(0, import_isEqual$1.default)(prevPoints, points))) return this.renderCurveWithAnimation(needClip, clipPathId);
				return this.renderCurveStatically(points, needClip, clipPathId);
			}
		},
		{
			key: "render",
			value: function render() {
				var _filterProps;
				var _this$props6 = this.props, hide = _this$props6.hide, dot = _this$props6.dot, points = _this$props6.points, className = _this$props6.className, xAxis = _this$props6.xAxis, yAxis = _this$props6.yAxis, top = _this$props6.top, left = _this$props6.left, width = _this$props6.width, height = _this$props6.height, isAnimationActive = _this$props6.isAnimationActive, id = _this$props6.id;
				if (hide || !points || !points.length) return null;
				var isAnimationFinished = this.state.isAnimationFinished;
				var hasSinglePoint = points.length === 1;
				var layerClass = clsx_default("recharts-line", className);
				var needClipX = xAxis && xAxis.allowDataOverflow;
				var needClipY = yAxis && yAxis.allowDataOverflow;
				var needClip = needClipX || needClipY;
				var clipPathId = (0, import_isNil$2.default)(id) ? this.id : id;
				var _ref2 = (_filterProps = filterProps(dot, false)) !== null && _filterProps !== void 0 ? _filterProps : {
					r: 3,
					strokeWidth: 2
				}, _ref2$r = _ref2.r, r$1 = _ref2$r === void 0 ? 3 : _ref2$r, _ref2$strokeWidth = _ref2.strokeWidth, strokeWidth = _ref2$strokeWidth === void 0 ? 2 : _ref2$strokeWidth;
				var _ref3$clipDot = (hasClipDot(dot) ? dot : {}).clipDot, clipDot = _ref3$clipDot === void 0 ? true : _ref3$clipDot;
				var dotSize = r$1 * 2 + strokeWidth;
				return /* @__PURE__ */ import_react.createElement(Layer, { className: layerClass }, needClipX || needClipY ? /* @__PURE__ */ import_react.createElement("defs", null, /* @__PURE__ */ import_react.createElement("clipPath", { id: "clipPath-".concat(clipPathId) }, /* @__PURE__ */ import_react.createElement("rect", {
					x: needClipX ? left : left - width / 2,
					y: needClipY ? top : top - height / 2,
					width: needClipX ? width : width * 2,
					height: needClipY ? height : height * 2
				})), !clipDot && /* @__PURE__ */ import_react.createElement("clipPath", { id: "clipPath-dots-".concat(clipPathId) }, /* @__PURE__ */ import_react.createElement("rect", {
					x: left - dotSize / 2,
					y: top - dotSize / 2,
					width: width + dotSize,
					height: height + dotSize
				}))) : null, !hasSinglePoint && this.renderCurve(needClip, clipPathId), this.renderErrorBar(needClip, clipPathId), (hasSinglePoint || dot) && this.renderDots(needClip, clipDot, clipPathId), (!isAnimationActive || isAnimationFinished) && LabelList.renderCallByParent(this.props, points));
			}
		}
	], [
		{
			key: "getDerivedStateFromProps",
			value: function getDerivedStateFromProps(nextProps, prevState) {
				if (nextProps.animationId !== prevState.prevAnimationId) return {
					prevAnimationId: nextProps.animationId,
					curPoints: nextProps.points,
					prevPoints: prevState.curPoints
				};
				if (nextProps.points !== prevState.curPoints) return { curPoints: nextProps.points };
				return null;
			}
		},
		{
			key: "repeat",
			value: function repeat(lines, count) {
				var linesUnit = lines.length % 2 !== 0 ? [].concat(_toConsumableArray$2(lines), [0]) : lines;
				var result = [];
				for (var i$2 = 0; i$2 < count; ++i$2) result = [].concat(_toConsumableArray$2(result), _toConsumableArray$2(linesUnit));
				return result;
			}
		},
		{
			key: "renderDotItem",
			value: function renderDotItem(option, props) {
				var dotItem;
				if (/* @__PURE__ */ import_react.isValidElement(option)) dotItem = /* @__PURE__ */ import_react.cloneElement(option, props);
				else if ((0, import_isFunction$2.default)(option)) dotItem = option(props);
				else {
					var key = props.key, dotProps = _objectWithoutProperties$2(props, _excluded2$2);
					var className = clsx_default("recharts-line-dot", typeof option !== "boolean" ? option.className : "");
					dotItem = /* @__PURE__ */ import_react.createElement(Dot, _extends$4({ key }, dotProps, { className }));
				}
				return dotItem;
			}
		}
	]);
}(import_react.PureComponent);
_defineProperty$6(Line, "displayName", "Line");
_defineProperty$6(Line, "defaultProps", {
	xAxisId: 0,
	yAxisId: 0,
	connectNulls: false,
	activeDot: true,
	dot: true,
	legendType: "line",
	stroke: "#3182bd",
	strokeWidth: 1,
	fill: "#fff",
	points: [],
	isAnimationActive: !Global.isSsr,
	animateNewValues: true,
	animationBegin: 0,
	animationDuration: 1500,
	animationEasing: "ease",
	hide: false,
	label: false
});
_defineProperty$6(Line, "getComposedData", function(_ref4) {
	var props = _ref4.props, xAxis = _ref4.xAxis, yAxis = _ref4.yAxis, xAxisTicks = _ref4.xAxisTicks, yAxisTicks = _ref4.yAxisTicks, dataKey = _ref4.dataKey, bandSize = _ref4.bandSize, displayedData = _ref4.displayedData, offset = _ref4.offset;
	var layout = props.layout;
	return _objectSpread$3({
		points: displayedData.map(function(entry, index) {
			var value = getValueByDataKey(entry, dataKey);
			if (layout === "horizontal") return {
				x: getCateCoordinateOfLine({
					axis: xAxis,
					ticks: xAxisTicks,
					bandSize,
					entry,
					index
				}),
				y: (0, import_isNil$2.default)(value) ? null : yAxis.scale(value),
				value,
				payload: entry
			};
			return {
				x: (0, import_isNil$2.default)(value) ? null : xAxis.scale(value),
				y: getCateCoordinateOfLine({
					axis: yAxis,
					ticks: yAxisTicks,
					bandSize,
					entry,
					index
				}),
				value,
				payload: entry
			};
		}),
		layout
	}, offset);
});
var import_isFunction$1 = /* @__PURE__ */ __toESM(require_isFunction());
var import_max = /* @__PURE__ */ __toESM(require_max());
var import_isNil$1 = /* @__PURE__ */ __toESM(require_isNil());
var import_isNaN = /* @__PURE__ */ __toESM(require_isNaN());
var import_isEqual = /* @__PURE__ */ __toESM(require_isEqual());
var _excluded$1 = [
	"layout",
	"type",
	"stroke",
	"connectNulls",
	"isRange",
	"ref"
], _excluded2$1 = ["key"];
var _Area;
function _typeof$5(o$1) {
	"@babel/helpers - typeof";
	return _typeof$5 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$2) {
		return typeof o$2;
	} : function(o$2) {
		return o$2 && "function" == typeof Symbol && o$2.constructor === Symbol && o$2 !== Symbol.prototype ? "symbol" : typeof o$2;
	}, _typeof$5(o$1);
}
function _objectWithoutProperties$1(source, excluded) {
	if (source == null) return {};
	var target = _objectWithoutPropertiesLoose$1(source, excluded);
	var key, i$2;
	if (Object.getOwnPropertySymbols) {
		var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
		for (i$2 = 0; i$2 < sourceSymbolKeys.length; i$2++) {
			key = sourceSymbolKeys[i$2];
			if (excluded.indexOf(key) >= 0) continue;
			if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
			target[key] = source[key];
		}
	}
	return target;
}
function _objectWithoutPropertiesLoose$1(source, excluded) {
	if (source == null) return {};
	var target = {};
	for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) {
		if (excluded.indexOf(key) >= 0) continue;
		target[key] = source[key];
	}
	return target;
}
function _extends$3() {
	_extends$3 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i$2 = 1; i$2 < arguments.length; i$2++) {
			var source = arguments[i$2];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$3.apply(this, arguments);
}
function ownKeys$2(e, r$1) {
	var t$1 = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o$1 = Object.getOwnPropertySymbols(e);
		r$1 && (o$1 = o$1.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t$1.push.apply(t$1, o$1);
	}
	return t$1;
}
function _objectSpread$2(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t$1 = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$2(Object(t$1), !0).forEach(function(r$2) {
			_defineProperty$5(e, r$2, t$1[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t$1)) : ownKeys$2(Object(t$1)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t$1, r$2));
		});
	}
	return e;
}
function _classCallCheck$4(instance, Constructor) {
	if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties$4(target, props) {
	for (var i$2 = 0; i$2 < props.length; i$2++) {
		var descriptor = props[i$2];
		descriptor.enumerable = descriptor.enumerable || false;
		descriptor.configurable = true;
		if ("value" in descriptor) descriptor.writable = true;
		Object.defineProperty(target, _toPropertyKey$5(descriptor.key), descriptor);
	}
}
function _createClass$4(Constructor, protoProps, staticProps) {
	if (protoProps) _defineProperties$4(Constructor.prototype, protoProps);
	if (staticProps) _defineProperties$4(Constructor, staticProps);
	Object.defineProperty(Constructor, "prototype", { writable: false });
	return Constructor;
}
function _callSuper$3(t$1, o$1, e) {
	return o$1 = _getPrototypeOf$3(o$1), _possibleConstructorReturn$3(t$1, _isNativeReflectConstruct$3() ? Reflect.construct(o$1, e || [], _getPrototypeOf$3(t$1).constructor) : o$1.apply(t$1, e));
}
function _possibleConstructorReturn$3(self$1, call) {
	if (call && (_typeof$5(call) === "object" || typeof call === "function")) return call;
	else if (call !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
	return _assertThisInitialized$3(self$1);
}
function _assertThisInitialized$3(self$1) {
	if (self$1 === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	return self$1;
}
function _isNativeReflectConstruct$3() {
	try {
		var t$1 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
	} catch (t$2) {}
	return (_isNativeReflectConstruct$3 = function _isNativeReflectConstruct$17() {
		return !!t$1;
	})();
}
function _getPrototypeOf$3(o$1) {
	_getPrototypeOf$3 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf$17(o$2) {
		return o$2.__proto__ || Object.getPrototypeOf(o$2);
	};
	return _getPrototypeOf$3(o$1);
}
function _inherits$3(subClass, superClass) {
	if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
	subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: {
		value: subClass,
		writable: true,
		configurable: true
	} });
	Object.defineProperty(subClass, "prototype", { writable: false });
	if (superClass) _setPrototypeOf$3(subClass, superClass);
}
function _setPrototypeOf$3(o$1, p) {
	_setPrototypeOf$3 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf$17(o$2, p$1) {
		o$2.__proto__ = p$1;
		return o$2;
	};
	return _setPrototypeOf$3(o$1, p);
}
function _defineProperty$5(obj, key, value) {
	key = _toPropertyKey$5(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$5(t$1) {
	var i$2 = _toPrimitive$5(t$1, "string");
	return "symbol" == _typeof$5(i$2) ? i$2 : i$2 + "";
}
function _toPrimitive$5(t$1, r$1) {
	if ("object" != _typeof$5(t$1) || !t$1) return t$1;
	var e = t$1[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i$2 = e.call(t$1, r$1 || "default");
		if ("object" != _typeof$5(i$2)) return i$2;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t$1);
}
var Area = /* @__PURE__ */ function(_PureComponent) {
	function Area$1() {
		var _this;
		_classCallCheck$4(this, Area$1);
		for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
		_this = _callSuper$3(this, Area$1, [].concat(args));
		_defineProperty$5(_this, "state", { isAnimationFinished: true });
		_defineProperty$5(_this, "id", uniqueId("recharts-area-"));
		_defineProperty$5(_this, "handleAnimationEnd", function() {
			var onAnimationEnd = _this.props.onAnimationEnd;
			_this.setState({ isAnimationFinished: true });
			if ((0, import_isFunction$1.default)(onAnimationEnd)) onAnimationEnd();
		});
		_defineProperty$5(_this, "handleAnimationStart", function() {
			var onAnimationStart = _this.props.onAnimationStart;
			_this.setState({ isAnimationFinished: false });
			if ((0, import_isFunction$1.default)(onAnimationStart)) onAnimationStart();
		});
		return _this;
	}
	_inherits$3(Area$1, _PureComponent);
	return _createClass$4(Area$1, [
		{
			key: "renderDots",
			value: function renderDots(needClip, clipDot, clipPathId) {
				var isAnimationActive = this.props.isAnimationActive;
				var isAnimationFinished = this.state.isAnimationFinished;
				if (isAnimationActive && !isAnimationFinished) return null;
				var _this$props = this.props, dot = _this$props.dot, points = _this$props.points, dataKey = _this$props.dataKey;
				var areaProps = filterProps(this.props, false);
				var customDotProps = filterProps(dot, true);
				var dots = points.map(function(entry, i$2) {
					var dotProps = _objectSpread$2(_objectSpread$2(_objectSpread$2({
						key: "dot-".concat(i$2),
						r: 3
					}, areaProps), customDotProps), {}, {
						index: i$2,
						cx: entry.x,
						cy: entry.y,
						dataKey,
						value: entry.value,
						payload: entry.payload,
						points
					});
					return Area$1.renderDotItem(dot, dotProps);
				});
				var dotsProps = { clipPath: needClip ? "url(#clipPath-".concat(clipDot ? "" : "dots-").concat(clipPathId, ")") : null };
				return /* @__PURE__ */ import_react.createElement(Layer, _extends$3({ className: "recharts-area-dots" }, dotsProps), dots);
			}
		},
		{
			key: "renderHorizontalRect",
			value: function renderHorizontalRect(alpha$1) {
				var _this$props2 = this.props, baseLine = _this$props2.baseLine, points = _this$props2.points, strokeWidth = _this$props2.strokeWidth;
				var startX = points[0].x;
				var endX = points[points.length - 1].x;
				var width = alpha$1 * Math.abs(startX - endX);
				var maxY = (0, import_max.default)(points.map(function(entry) {
					return entry.y || 0;
				}));
				if (isNumber(baseLine) && typeof baseLine === "number") maxY = Math.max(baseLine, maxY);
				else if (baseLine && Array.isArray(baseLine) && baseLine.length) maxY = Math.max((0, import_max.default)(baseLine.map(function(entry) {
					return entry.y || 0;
				})), maxY);
				if (isNumber(maxY)) return /* @__PURE__ */ import_react.createElement("rect", {
					x: startX < endX ? startX : startX - width,
					y: 0,
					width,
					height: Math.floor(maxY + (strokeWidth ? parseInt("".concat(strokeWidth), 10) : 1))
				});
				return null;
			}
		},
		{
			key: "renderVerticalRect",
			value: function renderVerticalRect(alpha$1) {
				var _this$props3 = this.props, baseLine = _this$props3.baseLine, points = _this$props3.points, strokeWidth = _this$props3.strokeWidth;
				var startY = points[0].y;
				var endY = points[points.length - 1].y;
				var height = alpha$1 * Math.abs(startY - endY);
				var maxX = (0, import_max.default)(points.map(function(entry) {
					return entry.x || 0;
				}));
				if (isNumber(baseLine) && typeof baseLine === "number") maxX = Math.max(baseLine, maxX);
				else if (baseLine && Array.isArray(baseLine) && baseLine.length) maxX = Math.max((0, import_max.default)(baseLine.map(function(entry) {
					return entry.x || 0;
				})), maxX);
				if (isNumber(maxX)) return /* @__PURE__ */ import_react.createElement("rect", {
					x: 0,
					y: startY < endY ? startY : startY - height,
					width: maxX + (strokeWidth ? parseInt("".concat(strokeWidth), 10) : 1),
					height: Math.floor(height)
				});
				return null;
			}
		},
		{
			key: "renderClipRect",
			value: function renderClipRect(alpha$1) {
				if (this.props.layout === "vertical") return this.renderVerticalRect(alpha$1);
				return this.renderHorizontalRect(alpha$1);
			}
		},
		{
			key: "renderAreaStatically",
			value: function renderAreaStatically(points, baseLine, needClip, clipPathId) {
				var _this$props4 = this.props, layout = _this$props4.layout, type = _this$props4.type, stroke = _this$props4.stroke, connectNulls = _this$props4.connectNulls, isRange = _this$props4.isRange;
				_this$props4.ref;
				var others = _objectWithoutProperties$1(_this$props4, _excluded$1);
				return /* @__PURE__ */ import_react.createElement(Layer, { clipPath: needClip ? "url(#clipPath-".concat(clipPathId, ")") : null }, /* @__PURE__ */ import_react.createElement(Curve, _extends$3({}, filterProps(others, true), {
					points,
					connectNulls,
					type,
					baseLine,
					layout,
					stroke: "none",
					className: "recharts-area-area"
				})), stroke !== "none" && /* @__PURE__ */ import_react.createElement(Curve, _extends$3({}, filterProps(this.props, false), {
					className: "recharts-area-curve",
					layout,
					type,
					connectNulls,
					fill: "none",
					points
				})), stroke !== "none" && isRange && /* @__PURE__ */ import_react.createElement(Curve, _extends$3({}, filterProps(this.props, false), {
					className: "recharts-area-curve",
					layout,
					type,
					connectNulls,
					fill: "none",
					points: baseLine
				})));
			}
		},
		{
			key: "renderAreaWithAnimation",
			value: function renderAreaWithAnimation(needClip, clipPathId) {
				var _this2 = this;
				var _this$props5 = this.props, points = _this$props5.points, baseLine = _this$props5.baseLine, isAnimationActive = _this$props5.isAnimationActive, animationBegin = _this$props5.animationBegin, animationDuration = _this$props5.animationDuration, animationEasing = _this$props5.animationEasing, animationId = _this$props5.animationId;
				var _this$state = this.state, prevPoints = _this$state.prevPoints, prevBaseLine = _this$state.prevBaseLine;
				return /* @__PURE__ */ import_react.createElement(es6_default, {
					begin: animationBegin,
					duration: animationDuration,
					isActive: isAnimationActive,
					easing: animationEasing,
					from: { t: 0 },
					to: { t: 1 },
					key: "area-".concat(animationId),
					onAnimationEnd: this.handleAnimationEnd,
					onAnimationStart: this.handleAnimationStart
				}, function(_ref) {
					var t$1 = _ref.t;
					if (prevPoints) {
						var prevPointsDiffFactor = prevPoints.length / points.length;
						var stepPoints = points.map(function(entry, index) {
							var prevPointIndex = Math.floor(index * prevPointsDiffFactor);
							if (prevPoints[prevPointIndex]) {
								var prev = prevPoints[prevPointIndex];
								var interpolatorX = interpolateNumber(prev.x, entry.x);
								var interpolatorY = interpolateNumber(prev.y, entry.y);
								return _objectSpread$2(_objectSpread$2({}, entry), {}, {
									x: interpolatorX(t$1),
									y: interpolatorY(t$1)
								});
							}
							return entry;
						});
						var stepBaseLine;
						if (isNumber(baseLine) && typeof baseLine === "number") stepBaseLine = interpolateNumber(prevBaseLine, baseLine)(t$1);
						else if ((0, import_isNil$1.default)(baseLine) || (0, import_isNaN.default)(baseLine)) stepBaseLine = interpolateNumber(prevBaseLine, 0)(t$1);
						else stepBaseLine = baseLine.map(function(entry, index) {
							var prevPointIndex = Math.floor(index * prevPointsDiffFactor);
							if (prevBaseLine[prevPointIndex]) {
								var prev = prevBaseLine[prevPointIndex];
								var interpolatorX = interpolateNumber(prev.x, entry.x);
								var interpolatorY = interpolateNumber(prev.y, entry.y);
								return _objectSpread$2(_objectSpread$2({}, entry), {}, {
									x: interpolatorX(t$1),
									y: interpolatorY(t$1)
								});
							}
							return entry;
						});
						return _this2.renderAreaStatically(stepPoints, stepBaseLine, needClip, clipPathId);
					}
					return /* @__PURE__ */ import_react.createElement(Layer, null, /* @__PURE__ */ import_react.createElement("defs", null, /* @__PURE__ */ import_react.createElement("clipPath", { id: "animationClipPath-".concat(clipPathId) }, _this2.renderClipRect(t$1))), /* @__PURE__ */ import_react.createElement(Layer, { clipPath: "url(#animationClipPath-".concat(clipPathId, ")") }, _this2.renderAreaStatically(points, baseLine, needClip, clipPathId)));
				});
			}
		},
		{
			key: "renderArea",
			value: function renderArea(needClip, clipPathId) {
				var _this$props6 = this.props, points = _this$props6.points, baseLine = _this$props6.baseLine, isAnimationActive = _this$props6.isAnimationActive;
				var _this$state2 = this.state, prevPoints = _this$state2.prevPoints, prevBaseLine = _this$state2.prevBaseLine, totalLength = _this$state2.totalLength;
				if (isAnimationActive && points && points.length && (!prevPoints && totalLength > 0 || !(0, import_isEqual.default)(prevPoints, points) || !(0, import_isEqual.default)(prevBaseLine, baseLine))) return this.renderAreaWithAnimation(needClip, clipPathId);
				return this.renderAreaStatically(points, baseLine, needClip, clipPathId);
			}
		},
		{
			key: "render",
			value: function render() {
				var _filterProps;
				var _this$props7 = this.props, hide = _this$props7.hide, dot = _this$props7.dot, points = _this$props7.points, className = _this$props7.className, top = _this$props7.top, left = _this$props7.left, xAxis = _this$props7.xAxis, yAxis = _this$props7.yAxis, width = _this$props7.width, height = _this$props7.height, isAnimationActive = _this$props7.isAnimationActive, id = _this$props7.id;
				if (hide || !points || !points.length) return null;
				var isAnimationFinished = this.state.isAnimationFinished;
				var hasSinglePoint = points.length === 1;
				var layerClass = clsx_default("recharts-area", className);
				var needClipX = xAxis && xAxis.allowDataOverflow;
				var needClipY = yAxis && yAxis.allowDataOverflow;
				var needClip = needClipX || needClipY;
				var clipPathId = (0, import_isNil$1.default)(id) ? this.id : id;
				var _ref2 = (_filterProps = filterProps(dot, false)) !== null && _filterProps !== void 0 ? _filterProps : {
					r: 3,
					strokeWidth: 2
				}, _ref2$r = _ref2.r, r$1 = _ref2$r === void 0 ? 3 : _ref2$r, _ref2$strokeWidth = _ref2.strokeWidth, strokeWidth = _ref2$strokeWidth === void 0 ? 2 : _ref2$strokeWidth;
				var _ref3$clipDot = (hasClipDot(dot) ? dot : {}).clipDot, clipDot = _ref3$clipDot === void 0 ? true : _ref3$clipDot;
				var dotSize = r$1 * 2 + strokeWidth;
				return /* @__PURE__ */ import_react.createElement(Layer, { className: layerClass }, needClipX || needClipY ? /* @__PURE__ */ import_react.createElement("defs", null, /* @__PURE__ */ import_react.createElement("clipPath", { id: "clipPath-".concat(clipPathId) }, /* @__PURE__ */ import_react.createElement("rect", {
					x: needClipX ? left : left - width / 2,
					y: needClipY ? top : top - height / 2,
					width: needClipX ? width : width * 2,
					height: needClipY ? height : height * 2
				})), !clipDot && /* @__PURE__ */ import_react.createElement("clipPath", { id: "clipPath-dots-".concat(clipPathId) }, /* @__PURE__ */ import_react.createElement("rect", {
					x: left - dotSize / 2,
					y: top - dotSize / 2,
					width: width + dotSize,
					height: height + dotSize
				}))) : null, !hasSinglePoint ? this.renderArea(needClip, clipPathId) : null, (dot || hasSinglePoint) && this.renderDots(needClip, clipDot, clipPathId), (!isAnimationActive || isAnimationFinished) && LabelList.renderCallByParent(this.props, points));
			}
		}
	], [{
		key: "getDerivedStateFromProps",
		value: function getDerivedStateFromProps(nextProps, prevState) {
			if (nextProps.animationId !== prevState.prevAnimationId) return {
				prevAnimationId: nextProps.animationId,
				curPoints: nextProps.points,
				curBaseLine: nextProps.baseLine,
				prevPoints: prevState.curPoints,
				prevBaseLine: prevState.curBaseLine
			};
			if (nextProps.points !== prevState.curPoints || nextProps.baseLine !== prevState.curBaseLine) return {
				curPoints: nextProps.points,
				curBaseLine: nextProps.baseLine
			};
			return null;
		}
	}]);
}(import_react.PureComponent);
_Area = Area;
_defineProperty$5(Area, "displayName", "Area");
_defineProperty$5(Area, "defaultProps", {
	stroke: "#3182bd",
	fill: "#3182bd",
	fillOpacity: .6,
	xAxisId: 0,
	yAxisId: 0,
	legendType: "line",
	connectNulls: false,
	points: [],
	dot: false,
	activeDot: true,
	hide: false,
	isAnimationActive: !Global.isSsr,
	animationBegin: 0,
	animationDuration: 1500,
	animationEasing: "ease"
});
_defineProperty$5(Area, "getBaseValue", function(props, item, xAxis, yAxis) {
	var layout = props.layout, chartBaseValue = props.baseValue;
	var itemBaseValue = item.props.baseValue;
	var baseValue = itemBaseValue !== null && itemBaseValue !== void 0 ? itemBaseValue : chartBaseValue;
	if (isNumber(baseValue) && typeof baseValue === "number") return baseValue;
	var numericAxis = layout === "horizontal" ? yAxis : xAxis;
	var domain = numericAxis.scale.domain();
	if (numericAxis.type === "number") {
		var domainMax = Math.max(domain[0], domain[1]);
		var domainMin = Math.min(domain[0], domain[1]);
		if (baseValue === "dataMin") return domainMin;
		if (baseValue === "dataMax") return domainMax;
		return domainMax < 0 ? domainMax : Math.max(Math.min(domain[0], domain[1]), 0);
	}
	if (baseValue === "dataMin") return domain[0];
	if (baseValue === "dataMax") return domain[1];
	return domain[0];
});
_defineProperty$5(Area, "getComposedData", function(_ref4) {
	var props = _ref4.props, item = _ref4.item, xAxis = _ref4.xAxis, yAxis = _ref4.yAxis, xAxisTicks = _ref4.xAxisTicks, yAxisTicks = _ref4.yAxisTicks, bandSize = _ref4.bandSize, dataKey = _ref4.dataKey, stackedData = _ref4.stackedData, dataStartIndex = _ref4.dataStartIndex, displayedData = _ref4.displayedData, offset = _ref4.offset;
	var layout = props.layout;
	var hasStack = stackedData && stackedData.length;
	var baseValue = _Area.getBaseValue(props, item, xAxis, yAxis);
	var isHorizontalLayout = layout === "horizontal";
	var isRange = false;
	var points = displayedData.map(function(entry, index) {
		var value;
		if (hasStack) value = stackedData[dataStartIndex + index];
		else {
			value = getValueByDataKey(entry, dataKey);
			if (!Array.isArray(value)) value = [baseValue, value];
			else isRange = true;
		}
		var isBreakPoint = value[1] == null || hasStack && getValueByDataKey(entry, dataKey) == null;
		if (isHorizontalLayout) return {
			x: getCateCoordinateOfLine({
				axis: xAxis,
				ticks: xAxisTicks,
				bandSize,
				entry,
				index
			}),
			y: isBreakPoint ? null : yAxis.scale(value[1]),
			value,
			payload: entry
		};
		return {
			x: isBreakPoint ? null : xAxis.scale(value[1]),
			y: getCateCoordinateOfLine({
				axis: yAxis,
				ticks: yAxisTicks,
				bandSize,
				entry,
				index
			}),
			value,
			payload: entry
		};
	});
	var baseLine;
	if (hasStack || isRange) baseLine = points.map(function(entry) {
		var x$1 = Array.isArray(entry.value) ? entry.value[0] : null;
		if (isHorizontalLayout) return {
			x: entry.x,
			y: x$1 != null && entry.y != null ? yAxis.scale(x$1) : null
		};
		return {
			x: x$1 != null ? xAxis.scale(x$1) : null,
			y: entry.y
		};
	});
	else baseLine = isHorizontalLayout ? yAxis.scale(baseValue) : xAxis.scale(baseValue);
	return _objectSpread$2({
		points,
		baseLine,
		layout,
		isRange
	}, offset);
});
_defineProperty$5(Area, "renderDotItem", function(option, props) {
	var dotItem;
	if (/* @__PURE__ */ import_react.isValidElement(option)) dotItem = /* @__PURE__ */ import_react.cloneElement(option, props);
	else if ((0, import_isFunction$1.default)(option)) dotItem = option(props);
	else {
		var className = clsx_default("recharts-area-dot", typeof option !== "boolean" ? option.className : "");
		var key = props.key, rest = _objectWithoutProperties$1(props, _excluded2$1);
		dotItem = /* @__PURE__ */ import_react.createElement(Dot, _extends$3({}, rest, {
			key,
			className
		}));
	}
	return dotItem;
});
function _typeof$4(o$1) {
	"@babel/helpers - typeof";
	return _typeof$4 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$2) {
		return typeof o$2;
	} : function(o$2) {
		return o$2 && "function" == typeof Symbol && o$2.constructor === Symbol && o$2 !== Symbol.prototype ? "symbol" : typeof o$2;
	}, _typeof$4(o$1);
}
function _classCallCheck$3(instance, Constructor) {
	if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties$3(target, props) {
	for (var i$2 = 0; i$2 < props.length; i$2++) {
		var descriptor = props[i$2];
		descriptor.enumerable = descriptor.enumerable || false;
		descriptor.configurable = true;
		if ("value" in descriptor) descriptor.writable = true;
		Object.defineProperty(target, _toPropertyKey$4(descriptor.key), descriptor);
	}
}
function _createClass$3(Constructor, protoProps, staticProps) {
	if (protoProps) _defineProperties$3(Constructor.prototype, protoProps);
	if (staticProps) _defineProperties$3(Constructor, staticProps);
	Object.defineProperty(Constructor, "prototype", { writable: false });
	return Constructor;
}
function _callSuper$2(t$1, o$1, e) {
	return o$1 = _getPrototypeOf$2(o$1), _possibleConstructorReturn$2(t$1, _isNativeReflectConstruct$2() ? Reflect.construct(o$1, e || [], _getPrototypeOf$2(t$1).constructor) : o$1.apply(t$1, e));
}
function _possibleConstructorReturn$2(self$1, call) {
	if (call && (_typeof$4(call) === "object" || typeof call === "function")) return call;
	else if (call !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
	return _assertThisInitialized$2(self$1);
}
function _assertThisInitialized$2(self$1) {
	if (self$1 === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	return self$1;
}
function _isNativeReflectConstruct$2() {
	try {
		var t$1 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
	} catch (t$2) {}
	return (_isNativeReflectConstruct$2 = function _isNativeReflectConstruct$17() {
		return !!t$1;
	})();
}
function _getPrototypeOf$2(o$1) {
	_getPrototypeOf$2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf$17(o$2) {
		return o$2.__proto__ || Object.getPrototypeOf(o$2);
	};
	return _getPrototypeOf$2(o$1);
}
function _inherits$2(subClass, superClass) {
	if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
	subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: {
		value: subClass,
		writable: true,
		configurable: true
	} });
	Object.defineProperty(subClass, "prototype", { writable: false });
	if (superClass) _setPrototypeOf$2(subClass, superClass);
}
function _setPrototypeOf$2(o$1, p) {
	_setPrototypeOf$2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf$17(o$2, p$1) {
		o$2.__proto__ = p$1;
		return o$2;
	};
	return _setPrototypeOf$2(o$1, p);
}
function _defineProperty$4(obj, key, value) {
	key = _toPropertyKey$4(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$4(t$1) {
	var i$2 = _toPrimitive$4(t$1, "string");
	return "symbol" == _typeof$4(i$2) ? i$2 : i$2 + "";
}
function _toPrimitive$4(t$1, r$1) {
	if ("object" != _typeof$4(t$1) || !t$1) return t$1;
	var e = t$1[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i$2 = e.call(t$1, r$1 || "default");
		if ("object" != _typeof$4(i$2)) return i$2;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t$1);
}
function _extends$2() {
	_extends$2 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i$2 = 1; i$2 < arguments.length; i$2++) {
			var source = arguments[i$2];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$2.apply(this, arguments);
}
function XAxisImpl(_ref) {
	var xAxisId = _ref.xAxisId;
	var width = useChartWidth();
	var height = useChartHeight();
	var axisOptions = useXAxisOrThrow(xAxisId);
	if (axisOptions == null) return null;
	return /* @__PURE__ */ import_react.createElement(CartesianAxis, _extends$2({}, axisOptions, {
		className: clsx_default("recharts-".concat(axisOptions.axisType, " ").concat(axisOptions.axisType), axisOptions.className),
		viewBox: {
			x: 0,
			y: 0,
			width,
			height
		},
		ticksGenerator: function ticksGenerator(axis) {
			return getTicksOfAxis(axis, true);
		}
	}));
}
var XAxis = /* @__PURE__ */ function(_React$Component) {
	function XAxis$1() {
		_classCallCheck$3(this, XAxis$1);
		return _callSuper$2(this, XAxis$1, arguments);
	}
	_inherits$2(XAxis$1, _React$Component);
	return _createClass$3(XAxis$1, [{
		key: "render",
		value: function render() {
			return /* @__PURE__ */ import_react.createElement(XAxisImpl, this.props);
		}
	}]);
}(import_react.Component);
_defineProperty$4(XAxis, "displayName", "XAxis");
_defineProperty$4(XAxis, "defaultProps", {
	allowDecimals: true,
	hide: false,
	orientation: "bottom",
	width: 0,
	height: 30,
	mirror: false,
	xAxisId: 0,
	tickCount: 5,
	type: "category",
	padding: {
		left: 0,
		right: 0
	},
	allowDataOverflow: false,
	scale: "auto",
	reversed: false,
	allowDuplicatedCategory: true
});
function _typeof$3(o$1) {
	"@babel/helpers - typeof";
	return _typeof$3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$2) {
		return typeof o$2;
	} : function(o$2) {
		return o$2 && "function" == typeof Symbol && o$2.constructor === Symbol && o$2 !== Symbol.prototype ? "symbol" : typeof o$2;
	}, _typeof$3(o$1);
}
function _classCallCheck$2(instance, Constructor) {
	if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties$2(target, props) {
	for (var i$2 = 0; i$2 < props.length; i$2++) {
		var descriptor = props[i$2];
		descriptor.enumerable = descriptor.enumerable || false;
		descriptor.configurable = true;
		if ("value" in descriptor) descriptor.writable = true;
		Object.defineProperty(target, _toPropertyKey$3(descriptor.key), descriptor);
	}
}
function _createClass$2(Constructor, protoProps, staticProps) {
	if (protoProps) _defineProperties$2(Constructor.prototype, protoProps);
	if (staticProps) _defineProperties$2(Constructor, staticProps);
	Object.defineProperty(Constructor, "prototype", { writable: false });
	return Constructor;
}
function _callSuper$1(t$1, o$1, e) {
	return o$1 = _getPrototypeOf$1(o$1), _possibleConstructorReturn$1(t$1, _isNativeReflectConstruct$1() ? Reflect.construct(o$1, e || [], _getPrototypeOf$1(t$1).constructor) : o$1.apply(t$1, e));
}
function _possibleConstructorReturn$1(self$1, call) {
	if (call && (_typeof$3(call) === "object" || typeof call === "function")) return call;
	else if (call !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
	return _assertThisInitialized$1(self$1);
}
function _assertThisInitialized$1(self$1) {
	if (self$1 === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	return self$1;
}
function _isNativeReflectConstruct$1() {
	try {
		var t$1 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
	} catch (t$2) {}
	return (_isNativeReflectConstruct$1 = function _isNativeReflectConstruct$17() {
		return !!t$1;
	})();
}
function _getPrototypeOf$1(o$1) {
	_getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf$17(o$2) {
		return o$2.__proto__ || Object.getPrototypeOf(o$2);
	};
	return _getPrototypeOf$1(o$1);
}
function _inherits$1(subClass, superClass) {
	if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
	subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: {
		value: subClass,
		writable: true,
		configurable: true
	} });
	Object.defineProperty(subClass, "prototype", { writable: false });
	if (superClass) _setPrototypeOf$1(subClass, superClass);
}
function _setPrototypeOf$1(o$1, p) {
	_setPrototypeOf$1 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf$17(o$2, p$1) {
		o$2.__proto__ = p$1;
		return o$2;
	};
	return _setPrototypeOf$1(o$1, p);
}
function _defineProperty$3(obj, key, value) {
	key = _toPropertyKey$3(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$3(t$1) {
	var i$2 = _toPrimitive$3(t$1, "string");
	return "symbol" == _typeof$3(i$2) ? i$2 : i$2 + "";
}
function _toPrimitive$3(t$1, r$1) {
	if ("object" != _typeof$3(t$1) || !t$1) return t$1;
	var e = t$1[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i$2 = e.call(t$1, r$1 || "default");
		if ("object" != _typeof$3(i$2)) return i$2;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t$1);
}
function _extends$1() {
	_extends$1 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i$2 = 1; i$2 < arguments.length; i$2++) {
			var source = arguments[i$2];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$1.apply(this, arguments);
}
var YAxisImpl = function YAxisImpl$1(_ref) {
	var yAxisId = _ref.yAxisId;
	var width = useChartWidth();
	var height = useChartHeight();
	var axisOptions = useYAxisOrThrow(yAxisId);
	if (axisOptions == null) return null;
	return /* @__PURE__ */ import_react.createElement(CartesianAxis, _extends$1({}, axisOptions, {
		className: clsx_default("recharts-".concat(axisOptions.axisType, " ").concat(axisOptions.axisType), axisOptions.className),
		viewBox: {
			x: 0,
			y: 0,
			width,
			height
		},
		ticksGenerator: function ticksGenerator(axis) {
			return getTicksOfAxis(axis, true);
		}
	}));
};
var YAxis = /* @__PURE__ */ function(_React$Component) {
	function YAxis$1() {
		_classCallCheck$2(this, YAxis$1);
		return _callSuper$1(this, YAxis$1, arguments);
	}
	_inherits$1(YAxis$1, _React$Component);
	return _createClass$2(YAxis$1, [{
		key: "render",
		value: function render() {
			return /* @__PURE__ */ import_react.createElement(YAxisImpl, this.props);
		}
	}]);
}(import_react.Component);
_defineProperty$3(YAxis, "displayName", "YAxis");
_defineProperty$3(YAxis, "defaultProps", {
	allowDuplicatedCategory: true,
	allowDecimals: true,
	hide: false,
	orientation: "left",
	width: 60,
	height: 0,
	mirror: false,
	yAxisId: 0,
	tickCount: 5,
	type: "number",
	padding: {
		top: 0,
		bottom: 0
	},
	allowDataOverflow: false,
	scale: "auto",
	reversed: false
});
function _toConsumableArray$1(arr) {
	return _arrayWithoutHoles$1(arr) || _iterableToArray$1(arr) || _unsupportedIterableToArray$1(arr) || _nonIterableSpread$1();
}
function _nonIterableSpread$1() {
	throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$1(o$1, minLen) {
	if (!o$1) return;
	if (typeof o$1 === "string") return _arrayLikeToArray$1(o$1, minLen);
	var n$1 = Object.prototype.toString.call(o$1).slice(8, -1);
	if (n$1 === "Object" && o$1.constructor) n$1 = o$1.constructor.name;
	if (n$1 === "Map" || n$1 === "Set") return Array.from(o$1);
	if (n$1 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n$1)) return _arrayLikeToArray$1(o$1, minLen);
}
function _iterableToArray$1(iter) {
	if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles$1(arr) {
	if (Array.isArray(arr)) return _arrayLikeToArray$1(arr);
}
function _arrayLikeToArray$1(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i$2 = 0, arr2 = new Array(len); i$2 < len; i$2++) arr2[i$2] = arr[i$2];
	return arr2;
}
var detectReferenceElementsDomain = function detectReferenceElementsDomain$1(children, domain, axisId, axisType, specifiedTicks) {
	var lines = findAllByType(children, ReferenceLine);
	var dots = findAllByType(children, ReferenceDot);
	var elements = [].concat(_toConsumableArray$1(lines), _toConsumableArray$1(dots));
	var areas = findAllByType(children, ReferenceArea);
	var idKey = "".concat(axisType, "Id");
	var valueKey = axisType[0];
	var finalDomain = domain;
	if (elements.length) finalDomain = elements.reduce(function(result, el) {
		if (el.props[idKey] === axisId && ifOverflowMatches(el.props, "extendDomain") && isNumber(el.props[valueKey])) {
			var value = el.props[valueKey];
			return [Math.min(result[0], value), Math.max(result[1], value)];
		}
		return result;
	}, finalDomain);
	if (areas.length) {
		var key1 = "".concat(valueKey, "1");
		var key2 = "".concat(valueKey, "2");
		finalDomain = areas.reduce(function(result, el) {
			if (el.props[idKey] === axisId && ifOverflowMatches(el.props, "extendDomain") && isNumber(el.props[key1]) && isNumber(el.props[key2])) {
				var value1 = el.props[key1];
				var value2 = el.props[key2];
				return [Math.min(result[0], value1, value2), Math.max(result[1], value1, value2)];
			}
			return result;
		}, finalDomain);
	}
	if (specifiedTicks && specifiedTicks.length) finalDomain = specifiedTicks.reduce(function(result, tick) {
		if (isNumber(tick)) return [Math.min(result[0], tick), Math.max(result[1], tick)];
		return result;
	}, finalDomain);
	return finalDomain;
};
var eventCenter = new (/* @__PURE__ */ __toESM((/* @__PURE__ */ __commonJSMin(((exports, module) => {
	var has = Object.prototype.hasOwnProperty, prefix = "~";
	function Events() {}
	if (Object.create) {
		Events.prototype = Object.create(null);
		if (!new Events().__proto__) prefix = false;
	}
	function EE(fn, context, once) {
		this.fn = fn;
		this.context = context;
		this.once = once || false;
	}
	function addListener(emitter, event, fn, context, once) {
		if (typeof fn !== "function") throw new TypeError("The listener must be a function");
		var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
		if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
		else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
		else emitter._events[evt] = [emitter._events[evt], listener];
		return emitter;
	}
	function clearEvent(emitter, evt) {
		if (--emitter._eventsCount === 0) emitter._events = new Events();
		else delete emitter._events[evt];
	}
	function EventEmitter$1() {
		this._events = new Events();
		this._eventsCount = 0;
	}
	EventEmitter$1.prototype.eventNames = function eventNames() {
		var names = [], events, name;
		if (this._eventsCount === 0) return names;
		for (name in events = this._events) if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
		if (Object.getOwnPropertySymbols) return names.concat(Object.getOwnPropertySymbols(events));
		return names;
	};
	EventEmitter$1.prototype.listeners = function listeners(event) {
		var evt = prefix ? prefix + event : event, handlers = this._events[evt];
		if (!handlers) return [];
		if (handlers.fn) return [handlers.fn];
		for (var i$2 = 0, l = handlers.length, ee = new Array(l); i$2 < l; i$2++) ee[i$2] = handlers[i$2].fn;
		return ee;
	};
	EventEmitter$1.prototype.listenerCount = function listenerCount(event) {
		var evt = prefix ? prefix + event : event, listeners = this._events[evt];
		if (!listeners) return 0;
		if (listeners.fn) return 1;
		return listeners.length;
	};
	EventEmitter$1.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
		var evt = prefix ? prefix + event : event;
		if (!this._events[evt]) return false;
		var listeners = this._events[evt], len = arguments.length, args, i$2;
		if (listeners.fn) {
			if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
			switch (len) {
				case 1: return listeners.fn.call(listeners.context), true;
				case 2: return listeners.fn.call(listeners.context, a1), true;
				case 3: return listeners.fn.call(listeners.context, a1, a2), true;
				case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
				case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
				case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
			}
			for (i$2 = 1, args = new Array(len - 1); i$2 < len; i$2++) args[i$2 - 1] = arguments[i$2];
			listeners.fn.apply(listeners.context, args);
		} else {
			var length = listeners.length, j;
			for (i$2 = 0; i$2 < length; i$2++) {
				if (listeners[i$2].once) this.removeListener(event, listeners[i$2].fn, void 0, true);
				switch (len) {
					case 1:
						listeners[i$2].fn.call(listeners[i$2].context);
						break;
					case 2:
						listeners[i$2].fn.call(listeners[i$2].context, a1);
						break;
					case 3:
						listeners[i$2].fn.call(listeners[i$2].context, a1, a2);
						break;
					case 4:
						listeners[i$2].fn.call(listeners[i$2].context, a1, a2, a3);
						break;
					default:
						if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) args[j - 1] = arguments[j];
						listeners[i$2].fn.apply(listeners[i$2].context, args);
				}
			}
		}
		return true;
	};
	EventEmitter$1.prototype.on = function on(event, fn, context) {
		return addListener(this, event, fn, context, false);
	};
	EventEmitter$1.prototype.once = function once(event, fn, context) {
		return addListener(this, event, fn, context, true);
	};
	EventEmitter$1.prototype.removeListener = function removeListener(event, fn, context, once) {
		var evt = prefix ? prefix + event : event;
		if (!this._events[evt]) return this;
		if (!fn) {
			clearEvent(this, evt);
			return this;
		}
		var listeners = this._events[evt];
		if (listeners.fn) {
			if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) clearEvent(this, evt);
		} else {
			for (var i$2 = 0, events = [], length = listeners.length; i$2 < length; i$2++) if (listeners[i$2].fn !== fn || once && !listeners[i$2].once || context && listeners[i$2].context !== context) events.push(listeners[i$2]);
			if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
			else clearEvent(this, evt);
		}
		return this;
	};
	EventEmitter$1.prototype.removeAllListeners = function removeAllListeners(event) {
		var evt;
		if (event) {
			evt = prefix ? prefix + event : event;
			if (this._events[evt]) clearEvent(this, evt);
		} else {
			this._events = new Events();
			this._eventsCount = 0;
		}
		return this;
	};
	EventEmitter$1.prototype.off = EventEmitter$1.prototype.removeListener;
	EventEmitter$1.prototype.addListener = EventEmitter$1.prototype.on;
	EventEmitter$1.prefixed = prefix;
	EventEmitter$1.EventEmitter = EventEmitter$1;
	if ("undefined" !== typeof module) module.exports = EventEmitter$1;
})))())).default();
var SYNC_EVENT = "recharts.syncMouseEvents";
function _typeof$2(o$1) {
	"@babel/helpers - typeof";
	return _typeof$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$2) {
		return typeof o$2;
	} : function(o$2) {
		return o$2 && "function" == typeof Symbol && o$2.constructor === Symbol && o$2 !== Symbol.prototype ? "symbol" : typeof o$2;
	}, _typeof$2(o$1);
}
function _classCallCheck$1(instance, Constructor) {
	if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties$1(target, props) {
	for (var i$2 = 0; i$2 < props.length; i$2++) {
		var descriptor = props[i$2];
		descriptor.enumerable = descriptor.enumerable || false;
		descriptor.configurable = true;
		if ("value" in descriptor) descriptor.writable = true;
		Object.defineProperty(target, _toPropertyKey$2(descriptor.key), descriptor);
	}
}
function _createClass$1(Constructor, protoProps, staticProps) {
	if (protoProps) _defineProperties$1(Constructor.prototype, protoProps);
	if (staticProps) _defineProperties$1(Constructor, staticProps);
	Object.defineProperty(Constructor, "prototype", { writable: false });
	return Constructor;
}
function _defineProperty$2(obj, key, value) {
	key = _toPropertyKey$2(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$2(t$1) {
	var i$2 = _toPrimitive$2(t$1, "string");
	return "symbol" == _typeof$2(i$2) ? i$2 : i$2 + "";
}
function _toPrimitive$2(t$1, r$1) {
	if ("object" != _typeof$2(t$1) || !t$1) return t$1;
	var e = t$1[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i$2 = e.call(t$1, r$1 || "default");
		if ("object" != _typeof$2(i$2)) return i$2;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t$1);
}
var AccessibilityManager = /* @__PURE__ */ function() {
	function AccessibilityManager$1() {
		_classCallCheck$1(this, AccessibilityManager$1);
		_defineProperty$2(this, "activeIndex", 0);
		_defineProperty$2(this, "coordinateList", []);
		_defineProperty$2(this, "layout", "horizontal");
	}
	return _createClass$1(AccessibilityManager$1, [
		{
			key: "setDetails",
			value: function setDetails(_ref) {
				var _ref2;
				var _ref$coordinateList = _ref.coordinateList, coordinateList = _ref$coordinateList === void 0 ? null : _ref$coordinateList, _ref$container = _ref.container, container = _ref$container === void 0 ? null : _ref$container, _ref$layout = _ref.layout, layout = _ref$layout === void 0 ? null : _ref$layout, _ref$offset = _ref.offset, offset = _ref$offset === void 0 ? null : _ref$offset, _ref$mouseHandlerCall = _ref.mouseHandlerCallback, mouseHandlerCallback = _ref$mouseHandlerCall === void 0 ? null : _ref$mouseHandlerCall;
				this.coordinateList = (_ref2 = coordinateList !== null && coordinateList !== void 0 ? coordinateList : this.coordinateList) !== null && _ref2 !== void 0 ? _ref2 : [];
				this.container = container !== null && container !== void 0 ? container : this.container;
				this.layout = layout !== null && layout !== void 0 ? layout : this.layout;
				this.offset = offset !== null && offset !== void 0 ? offset : this.offset;
				this.mouseHandlerCallback = mouseHandlerCallback !== null && mouseHandlerCallback !== void 0 ? mouseHandlerCallback : this.mouseHandlerCallback;
				this.activeIndex = Math.min(Math.max(this.activeIndex, 0), this.coordinateList.length - 1);
			}
		},
		{
			key: "focus",
			value: function focus() {
				this.spoofMouse();
			}
		},
		{
			key: "keyboardEvent",
			value: function keyboardEvent(e) {
				if (this.coordinateList.length === 0) return;
				switch (e.key) {
					case "ArrowRight":
						if (this.layout !== "horizontal") return;
						this.activeIndex = Math.min(this.activeIndex + 1, this.coordinateList.length - 1);
						this.spoofMouse();
						break;
					case "ArrowLeft":
						if (this.layout !== "horizontal") return;
						this.activeIndex = Math.max(this.activeIndex - 1, 0);
						this.spoofMouse();
						break;
					default: break;
				}
			}
		},
		{
			key: "setIndex",
			value: function setIndex(newIndex) {
				this.activeIndex = newIndex;
			}
		},
		{
			key: "spoofMouse",
			value: function spoofMouse() {
				var _window, _window2;
				if (this.layout !== "horizontal") return;
				if (this.coordinateList.length === 0) return;
				var _this$container$getBo = this.container.getBoundingClientRect(), x$1 = _this$container$getBo.x, y$1 = _this$container$getBo.y, height = _this$container$getBo.height;
				var coordinate = this.coordinateList[this.activeIndex].coordinate;
				var scrollOffsetX = ((_window = window) === null || _window === void 0 ? void 0 : _window.scrollX) || 0;
				var scrollOffsetY = ((_window2 = window) === null || _window2 === void 0 ? void 0 : _window2.scrollY) || 0;
				var pageX = x$1 + coordinate + scrollOffsetX;
				var pageY = y$1 + this.offset.top + height / 2 + scrollOffsetY;
				this.mouseHandlerCallback({
					pageX,
					pageY
				});
			}
		}
	]);
}();
function isDomainSpecifiedByUser(domain, allowDataOverflow, axisType) {
	if (axisType === "number" && allowDataOverflow === true && Array.isArray(domain)) {
		var domainStart = domain === null || domain === void 0 ? void 0 : domain[0];
		var domainEnd = domain === null || domain === void 0 ? void 0 : domain[1];
		if (!!domainStart && !!domainEnd && isNumber(domainStart) && isNumber(domainEnd)) return true;
	}
	return false;
}
function getCursorRectangle(layout, activeCoordinate, offset, tooltipAxisBandSize) {
	var halfSize = tooltipAxisBandSize / 2;
	return {
		stroke: "none",
		fill: "#ccc",
		x: layout === "horizontal" ? activeCoordinate.x - halfSize : offset.left + .5,
		y: layout === "horizontal" ? offset.top + .5 : activeCoordinate.y - halfSize,
		width: layout === "horizontal" ? tooltipAxisBandSize : offset.width - 1,
		height: layout === "horizontal" ? offset.height - 1 : tooltipAxisBandSize
	};
}
function getRadialCursorPoints(activeCoordinate) {
	var cx = activeCoordinate.cx, cy = activeCoordinate.cy, radius = activeCoordinate.radius, startAngle = activeCoordinate.startAngle, endAngle = activeCoordinate.endAngle;
	return {
		points: [polarToCartesian(cx, cy, radius, startAngle), polarToCartesian(cx, cy, radius, endAngle)],
		cx,
		cy,
		radius,
		startAngle,
		endAngle
	};
}
function getCursorPoints(layout, activeCoordinate, offset) {
	var x1, y1, x2, y2;
	if (layout === "horizontal") {
		x1 = activeCoordinate.x;
		x2 = x1;
		y1 = offset.top;
		y2 = offset.top + offset.height;
	} else if (layout === "vertical") {
		y1 = activeCoordinate.y;
		y2 = y1;
		x1 = offset.left;
		x2 = offset.left + offset.width;
	} else if (activeCoordinate.cx != null && activeCoordinate.cy != null) if (layout === "centric") {
		var cx = activeCoordinate.cx, cy = activeCoordinate.cy, innerRadius = activeCoordinate.innerRadius, outerRadius = activeCoordinate.outerRadius, angle = activeCoordinate.angle;
		var innerPoint = polarToCartesian(cx, cy, innerRadius, angle);
		var outerPoint = polarToCartesian(cx, cy, outerRadius, angle);
		x1 = innerPoint.x;
		y1 = innerPoint.y;
		x2 = outerPoint.x;
		y2 = outerPoint.y;
	} else return getRadialCursorPoints(activeCoordinate);
	return [{
		x: x1,
		y: y1
	}, {
		x: x2,
		y: y2
	}];
}
function _typeof$1(o$1) {
	"@babel/helpers - typeof";
	return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$2) {
		return typeof o$2;
	} : function(o$2) {
		return o$2 && "function" == typeof Symbol && o$2.constructor === Symbol && o$2 !== Symbol.prototype ? "symbol" : typeof o$2;
	}, _typeof$1(o$1);
}
function ownKeys$1(e, r$1) {
	var t$1 = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o$1 = Object.getOwnPropertySymbols(e);
		r$1 && (o$1 = o$1.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t$1.push.apply(t$1, o$1);
	}
	return t$1;
}
function _objectSpread$1(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t$1 = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$1(Object(t$1), !0).forEach(function(r$2) {
			_defineProperty$1(e, r$2, t$1[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t$1)) : ownKeys$1(Object(t$1)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t$1, r$2));
		});
	}
	return e;
}
function _defineProperty$1(obj, key, value) {
	key = _toPropertyKey$1(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$1(t$1) {
	var i$2 = _toPrimitive$1(t$1, "string");
	return "symbol" == _typeof$1(i$2) ? i$2 : i$2 + "";
}
function _toPrimitive$1(t$1, r$1) {
	if ("object" != _typeof$1(t$1) || !t$1) return t$1;
	var e = t$1[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i$2 = e.call(t$1, r$1 || "default");
		if ("object" != _typeof$1(i$2)) return i$2;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t$1);
}
function Cursor(props) {
	var _element$props$cursor, _defaultProps;
	var element = props.element, tooltipEventType = props.tooltipEventType, isActive = props.isActive, activeCoordinate = props.activeCoordinate, activePayload = props.activePayload, offset = props.offset, activeTooltipIndex = props.activeTooltipIndex, tooltipAxisBandSize = props.tooltipAxisBandSize, layout = props.layout, chartName = props.chartName;
	var elementPropsCursor = (_element$props$cursor = element.props.cursor) !== null && _element$props$cursor !== void 0 ? _element$props$cursor : (_defaultProps = element.type.defaultProps) === null || _defaultProps === void 0 ? void 0 : _defaultProps.cursor;
	if (!element || !elementPropsCursor || !isActive || !activeCoordinate || chartName !== "ScatterChart" && tooltipEventType !== "axis") return null;
	var restProps;
	var cursorComp = Curve;
	if (chartName === "ScatterChart") {
		restProps = activeCoordinate;
		cursorComp = Cross;
	} else if (chartName === "BarChart") {
		restProps = getCursorRectangle(layout, activeCoordinate, offset, tooltipAxisBandSize);
		cursorComp = Rectangle;
	} else if (layout === "radial") {
		var _getRadialCursorPoint = getRadialCursorPoints(activeCoordinate), cx = _getRadialCursorPoint.cx, cy = _getRadialCursorPoint.cy, radius = _getRadialCursorPoint.radius;
		restProps = {
			cx,
			cy,
			startAngle: _getRadialCursorPoint.startAngle,
			endAngle: _getRadialCursorPoint.endAngle,
			innerRadius: radius,
			outerRadius: radius
		};
		cursorComp = Sector;
	} else {
		restProps = { points: getCursorPoints(layout, activeCoordinate, offset) };
		cursorComp = Curve;
	}
	var cursorProps = _objectSpread$1(_objectSpread$1(_objectSpread$1(_objectSpread$1({
		stroke: "#ccc",
		pointerEvents: "none"
	}, offset), restProps), filterProps(elementPropsCursor, false)), {}, {
		payload: activePayload,
		payloadIndex: activeTooltipIndex,
		className: clsx_default("recharts-tooltip-cursor", elementPropsCursor.className)
	});
	return /* @__PURE__ */ (0, import_react.isValidElement)(elementPropsCursor) ? /* @__PURE__ */ (0, import_react.cloneElement)(elementPropsCursor, cursorProps) : /* @__PURE__ */ (0, import_react.createElement)(cursorComp, cursorProps);
}
var import_isNil = /* @__PURE__ */ __toESM(require_isNil());
var import_isFunction = /* @__PURE__ */ __toESM(require_isFunction());
var import_range = /* @__PURE__ */ __toESM(require_range());
var import_get = /* @__PURE__ */ __toESM(require_get());
var import_sortBy = /* @__PURE__ */ __toESM(require_sortBy());
var import_throttle = /* @__PURE__ */ __toESM(require_throttle());
var _excluded = ["item"], _excluded2 = [
	"children",
	"className",
	"width",
	"height",
	"style",
	"compact",
	"title",
	"desc"
];
function _typeof(o$1) {
	"@babel/helpers - typeof";
	return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$2) {
		return typeof o$2;
	} : function(o$2) {
		return o$2 && "function" == typeof Symbol && o$2.constructor === Symbol && o$2 !== Symbol.prototype ? "symbol" : typeof o$2;
	}, _typeof(o$1);
}
function _extends() {
	_extends = Object.assign ? Object.assign.bind() : function(target) {
		for (var i$2 = 1; i$2 < arguments.length; i$2++) {
			var source = arguments[i$2];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends.apply(this, arguments);
}
function _slicedToArray(arr, i$2) {
	return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i$2) || _unsupportedIterableToArray(arr, i$2) || _nonIterableRest();
}
function _nonIterableRest() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArrayLimit(r$1, l) {
	var t$1 = null == r$1 ? null : "undefined" != typeof Symbol && r$1[Symbol.iterator] || r$1["@@iterator"];
	if (null != t$1) {
		var e, n$1, i$2, u, a$2 = [], f = !0, o$1 = !1;
		try {
			if (i$2 = (t$1 = t$1.call(r$1)).next, 0 === l) {
				if (Object(t$1) !== t$1) return;
				f = !1;
			} else for (; !(f = (e = i$2.call(t$1)).done) && (a$2.push(e.value), a$2.length !== l); f = !0);
		} catch (r$2) {
			o$1 = !0, n$1 = r$2;
		} finally {
			try {
				if (!f && null != t$1["return"] && (u = t$1["return"](), Object(u) !== u)) return;
			} finally {
				if (o$1) throw n$1;
			}
		}
		return a$2;
	}
}
function _arrayWithHoles(arr) {
	if (Array.isArray(arr)) return arr;
}
function _objectWithoutProperties(source, excluded) {
	if (source == null) return {};
	var target = _objectWithoutPropertiesLoose(source, excluded);
	var key, i$2;
	if (Object.getOwnPropertySymbols) {
		var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
		for (i$2 = 0; i$2 < sourceSymbolKeys.length; i$2++) {
			key = sourceSymbolKeys[i$2];
			if (excluded.indexOf(key) >= 0) continue;
			if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
			target[key] = source[key];
		}
	}
	return target;
}
function _objectWithoutPropertiesLoose(source, excluded) {
	if (source == null) return {};
	var target = {};
	for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) {
		if (excluded.indexOf(key) >= 0) continue;
		target[key] = source[key];
	}
	return target;
}
function _classCallCheck(instance, Constructor) {
	if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
	for (var i$2 = 0; i$2 < props.length; i$2++) {
		var descriptor = props[i$2];
		descriptor.enumerable = descriptor.enumerable || false;
		descriptor.configurable = true;
		if ("value" in descriptor) descriptor.writable = true;
		Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
	}
}
function _createClass(Constructor, protoProps, staticProps) {
	if (protoProps) _defineProperties(Constructor.prototype, protoProps);
	if (staticProps) _defineProperties(Constructor, staticProps);
	Object.defineProperty(Constructor, "prototype", { writable: false });
	return Constructor;
}
function _callSuper(t$1, o$1, e) {
	return o$1 = _getPrototypeOf(o$1), _possibleConstructorReturn(t$1, _isNativeReflectConstruct() ? Reflect.construct(o$1, e || [], _getPrototypeOf(t$1).constructor) : o$1.apply(t$1, e));
}
function _possibleConstructorReturn(self$1, call) {
	if (call && (_typeof(call) === "object" || typeof call === "function")) return call;
	else if (call !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
	return _assertThisInitialized(self$1);
}
function _assertThisInitialized(self$1) {
	if (self$1 === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	return self$1;
}
function _isNativeReflectConstruct() {
	try {
		var t$1 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
	} catch (t$2) {}
	return (_isNativeReflectConstruct = function _isNativeReflectConstruct$17() {
		return !!t$1;
	})();
}
function _getPrototypeOf(o$1) {
	_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf$17(o$2) {
		return o$2.__proto__ || Object.getPrototypeOf(o$2);
	};
	return _getPrototypeOf(o$1);
}
function _inherits(subClass, superClass) {
	if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
	subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: {
		value: subClass,
		writable: true,
		configurable: true
	} });
	Object.defineProperty(subClass, "prototype", { writable: false });
	if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o$1, p) {
	_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf$17(o$2, p$1) {
		o$2.__proto__ = p$1;
		return o$2;
	};
	return _setPrototypeOf(o$1, p);
}
function _toConsumableArray(arr) {
	return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _nonIterableSpread() {
	throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o$1, minLen) {
	if (!o$1) return;
	if (typeof o$1 === "string") return _arrayLikeToArray(o$1, minLen);
	var n$1 = Object.prototype.toString.call(o$1).slice(8, -1);
	if (n$1 === "Object" && o$1.constructor) n$1 = o$1.constructor.name;
	if (n$1 === "Map" || n$1 === "Set") return Array.from(o$1);
	if (n$1 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n$1)) return _arrayLikeToArray(o$1, minLen);
}
function _iterableToArray(iter) {
	if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles(arr) {
	if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
function _arrayLikeToArray(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i$2 = 0, arr2 = new Array(len); i$2 < len; i$2++) arr2[i$2] = arr[i$2];
	return arr2;
}
function ownKeys(e, r$1) {
	var t$1 = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o$1 = Object.getOwnPropertySymbols(e);
		r$1 && (o$1 = o$1.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t$1.push.apply(t$1, o$1);
	}
	return t$1;
}
function _objectSpread(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t$1 = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys(Object(t$1), !0).forEach(function(r$2) {
			_defineProperty(e, r$2, t$1[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t$1)) : ownKeys(Object(t$1)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t$1, r$2));
		});
	}
	return e;
}
function _defineProperty(obj, key, value) {
	key = _toPropertyKey(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey(t$1) {
	var i$2 = _toPrimitive(t$1, "string");
	return "symbol" == _typeof(i$2) ? i$2 : i$2 + "";
}
function _toPrimitive(t$1, r$1) {
	if ("object" != _typeof(t$1) || !t$1) return t$1;
	var e = t$1[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i$2 = e.call(t$1, r$1 || "default");
		if ("object" != _typeof(i$2)) return i$2;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t$1);
}
var ORIENT_MAP = {
	xAxis: ["bottom", "top"],
	yAxis: ["left", "right"]
};
var FULL_WIDTH_AND_HEIGHT = {
	width: "100%",
	height: "100%"
};
var originCoordinate = {
	x: 0,
	y: 0
};
function renderAsIs(element) {
	return element;
}
var calculateTooltipPos = function calculateTooltipPos$1(rangeObj, layout) {
	if (layout === "horizontal") return rangeObj.x;
	if (layout === "vertical") return rangeObj.y;
	if (layout === "centric") return rangeObj.angle;
	return rangeObj.radius;
};
var getActiveCoordinate = function getActiveCoordinate$1(layout, tooltipTicks, activeIndex, rangeObj) {
	var entry = tooltipTicks.find(function(tick) {
		return tick && tick.index === activeIndex;
	});
	if (entry) {
		if (layout === "horizontal") return {
			x: entry.coordinate,
			y: rangeObj.y
		};
		if (layout === "vertical") return {
			x: rangeObj.x,
			y: entry.coordinate
		};
		if (layout === "centric") {
			var _angle = entry.coordinate;
			var _radius = rangeObj.radius;
			return _objectSpread(_objectSpread(_objectSpread({}, rangeObj), polarToCartesian(rangeObj.cx, rangeObj.cy, _radius, _angle)), {}, {
				angle: _angle,
				radius: _radius
			});
		}
		var radius = entry.coordinate;
		var angle = rangeObj.angle;
		return _objectSpread(_objectSpread(_objectSpread({}, rangeObj), polarToCartesian(rangeObj.cx, rangeObj.cy, radius, angle)), {}, {
			angle,
			radius
		});
	}
	return originCoordinate;
};
var getDisplayedData = function getDisplayedData$1(data, _ref) {
	var graphicalItems = _ref.graphicalItems, dataStartIndex = _ref.dataStartIndex, dataEndIndex = _ref.dataEndIndex;
	var itemsData = (graphicalItems !== null && graphicalItems !== void 0 ? graphicalItems : []).reduce(function(result, child) {
		var itemData = child.props.data;
		if (itemData && itemData.length) return [].concat(_toConsumableArray(result), _toConsumableArray(itemData));
		return result;
	}, []);
	if (itemsData.length > 0) return itemsData;
	if (data && data.length && isNumber(dataStartIndex) && isNumber(dataEndIndex)) return data.slice(dataStartIndex, dataEndIndex + 1);
	return [];
};
function getDefaultDomainByAxisType(axisType) {
	return axisType === "number" ? [0, "auto"] : void 0;
}
var getTooltipContent = function getTooltipContent$1(state, chartData, activeIndex, activeLabel) {
	var graphicalItems = state.graphicalItems, tooltipAxis = state.tooltipAxis;
	var displayedData = getDisplayedData(chartData, state);
	if (activeIndex < 0 || !graphicalItems || !graphicalItems.length || activeIndex >= displayedData.length) return null;
	return graphicalItems.reduce(function(result, child) {
		var _child$props$data;
		var data = (_child$props$data = child.props.data) !== null && _child$props$data !== void 0 ? _child$props$data : chartData;
		if (data && state.dataStartIndex + state.dataEndIndex !== 0 && state.dataEndIndex - state.dataStartIndex >= activeIndex) data = data.slice(state.dataStartIndex, state.dataEndIndex + 1);
		var payload;
		if (tooltipAxis.dataKey && !tooltipAxis.allowDuplicatedCategory) payload = findEntryInArray(data === void 0 ? displayedData : data, tooltipAxis.dataKey, activeLabel);
		else payload = data && data[activeIndex] || displayedData[activeIndex];
		if (!payload) return result;
		return [].concat(_toConsumableArray(result), [getTooltipItem(child, payload)]);
	}, []);
};
var getTooltipData = function getTooltipData$1(state, chartData, layout, rangeObj) {
	var rangeData = rangeObj || {
		x: state.chartX,
		y: state.chartY
	};
	var pos = calculateTooltipPos(rangeData, layout);
	var ticks$1 = state.orderedTooltipTicks, axis = state.tooltipAxis, tooltipTicks = state.tooltipTicks;
	var activeIndex = calculateActiveTickIndex(pos, ticks$1, tooltipTicks, axis);
	if (activeIndex >= 0 && tooltipTicks) {
		var activeLabel = tooltipTicks[activeIndex] && tooltipTicks[activeIndex].value;
		return {
			activeTooltipIndex: activeIndex,
			activeLabel,
			activePayload: getTooltipContent(state, chartData, activeIndex, activeLabel),
			activeCoordinate: getActiveCoordinate(layout, ticks$1, activeIndex, rangeData)
		};
	}
	return null;
};
var getAxisMapByAxes = function getAxisMapByAxes$1(props, _ref2) {
	var axes = _ref2.axes, graphicalItems = _ref2.graphicalItems, axisType = _ref2.axisType, axisIdKey = _ref2.axisIdKey, stackGroups = _ref2.stackGroups, dataStartIndex = _ref2.dataStartIndex, dataEndIndex = _ref2.dataEndIndex;
	var layout = props.layout, children = props.children, stackOffset = props.stackOffset;
	var isCategorical = isCategoricalAxis(layout, axisType);
	return axes.reduce(function(result, child) {
		var _childProps$domain2;
		var childProps = child.type.defaultProps !== void 0 ? _objectSpread(_objectSpread({}, child.type.defaultProps), child.props) : child.props;
		var type = childProps.type, dataKey = childProps.dataKey, allowDataOverflow = childProps.allowDataOverflow, allowDuplicatedCategory = childProps.allowDuplicatedCategory, scale = childProps.scale, ticks$1 = childProps.ticks, includeHidden = childProps.includeHidden;
		var axisId = childProps[axisIdKey];
		if (result[axisId]) return result;
		var displayedData = getDisplayedData(props.data, {
			graphicalItems: graphicalItems.filter(function(item) {
				var _defaultProps;
				return (axisIdKey in item.props ? item.props[axisIdKey] : (_defaultProps = item.type.defaultProps) === null || _defaultProps === void 0 ? void 0 : _defaultProps[axisIdKey]) === axisId;
			}),
			dataStartIndex,
			dataEndIndex
		});
		var len = displayedData.length;
		var domain, duplicateDomain, categoricalDomain;
		if (isDomainSpecifiedByUser(childProps.domain, allowDataOverflow, type)) {
			domain = parseSpecifiedDomain(childProps.domain, null, allowDataOverflow);
			if (isCategorical && (type === "number" || scale !== "auto")) categoricalDomain = getDomainOfDataByKey(displayedData, dataKey, "category");
		}
		var defaultDomain = getDefaultDomainByAxisType(type);
		if (!domain || domain.length === 0) {
			var _childProps$domain;
			var childDomain = (_childProps$domain = childProps.domain) !== null && _childProps$domain !== void 0 ? _childProps$domain : defaultDomain;
			if (dataKey) {
				domain = getDomainOfDataByKey(displayedData, dataKey, type);
				if (type === "category" && isCategorical) {
					var duplicate = hasDuplicate(domain);
					if (allowDuplicatedCategory && duplicate) {
						duplicateDomain = domain;
						domain = (0, import_range.default)(0, len);
					} else if (!allowDuplicatedCategory) domain = parseDomainOfCategoryAxis(childDomain, domain, child).reduce(function(finalDomain, entry) {
						return finalDomain.indexOf(entry) >= 0 ? finalDomain : [].concat(_toConsumableArray(finalDomain), [entry]);
					}, []);
				} else if (type === "category") if (!allowDuplicatedCategory) domain = parseDomainOfCategoryAxis(childDomain, domain, child).reduce(function(finalDomain, entry) {
					return finalDomain.indexOf(entry) >= 0 || entry === "" || (0, import_isNil.default)(entry) ? finalDomain : [].concat(_toConsumableArray(finalDomain), [entry]);
				}, []);
				else domain = domain.filter(function(entry) {
					return entry !== "" && !(0, import_isNil.default)(entry);
				});
				else if (type === "number") {
					var errorBarsDomain = parseErrorBarsOfAxis(displayedData, graphicalItems.filter(function(item) {
						var _defaultProps2, _defaultProps3;
						var itemAxisId = axisIdKey in item.props ? item.props[axisIdKey] : (_defaultProps2 = item.type.defaultProps) === null || _defaultProps2 === void 0 ? void 0 : _defaultProps2[axisIdKey];
						var itemHide = "hide" in item.props ? item.props.hide : (_defaultProps3 = item.type.defaultProps) === null || _defaultProps3 === void 0 ? void 0 : _defaultProps3.hide;
						return itemAxisId === axisId && (includeHidden || !itemHide);
					}), dataKey, axisType, layout);
					if (errorBarsDomain) domain = errorBarsDomain;
				}
				if (isCategorical && (type === "number" || scale !== "auto")) categoricalDomain = getDomainOfDataByKey(displayedData, dataKey, "category");
			} else if (isCategorical) domain = (0, import_range.default)(0, len);
			else if (stackGroups && stackGroups[axisId] && stackGroups[axisId].hasStack && type === "number") domain = stackOffset === "expand" ? [0, 1] : getDomainOfStackGroups(stackGroups[axisId].stackGroups, dataStartIndex, dataEndIndex);
			else domain = getDomainOfItemsWithSameAxis(displayedData, graphicalItems.filter(function(item) {
				var itemAxisId = axisIdKey in item.props ? item.props[axisIdKey] : item.type.defaultProps[axisIdKey];
				var itemHide = "hide" in item.props ? item.props.hide : item.type.defaultProps.hide;
				return itemAxisId === axisId && (includeHidden || !itemHide);
			}), type, layout, true);
			if (type === "number") {
				domain = detectReferenceElementsDomain(children, domain, axisId, axisType, ticks$1);
				if (childDomain) domain = parseSpecifiedDomain(childDomain, domain, allowDataOverflow);
			} else if (type === "category" && childDomain) {
				var axisDomain = childDomain;
				if (domain.every(function(entry) {
					return axisDomain.indexOf(entry) >= 0;
				})) domain = axisDomain;
			}
		}
		return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, axisId, _objectSpread(_objectSpread({}, childProps), {}, {
			axisType,
			domain,
			categoricalDomain,
			duplicateDomain,
			originalDomain: (_childProps$domain2 = childProps.domain) !== null && _childProps$domain2 !== void 0 ? _childProps$domain2 : defaultDomain,
			isCategorical,
			layout
		})));
	}, {});
};
var getAxisMapByItems = function getAxisMapByItems$1(props, _ref3) {
	var graphicalItems = _ref3.graphicalItems, Axis = _ref3.Axis, axisType = _ref3.axisType, axisIdKey = _ref3.axisIdKey, stackGroups = _ref3.stackGroups, dataStartIndex = _ref3.dataStartIndex, dataEndIndex = _ref3.dataEndIndex;
	var layout = props.layout, children = props.children;
	var displayedData = getDisplayedData(props.data, {
		graphicalItems,
		dataStartIndex,
		dataEndIndex
	});
	var len = displayedData.length;
	var isCategorical = isCategoricalAxis(layout, axisType);
	var index = -1;
	return graphicalItems.reduce(function(result, child) {
		var axisId = (child.type.defaultProps !== void 0 ? _objectSpread(_objectSpread({}, child.type.defaultProps), child.props) : child.props)[axisIdKey];
		var originalDomain = getDefaultDomainByAxisType("number");
		if (!result[axisId]) {
			index++;
			var domain;
			if (isCategorical) domain = (0, import_range.default)(0, len);
			else if (stackGroups && stackGroups[axisId] && stackGroups[axisId].hasStack) {
				domain = getDomainOfStackGroups(stackGroups[axisId].stackGroups, dataStartIndex, dataEndIndex);
				domain = detectReferenceElementsDomain(children, domain, axisId, axisType);
			} else {
				domain = parseSpecifiedDomain(originalDomain, getDomainOfItemsWithSameAxis(displayedData, graphicalItems.filter(function(item) {
					var _defaultProps4, _defaultProps5;
					var itemAxisId = axisIdKey in item.props ? item.props[axisIdKey] : (_defaultProps4 = item.type.defaultProps) === null || _defaultProps4 === void 0 ? void 0 : _defaultProps4[axisIdKey];
					var itemHide = "hide" in item.props ? item.props.hide : (_defaultProps5 = item.type.defaultProps) === null || _defaultProps5 === void 0 ? void 0 : _defaultProps5.hide;
					return itemAxisId === axisId && !itemHide;
				}), "number", layout), Axis.defaultProps.allowDataOverflow);
				domain = detectReferenceElementsDomain(children, domain, axisId, axisType);
			}
			return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, axisId, _objectSpread(_objectSpread({ axisType }, Axis.defaultProps), {}, {
				hide: true,
				orientation: (0, import_get.default)(ORIENT_MAP, "".concat(axisType, ".").concat(index % 2), null),
				domain,
				originalDomain,
				isCategorical,
				layout
			})));
		}
		return result;
	}, {});
};
var getAxisMap = function getAxisMap$1(props, _ref4) {
	var _ref4$axisType = _ref4.axisType, axisType = _ref4$axisType === void 0 ? "xAxis" : _ref4$axisType, AxisComp = _ref4.AxisComp, graphicalItems = _ref4.graphicalItems, stackGroups = _ref4.stackGroups, dataStartIndex = _ref4.dataStartIndex, dataEndIndex = _ref4.dataEndIndex;
	var children = props.children;
	var axisIdKey = "".concat(axisType, "Id");
	var axes = findAllByType(children, AxisComp);
	var axisMap = {};
	if (axes && axes.length) axisMap = getAxisMapByAxes(props, {
		axes,
		graphicalItems,
		axisType,
		axisIdKey,
		stackGroups,
		dataStartIndex,
		dataEndIndex
	});
	else if (graphicalItems && graphicalItems.length) axisMap = getAxisMapByItems(props, {
		Axis: AxisComp,
		graphicalItems,
		axisType,
		axisIdKey,
		stackGroups,
		dataStartIndex,
		dataEndIndex
	});
	return axisMap;
};
var tooltipTicksGenerator = function tooltipTicksGenerator$1(axisMap) {
	var axis = getAnyElementOfObject(axisMap);
	var tooltipTicks = getTicksOfAxis(axis, false, true);
	return {
		tooltipTicks,
		orderedTooltipTicks: (0, import_sortBy.default)(tooltipTicks, function(o$1) {
			return o$1.coordinate;
		}),
		tooltipAxis: axis,
		tooltipAxisBandSize: getBandSizeOfAxis(axis, tooltipTicks)
	};
};
var createDefaultState = function createDefaultState$1(props) {
	var children = props.children, defaultShowTooltip = props.defaultShowTooltip;
	var brushItem = findChildByType(children, Brush);
	var startIndex = 0;
	var endIndex = 0;
	if (props.data && props.data.length !== 0) endIndex = props.data.length - 1;
	if (brushItem && brushItem.props) {
		if (brushItem.props.startIndex >= 0) startIndex = brushItem.props.startIndex;
		if (brushItem.props.endIndex >= 0) endIndex = brushItem.props.endIndex;
	}
	return {
		chartX: 0,
		chartY: 0,
		dataStartIndex: startIndex,
		dataEndIndex: endIndex,
		activeTooltipIndex: -1,
		isTooltipActive: Boolean(defaultShowTooltip)
	};
};
var hasGraphicalBarItem = function hasGraphicalBarItem$1(graphicalItems) {
	if (!graphicalItems || !graphicalItems.length) return false;
	return graphicalItems.some(function(item) {
		var name = getDisplayName(item && item.type);
		return name && name.indexOf("Bar") >= 0;
	});
};
var getAxisNameByLayout = function getAxisNameByLayout$1(layout) {
	if (layout === "horizontal") return {
		numericAxisName: "yAxis",
		cateAxisName: "xAxis"
	};
	if (layout === "vertical") return {
		numericAxisName: "xAxis",
		cateAxisName: "yAxis"
	};
	if (layout === "centric") return {
		numericAxisName: "radiusAxis",
		cateAxisName: "angleAxis"
	};
	return {
		numericAxisName: "angleAxis",
		cateAxisName: "radiusAxis"
	};
};
var calculateOffset = function calculateOffset$1(_ref5, prevLegendBBox) {
	var props = _ref5.props, graphicalItems = _ref5.graphicalItems, _ref5$xAxisMap = _ref5.xAxisMap, xAxisMap = _ref5$xAxisMap === void 0 ? {} : _ref5$xAxisMap, _ref5$yAxisMap = _ref5.yAxisMap, yAxisMap = _ref5$yAxisMap === void 0 ? {} : _ref5$yAxisMap;
	var width = props.width, height = props.height, children = props.children;
	var margin = props.margin || {};
	var brushItem = findChildByType(children, Brush);
	var legendItem = findChildByType(children, Legend);
	var offsetH = Object.keys(yAxisMap).reduce(function(result, id) {
		var entry = yAxisMap[id];
		var orientation = entry.orientation;
		if (!entry.mirror && !entry.hide) return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, orientation, result[orientation] + entry.width));
		return result;
	}, {
		left: margin.left || 0,
		right: margin.right || 0
	});
	var offset = _objectSpread(_objectSpread({}, Object.keys(xAxisMap).reduce(function(result, id) {
		var entry = xAxisMap[id];
		var orientation = entry.orientation;
		if (!entry.mirror && !entry.hide) return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, orientation, (0, import_get.default)(result, "".concat(orientation)) + entry.height));
		return result;
	}, {
		top: margin.top || 0,
		bottom: margin.bottom || 0
	})), offsetH);
	var brushBottom = offset.bottom;
	if (brushItem) offset.bottom += brushItem.props.height || Brush.defaultProps.height;
	if (legendItem && prevLegendBBox) offset = appendOffsetOfLegend(offset, graphicalItems, props, prevLegendBBox);
	var offsetWidth = width - offset.left - offset.right;
	var offsetHeight = height - offset.top - offset.bottom;
	return _objectSpread(_objectSpread({ brushBottom }, offset), {}, {
		width: Math.max(offsetWidth, 0),
		height: Math.max(offsetHeight, 0)
	});
};
var getCartesianAxisSize = function getCartesianAxisSize$1(axisObj, axisName) {
	if (axisName === "xAxis") return axisObj[axisName].width;
	if (axisName === "yAxis") return axisObj[axisName].height;
};
var generateCategoricalChart = function generateCategoricalChart$1(_ref6) {
	var chartName = _ref6.chartName, GraphicalChild = _ref6.GraphicalChild, _ref6$defaultTooltipE = _ref6.defaultTooltipEventType, defaultTooltipEventType = _ref6$defaultTooltipE === void 0 ? "axis" : _ref6$defaultTooltipE, _ref6$validateTooltip = _ref6.validateTooltipEventTypes, validateTooltipEventTypes = _ref6$validateTooltip === void 0 ? ["axis"] : _ref6$validateTooltip, axisComponents = _ref6.axisComponents, legendContent = _ref6.legendContent, formatAxisMap$1 = _ref6.formatAxisMap, defaultProps$4 = _ref6.defaultProps;
	var getFormatItems = function getFormatItems$1(props, currentState) {
		var graphicalItems = currentState.graphicalItems, stackGroups = currentState.stackGroups, offset = currentState.offset, updateId = currentState.updateId, dataStartIndex = currentState.dataStartIndex, dataEndIndex = currentState.dataEndIndex;
		var barSize = props.barSize, layout = props.layout, barGap = props.barGap, barCategoryGap = props.barCategoryGap, globalMaxBarSize = props.maxBarSize;
		var _getAxisNameByLayout = getAxisNameByLayout(layout), numericAxisName = _getAxisNameByLayout.numericAxisName, cateAxisName = _getAxisNameByLayout.cateAxisName;
		var hasBar = hasGraphicalBarItem(graphicalItems);
		var formattedItems = [];
		graphicalItems.forEach(function(item, index) {
			var displayedData = getDisplayedData(props.data, {
				graphicalItems: [item],
				dataStartIndex,
				dataEndIndex
			});
			var itemProps = item.type.defaultProps !== void 0 ? _objectSpread(_objectSpread({}, item.type.defaultProps), item.props) : item.props;
			var dataKey = itemProps.dataKey, childMaxBarSize = itemProps.maxBarSize;
			var numericAxisId = itemProps["".concat(numericAxisName, "Id")];
			var cateAxisId = itemProps["".concat(cateAxisName, "Id")];
			var axisObj = axisComponents.reduce(function(result, entry) {
				var _item$type$displayNam, _item$type;
				var axisMap = currentState["".concat(entry.axisType, "Map")];
				var id = itemProps["".concat(entry.axisType, "Id")];
				!(axisMap && axisMap[id] || entry.axisType === "zAxis") && invariant(false, "Specifying a(n) ".concat(entry.axisType, "Id requires a corresponding ").concat(entry.axisType, "Id on the targeted graphical component ").concat((_item$type$displayNam = item === null || item === void 0 || (_item$type = item.type) === null || _item$type === void 0 ? void 0 : _item$type.displayName) !== null && _item$type$displayNam !== void 0 ? _item$type$displayNam : ""));
				var axis = axisMap[id];
				return _objectSpread(_objectSpread({}, result), {}, _defineProperty(_defineProperty({}, entry.axisType, axis), "".concat(entry.axisType, "Ticks"), getTicksOfAxis(axis)));
			}, {});
			var cateAxis = axisObj[cateAxisName];
			var cateTicks = axisObj["".concat(cateAxisName, "Ticks")];
			var stackedData = stackGroups && stackGroups[numericAxisId] && stackGroups[numericAxisId].hasStack && getStackedDataOfItem(item, stackGroups[numericAxisId].stackGroups);
			var itemIsBar = getDisplayName(item.type).indexOf("Bar") >= 0;
			var bandSize = getBandSizeOfAxis(cateAxis, cateTicks);
			var barPosition = [];
			var sizeList = hasBar && getBarSizeList({
				barSize,
				stackGroups,
				totalSize: getCartesianAxisSize(axisObj, cateAxisName)
			});
			if (itemIsBar) {
				var _ref7, _getBandSizeOfAxis;
				var maxBarSize = (0, import_isNil.default)(childMaxBarSize) ? globalMaxBarSize : childMaxBarSize;
				var barBandSize = (_ref7 = (_getBandSizeOfAxis = getBandSizeOfAxis(cateAxis, cateTicks, true)) !== null && _getBandSizeOfAxis !== void 0 ? _getBandSizeOfAxis : maxBarSize) !== null && _ref7 !== void 0 ? _ref7 : 0;
				barPosition = getBarPosition({
					barGap,
					barCategoryGap,
					bandSize: barBandSize !== bandSize ? barBandSize : bandSize,
					sizeList: sizeList[cateAxisId],
					maxBarSize
				});
				if (barBandSize !== bandSize) barPosition = barPosition.map(function(pos) {
					return _objectSpread(_objectSpread({}, pos), {}, { position: _objectSpread(_objectSpread({}, pos.position), {}, { offset: pos.position.offset - barBandSize / 2 }) });
				});
			}
			var composedFn = item && item.type && item.type.getComposedData;
			if (composedFn) formattedItems.push({
				props: _objectSpread(_objectSpread({}, composedFn(_objectSpread(_objectSpread({}, axisObj), {}, {
					displayedData,
					props,
					dataKey,
					item,
					bandSize,
					barPosition,
					offset,
					stackedData,
					layout,
					dataStartIndex,
					dataEndIndex
				}))), {}, _defineProperty(_defineProperty(_defineProperty({ key: item.key || "item-".concat(index) }, numericAxisName, axisObj[numericAxisName]), cateAxisName, axisObj[cateAxisName]), "animationId", updateId)),
				childIndex: parseChildIndex(item, props.children),
				item
			});
		});
		return formattedItems;
	};
	var updateStateOfAxisMapsOffsetAndStackGroups = function updateStateOfAxisMapsOffsetAndStackGroups$1(_ref8, prevState) {
		var props = _ref8.props, dataStartIndex = _ref8.dataStartIndex, dataEndIndex = _ref8.dataEndIndex, updateId = _ref8.updateId;
		if (!validateWidthHeight({ props })) return null;
		var children = props.children, layout = props.layout, stackOffset = props.stackOffset, data = props.data, reverseStackOrder = props.reverseStackOrder;
		var _getAxisNameByLayout2 = getAxisNameByLayout(layout), numericAxisName = _getAxisNameByLayout2.numericAxisName, cateAxisName = _getAxisNameByLayout2.cateAxisName;
		var graphicalItems = findAllByType(children, GraphicalChild);
		var stackGroups = getStackGroupsByAxisId(data, graphicalItems, "".concat(numericAxisName, "Id"), "".concat(cateAxisName, "Id"), stackOffset, reverseStackOrder);
		var axisObj = axisComponents.reduce(function(result, entry) {
			var name = "".concat(entry.axisType, "Map");
			return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, name, getAxisMap(props, _objectSpread(_objectSpread({}, entry), {}, {
				graphicalItems,
				stackGroups: entry.axisType === numericAxisName && stackGroups,
				dataStartIndex,
				dataEndIndex
			}))));
		}, {});
		var offset = calculateOffset(_objectSpread(_objectSpread({}, axisObj), {}, {
			props,
			graphicalItems
		}), prevState === null || prevState === void 0 ? void 0 : prevState.legendBBox);
		Object.keys(axisObj).forEach(function(key) {
			axisObj[key] = formatAxisMap$1(props, axisObj[key], offset, key.replace("Map", ""), chartName);
		});
		var cateAxisMap = axisObj["".concat(cateAxisName, "Map")];
		var ticksObj = tooltipTicksGenerator(cateAxisMap);
		return _objectSpread(_objectSpread({
			formattedGraphicalItems: getFormatItems(props, _objectSpread(_objectSpread({}, axisObj), {}, {
				dataStartIndex,
				dataEndIndex,
				updateId,
				graphicalItems,
				stackGroups,
				offset
			})),
			graphicalItems,
			offset,
			stackGroups
		}, ticksObj), axisObj);
	};
	var CategoricalChartWrapper = /* @__PURE__ */ function(_Component) {
		function CategoricalChartWrapper$1(_props) {
			var _props$id, _props$throttleDelay;
			var _this;
			_classCallCheck(this, CategoricalChartWrapper$1);
			_this = _callSuper(this, CategoricalChartWrapper$1, [_props]);
			_defineProperty(_this, "eventEmitterSymbol", Symbol("rechartsEventEmitter"));
			_defineProperty(_this, "accessibilityManager", new AccessibilityManager());
			_defineProperty(_this, "handleLegendBBoxUpdate", function(box) {
				if (box) {
					var _this$state = _this.state, dataStartIndex = _this$state.dataStartIndex, dataEndIndex = _this$state.dataEndIndex, updateId = _this$state.updateId;
					_this.setState(_objectSpread({ legendBBox: box }, updateStateOfAxisMapsOffsetAndStackGroups({
						props: _this.props,
						dataStartIndex,
						dataEndIndex,
						updateId
					}, _objectSpread(_objectSpread({}, _this.state), {}, { legendBBox: box }))));
				}
			});
			_defineProperty(_this, "handleReceiveSyncEvent", function(cId, data, emitter) {
				if (_this.props.syncId === cId) {
					if (emitter === _this.eventEmitterSymbol && typeof _this.props.syncMethod !== "function") return;
					_this.applySyncEvent(data);
				}
			});
			_defineProperty(_this, "handleBrushChange", function(_ref9) {
				var startIndex = _ref9.startIndex, endIndex = _ref9.endIndex;
				if (startIndex !== _this.state.dataStartIndex || endIndex !== _this.state.dataEndIndex) {
					var updateId = _this.state.updateId;
					_this.setState(function() {
						return _objectSpread({
							dataStartIndex: startIndex,
							dataEndIndex: endIndex
						}, updateStateOfAxisMapsOffsetAndStackGroups({
							props: _this.props,
							dataStartIndex: startIndex,
							dataEndIndex: endIndex,
							updateId
						}, _this.state));
					});
					_this.triggerSyncEvent({
						dataStartIndex: startIndex,
						dataEndIndex: endIndex
					});
				}
			});
			_defineProperty(_this, "handleMouseEnter", function(e) {
				var mouse = _this.getMouseInfo(e);
				if (mouse) {
					var _nextState = _objectSpread(_objectSpread({}, mouse), {}, { isTooltipActive: true });
					_this.setState(_nextState);
					_this.triggerSyncEvent(_nextState);
					var onMouseEnter = _this.props.onMouseEnter;
					if ((0, import_isFunction.default)(onMouseEnter)) onMouseEnter(_nextState, e);
				}
			});
			_defineProperty(_this, "triggeredAfterMouseMove", function(e) {
				var mouse = _this.getMouseInfo(e);
				var nextState = mouse ? _objectSpread(_objectSpread({}, mouse), {}, { isTooltipActive: true }) : { isTooltipActive: false };
				_this.setState(nextState);
				_this.triggerSyncEvent(nextState);
				var onMouseMove = _this.props.onMouseMove;
				if ((0, import_isFunction.default)(onMouseMove)) onMouseMove(nextState, e);
			});
			_defineProperty(_this, "handleItemMouseEnter", function(el) {
				_this.setState(function() {
					return {
						isTooltipActive: true,
						activeItem: el,
						activePayload: el.tooltipPayload,
						activeCoordinate: el.tooltipPosition || {
							x: el.cx,
							y: el.cy
						}
					};
				});
			});
			_defineProperty(_this, "handleItemMouseLeave", function() {
				_this.setState(function() {
					return { isTooltipActive: false };
				});
			});
			_defineProperty(_this, "handleMouseMove", function(e) {
				e.persist();
				_this.throttleTriggeredAfterMouseMove(e);
			});
			_defineProperty(_this, "handleMouseLeave", function(e) {
				_this.throttleTriggeredAfterMouseMove.cancel();
				var nextState = { isTooltipActive: false };
				_this.setState(nextState);
				_this.triggerSyncEvent(nextState);
				var onMouseLeave = _this.props.onMouseLeave;
				if ((0, import_isFunction.default)(onMouseLeave)) onMouseLeave(nextState, e);
			});
			_defineProperty(_this, "handleOuterEvent", function(e) {
				var eventName = getReactEventByType(e);
				var event = (0, import_get.default)(_this.props, "".concat(eventName));
				if (eventName && (0, import_isFunction.default)(event)) {
					var _mouse;
					var mouse;
					if (/.*touch.*/i.test(eventName)) mouse = _this.getMouseInfo(e.changedTouches[0]);
					else mouse = _this.getMouseInfo(e);
					event((_mouse = mouse) !== null && _mouse !== void 0 ? _mouse : {}, e);
				}
			});
			_defineProperty(_this, "handleClick", function(e) {
				var mouse = _this.getMouseInfo(e);
				if (mouse) {
					var _nextState2 = _objectSpread(_objectSpread({}, mouse), {}, { isTooltipActive: true });
					_this.setState(_nextState2);
					_this.triggerSyncEvent(_nextState2);
					var onClick = _this.props.onClick;
					if ((0, import_isFunction.default)(onClick)) onClick(_nextState2, e);
				}
			});
			_defineProperty(_this, "handleMouseDown", function(e) {
				var onMouseDown = _this.props.onMouseDown;
				if ((0, import_isFunction.default)(onMouseDown)) onMouseDown(_this.getMouseInfo(e), e);
			});
			_defineProperty(_this, "handleMouseUp", function(e) {
				var onMouseUp = _this.props.onMouseUp;
				if ((0, import_isFunction.default)(onMouseUp)) onMouseUp(_this.getMouseInfo(e), e);
			});
			_defineProperty(_this, "handleTouchMove", function(e) {
				if (e.changedTouches != null && e.changedTouches.length > 0) _this.throttleTriggeredAfterMouseMove(e.changedTouches[0]);
			});
			_defineProperty(_this, "handleTouchStart", function(e) {
				if (e.changedTouches != null && e.changedTouches.length > 0) _this.handleMouseDown(e.changedTouches[0]);
			});
			_defineProperty(_this, "handleTouchEnd", function(e) {
				if (e.changedTouches != null && e.changedTouches.length > 0) _this.handleMouseUp(e.changedTouches[0]);
			});
			_defineProperty(_this, "handleDoubleClick", function(e) {
				var onDoubleClick = _this.props.onDoubleClick;
				if ((0, import_isFunction.default)(onDoubleClick)) onDoubleClick(_this.getMouseInfo(e), e);
			});
			_defineProperty(_this, "handleContextMenu", function(e) {
				var onContextMenu = _this.props.onContextMenu;
				if ((0, import_isFunction.default)(onContextMenu)) onContextMenu(_this.getMouseInfo(e), e);
			});
			_defineProperty(_this, "triggerSyncEvent", function(data) {
				if (_this.props.syncId !== void 0) eventCenter.emit(SYNC_EVENT, _this.props.syncId, data, _this.eventEmitterSymbol);
			});
			_defineProperty(_this, "applySyncEvent", function(data) {
				var _this$props = _this.props, layout = _this$props.layout, syncMethod = _this$props.syncMethod;
				var updateId = _this.state.updateId;
				var dataStartIndex = data.dataStartIndex, dataEndIndex = data.dataEndIndex;
				if (data.dataStartIndex !== void 0 || data.dataEndIndex !== void 0) _this.setState(_objectSpread({
					dataStartIndex,
					dataEndIndex
				}, updateStateOfAxisMapsOffsetAndStackGroups({
					props: _this.props,
					dataStartIndex,
					dataEndIndex,
					updateId
				}, _this.state)));
				else if (data.activeTooltipIndex !== void 0) {
					var chartX = data.chartX, chartY = data.chartY;
					var activeTooltipIndex = data.activeTooltipIndex;
					var _this$state2 = _this.state, offset = _this$state2.offset, tooltipTicks = _this$state2.tooltipTicks;
					if (!offset) return;
					if (typeof syncMethod === "function") activeTooltipIndex = syncMethod(tooltipTicks, data);
					else if (syncMethod === "value") {
						activeTooltipIndex = -1;
						for (var i$2 = 0; i$2 < tooltipTicks.length; i$2++) if (tooltipTicks[i$2].value === data.activeLabel) {
							activeTooltipIndex = i$2;
							break;
						}
					}
					var viewBox = _objectSpread(_objectSpread({}, offset), {}, {
						x: offset.left,
						y: offset.top
					});
					var validateChartX = Math.min(chartX, viewBox.x + viewBox.width);
					var validateChartY = Math.min(chartY, viewBox.y + viewBox.height);
					var activeLabel = tooltipTicks[activeTooltipIndex] && tooltipTicks[activeTooltipIndex].value;
					var activePayload = getTooltipContent(_this.state, _this.props.data, activeTooltipIndex);
					var activeCoordinate = tooltipTicks[activeTooltipIndex] ? {
						x: layout === "horizontal" ? tooltipTicks[activeTooltipIndex].coordinate : validateChartX,
						y: layout === "horizontal" ? validateChartY : tooltipTicks[activeTooltipIndex].coordinate
					} : originCoordinate;
					_this.setState(_objectSpread(_objectSpread({}, data), {}, {
						activeLabel,
						activeCoordinate,
						activePayload,
						activeTooltipIndex
					}));
				} else _this.setState(data);
			});
			_defineProperty(_this, "renderCursor", function(element) {
				var _element$props$active;
				var _this$state3 = _this.state, isTooltipActive = _this$state3.isTooltipActive, activeCoordinate = _this$state3.activeCoordinate, activePayload = _this$state3.activePayload, offset = _this$state3.offset, activeTooltipIndex = _this$state3.activeTooltipIndex, tooltipAxisBandSize = _this$state3.tooltipAxisBandSize;
				var tooltipEventType = _this.getTooltipEventType();
				var isActive = (_element$props$active = element.props.active) !== null && _element$props$active !== void 0 ? _element$props$active : isTooltipActive;
				var layout = _this.props.layout;
				var key = element.key || "_recharts-cursor";
				return /* @__PURE__ */ import_react.createElement(Cursor, {
					key,
					activeCoordinate,
					activePayload,
					activeTooltipIndex,
					chartName,
					element,
					isActive,
					layout,
					offset,
					tooltipAxisBandSize,
					tooltipEventType
				});
			});
			_defineProperty(_this, "renderPolarAxis", function(element, displayName, index) {
				var axisType = (0, import_get.default)(element, "type.axisType");
				var axisMap = (0, import_get.default)(_this.state, "".concat(axisType, "Map"));
				var elementDefaultProps = element.type.defaultProps;
				var elementProps = elementDefaultProps !== void 0 ? _objectSpread(_objectSpread({}, elementDefaultProps), element.props) : element.props;
				var axisOption = axisMap && axisMap[elementProps["".concat(axisType, "Id")]];
				return /* @__PURE__ */ (0, import_react.cloneElement)(element, _objectSpread(_objectSpread({}, axisOption), {}, {
					className: clsx_default(axisType, axisOption.className),
					key: element.key || "".concat(displayName, "-").concat(index),
					ticks: getTicksOfAxis(axisOption, true)
				}));
			});
			_defineProperty(_this, "renderPolarGrid", function(element) {
				var _element$props = element.props, radialLines = _element$props.radialLines, polarAngles = _element$props.polarAngles, polarRadius = _element$props.polarRadius;
				var _this$state4 = _this.state, radiusAxisMap = _this$state4.radiusAxisMap, angleAxisMap = _this$state4.angleAxisMap;
				var radiusAxis = getAnyElementOfObject(radiusAxisMap);
				var angleAxis = getAnyElementOfObject(angleAxisMap);
				var cx = angleAxis.cx, cy = angleAxis.cy, innerRadius = angleAxis.innerRadius, outerRadius = angleAxis.outerRadius;
				return /* @__PURE__ */ (0, import_react.cloneElement)(element, {
					polarAngles: Array.isArray(polarAngles) ? polarAngles : getTicksOfAxis(angleAxis, true).map(function(entry) {
						return entry.coordinate;
					}),
					polarRadius: Array.isArray(polarRadius) ? polarRadius : getTicksOfAxis(radiusAxis, true).map(function(entry) {
						return entry.coordinate;
					}),
					cx,
					cy,
					innerRadius,
					outerRadius,
					key: element.key || "polar-grid",
					radialLines
				});
			});
			_defineProperty(_this, "renderLegend", function() {
				var formattedGraphicalItems = _this.state.formattedGraphicalItems;
				var _this$props2 = _this.props, children = _this$props2.children, width = _this$props2.width, height = _this$props2.height;
				var margin = _this.props.margin || {};
				var props = getLegendProps({
					children,
					formattedGraphicalItems,
					legendWidth: width - (margin.left || 0) - (margin.right || 0),
					legendContent
				});
				if (!props) return null;
				var item = props.item;
				return /* @__PURE__ */ (0, import_react.cloneElement)(item, _objectSpread(_objectSpread({}, _objectWithoutProperties(props, _excluded)), {}, {
					chartWidth: width,
					chartHeight: height,
					margin,
					onBBoxUpdate: _this.handleLegendBBoxUpdate
				}));
			});
			_defineProperty(_this, "renderTooltip", function() {
				var _tooltipItem$props$ac;
				var _this$props3 = _this.props, children = _this$props3.children, accessibilityLayer = _this$props3.accessibilityLayer;
				var tooltipItem = findChildByType(children, Tooltip);
				if (!tooltipItem) return null;
				var _this$state5 = _this.state, isTooltipActive = _this$state5.isTooltipActive, activeCoordinate = _this$state5.activeCoordinate, activePayload = _this$state5.activePayload, activeLabel = _this$state5.activeLabel, offset = _this$state5.offset;
				var isActive = (_tooltipItem$props$ac = tooltipItem.props.active) !== null && _tooltipItem$props$ac !== void 0 ? _tooltipItem$props$ac : isTooltipActive;
				return /* @__PURE__ */ (0, import_react.cloneElement)(tooltipItem, {
					viewBox: _objectSpread(_objectSpread({}, offset), {}, {
						x: offset.left,
						y: offset.top
					}),
					active: isActive,
					label: activeLabel,
					payload: isActive ? activePayload : [],
					coordinate: activeCoordinate,
					accessibilityLayer
				});
			});
			_defineProperty(_this, "renderBrush", function(element) {
				var _this$props4 = _this.props, margin = _this$props4.margin, data = _this$props4.data;
				var _this$state6 = _this.state, offset = _this$state6.offset, dataStartIndex = _this$state6.dataStartIndex, dataEndIndex = _this$state6.dataEndIndex, updateId = _this$state6.updateId;
				return /* @__PURE__ */ (0, import_react.cloneElement)(element, {
					key: element.key || "_recharts-brush",
					onChange: combineEventHandlers(_this.handleBrushChange, element.props.onChange),
					data,
					x: isNumber(element.props.x) ? element.props.x : offset.left,
					y: isNumber(element.props.y) ? element.props.y : offset.top + offset.height + offset.brushBottom - (margin.bottom || 0),
					width: isNumber(element.props.width) ? element.props.width : offset.width,
					startIndex: dataStartIndex,
					endIndex: dataEndIndex,
					updateId: "brush-".concat(updateId)
				});
			});
			_defineProperty(_this, "renderReferenceElement", function(element, displayName, index) {
				if (!element) return null;
				var clipPathId = _this.clipPathId;
				var _this$state7 = _this.state, xAxisMap = _this$state7.xAxisMap, yAxisMap = _this$state7.yAxisMap, offset = _this$state7.offset;
				var elementDefaultProps = element.type.defaultProps || {};
				var _element$props2 = element.props, _element$props2$xAxis = _element$props2.xAxisId, xAxisId = _element$props2$xAxis === void 0 ? elementDefaultProps.xAxisId : _element$props2$xAxis, _element$props2$yAxis = _element$props2.yAxisId, yAxisId = _element$props2$yAxis === void 0 ? elementDefaultProps.yAxisId : _element$props2$yAxis;
				return /* @__PURE__ */ (0, import_react.cloneElement)(element, {
					key: element.key || "".concat(displayName, "-").concat(index),
					xAxis: xAxisMap[xAxisId],
					yAxis: yAxisMap[yAxisId],
					viewBox: {
						x: offset.left,
						y: offset.top,
						width: offset.width,
						height: offset.height
					},
					clipPathId
				});
			});
			_defineProperty(_this, "renderActivePoints", function(_ref10) {
				var item = _ref10.item, activePoint = _ref10.activePoint, basePoint = _ref10.basePoint, childIndex = _ref10.childIndex, isRange = _ref10.isRange;
				var result = [];
				var key = item.props.key;
				var itemItemProps = item.item.type.defaultProps !== void 0 ? _objectSpread(_objectSpread({}, item.item.type.defaultProps), item.item.props) : item.item.props;
				var activeDot = itemItemProps.activeDot, dataKey = itemItemProps.dataKey;
				var dotProps = _objectSpread(_objectSpread({
					index: childIndex,
					dataKey,
					cx: activePoint.x,
					cy: activePoint.y,
					r: 4,
					fill: getMainColorOfGraphicItem(item.item),
					strokeWidth: 2,
					stroke: "#fff",
					payload: activePoint.payload,
					value: activePoint.value
				}, filterProps(activeDot, false)), adaptEventHandlers(activeDot));
				result.push(CategoricalChartWrapper$1.renderActiveDot(activeDot, dotProps, "".concat(key, "-activePoint-").concat(childIndex)));
				if (basePoint) result.push(CategoricalChartWrapper$1.renderActiveDot(activeDot, _objectSpread(_objectSpread({}, dotProps), {}, {
					cx: basePoint.x,
					cy: basePoint.y
				}), "".concat(key, "-basePoint-").concat(childIndex)));
				else if (isRange) result.push(null);
				return result;
			});
			_defineProperty(_this, "renderGraphicChild", function(element, displayName, index) {
				var item = _this.filterFormatItem(element, displayName, index);
				if (!item) return null;
				var tooltipEventType = _this.getTooltipEventType();
				var _this$state8 = _this.state, isTooltipActive = _this$state8.isTooltipActive, tooltipAxis = _this$state8.tooltipAxis, activeTooltipIndex = _this$state8.activeTooltipIndex, activeLabel = _this$state8.activeLabel;
				var children = _this.props.children;
				var tooltipItem = findChildByType(children, Tooltip);
				var _item$props = item.props, points = _item$props.points, isRange = _item$props.isRange, baseLine = _item$props.baseLine;
				var itemItemProps = item.item.type.defaultProps !== void 0 ? _objectSpread(_objectSpread({}, item.item.type.defaultProps), item.item.props) : item.item.props;
				var activeDot = itemItemProps.activeDot, hide = itemItemProps.hide, activeBar = itemItemProps.activeBar, activeShape = itemItemProps.activeShape;
				var hasActive = Boolean(!hide && isTooltipActive && tooltipItem && (activeDot || activeBar || activeShape));
				var itemEvents = {};
				if (tooltipEventType !== "axis" && tooltipItem && tooltipItem.props.trigger === "click") itemEvents = { onClick: combineEventHandlers(_this.handleItemMouseEnter, element.props.onClick) };
				else if (tooltipEventType !== "axis") itemEvents = {
					onMouseLeave: combineEventHandlers(_this.handleItemMouseLeave, element.props.onMouseLeave),
					onMouseEnter: combineEventHandlers(_this.handleItemMouseEnter, element.props.onMouseEnter)
				};
				var graphicalItem = /* @__PURE__ */ (0, import_react.cloneElement)(element, _objectSpread(_objectSpread({}, item.props), itemEvents));
				function findWithPayload(entry) {
					return typeof tooltipAxis.dataKey === "function" ? tooltipAxis.dataKey(entry.payload) : null;
				}
				if (hasActive) if (activeTooltipIndex >= 0) {
					var activePoint, basePoint;
					if (tooltipAxis.dataKey && !tooltipAxis.allowDuplicatedCategory) {
						var specifiedKey = typeof tooltipAxis.dataKey === "function" ? findWithPayload : "payload.".concat(tooltipAxis.dataKey.toString());
						activePoint = findEntryInArray(points, specifiedKey, activeLabel);
						basePoint = isRange && baseLine && findEntryInArray(baseLine, specifiedKey, activeLabel);
					} else {
						activePoint = points === null || points === void 0 ? void 0 : points[activeTooltipIndex];
						basePoint = isRange && baseLine && baseLine[activeTooltipIndex];
					}
					if (activeShape || activeBar) {
						var activeIndex = element.props.activeIndex !== void 0 ? element.props.activeIndex : activeTooltipIndex;
						return [
							/* @__PURE__ */ (0, import_react.cloneElement)(element, _objectSpread(_objectSpread(_objectSpread({}, item.props), itemEvents), {}, { activeIndex })),
							null,
							null
						];
					}
					if (!(0, import_isNil.default)(activePoint)) return [graphicalItem].concat(_toConsumableArray(_this.renderActivePoints({
						item,
						activePoint,
						basePoint,
						childIndex: activeTooltipIndex,
						isRange
					})));
				} else {
					var _this$getItemByXY;
					var _ref11$graphicalItem = ((_this$getItemByXY = _this.getItemByXY(_this.state.activeCoordinate)) !== null && _this$getItemByXY !== void 0 ? _this$getItemByXY : { graphicalItem }).graphicalItem, _ref11$graphicalItem$ = _ref11$graphicalItem.item, xyItem = _ref11$graphicalItem$ === void 0 ? element : _ref11$graphicalItem$, childIndex = _ref11$graphicalItem.childIndex;
					return [
						/* @__PURE__ */ (0, import_react.cloneElement)(xyItem, _objectSpread(_objectSpread(_objectSpread({}, item.props), itemEvents), {}, { activeIndex: childIndex })),
						null,
						null
					];
				}
				if (isRange) return [
					graphicalItem,
					null,
					null
				];
				return [graphicalItem, null];
			});
			_defineProperty(_this, "renderCustomized", function(element, displayName, index) {
				return /* @__PURE__ */ (0, import_react.cloneElement)(element, _objectSpread(_objectSpread({ key: "recharts-customized-".concat(index) }, _this.props), _this.state));
			});
			_defineProperty(_this, "renderMap", {
				CartesianGrid: {
					handler: renderAsIs,
					once: true
				},
				ReferenceArea: { handler: _this.renderReferenceElement },
				ReferenceLine: { handler: renderAsIs },
				ReferenceDot: { handler: _this.renderReferenceElement },
				XAxis: { handler: renderAsIs },
				YAxis: { handler: renderAsIs },
				Brush: {
					handler: _this.renderBrush,
					once: true
				},
				Bar: { handler: _this.renderGraphicChild },
				Line: { handler: _this.renderGraphicChild },
				Area: { handler: _this.renderGraphicChild },
				Radar: { handler: _this.renderGraphicChild },
				RadialBar: { handler: _this.renderGraphicChild },
				Scatter: { handler: _this.renderGraphicChild },
				Pie: { handler: _this.renderGraphicChild },
				Funnel: { handler: _this.renderGraphicChild },
				Tooltip: {
					handler: _this.renderCursor,
					once: true
				},
				PolarGrid: {
					handler: _this.renderPolarGrid,
					once: true
				},
				PolarAngleAxis: { handler: _this.renderPolarAxis },
				PolarRadiusAxis: { handler: _this.renderPolarAxis },
				Customized: { handler: _this.renderCustomized }
			});
			_this.clipPathId = "".concat((_props$id = _props.id) !== null && _props$id !== void 0 ? _props$id : uniqueId("recharts"), "-clip");
			_this.throttleTriggeredAfterMouseMove = (0, import_throttle.default)(_this.triggeredAfterMouseMove, (_props$throttleDelay = _props.throttleDelay) !== null && _props$throttleDelay !== void 0 ? _props$throttleDelay : 1e3 / 60);
			_this.state = {};
			return _this;
		}
		_inherits(CategoricalChartWrapper$1, _Component);
		return _createClass(CategoricalChartWrapper$1, [
			{
				key: "componentDidMount",
				value: function componentDidMount() {
					var _this$props$margin$le, _this$props$margin$to;
					this.addListener();
					this.accessibilityManager.setDetails({
						container: this.container,
						offset: {
							left: (_this$props$margin$le = this.props.margin.left) !== null && _this$props$margin$le !== void 0 ? _this$props$margin$le : 0,
							top: (_this$props$margin$to = this.props.margin.top) !== null && _this$props$margin$to !== void 0 ? _this$props$margin$to : 0
						},
						coordinateList: this.state.tooltipTicks,
						mouseHandlerCallback: this.triggeredAfterMouseMove,
						layout: this.props.layout
					});
					this.displayDefaultTooltip();
				}
			},
			{
				key: "displayDefaultTooltip",
				value: function displayDefaultTooltip() {
					var _this$props5 = this.props, children = _this$props5.children, data = _this$props5.data, height = _this$props5.height, layout = _this$props5.layout;
					var tooltipElem = findChildByType(children, Tooltip);
					if (!tooltipElem) return;
					var defaultIndex = tooltipElem.props.defaultIndex;
					if (typeof defaultIndex !== "number" || defaultIndex < 0 || defaultIndex > this.state.tooltipTicks.length - 1) return;
					var activeLabel = this.state.tooltipTicks[defaultIndex] && this.state.tooltipTicks[defaultIndex].value;
					var activePayload = getTooltipContent(this.state, data, defaultIndex, activeLabel);
					var independentAxisCoord = this.state.tooltipTicks[defaultIndex].coordinate;
					var dependentAxisCoord = (this.state.offset.top + height) / 2;
					var activeCoordinate = layout === "horizontal" ? {
						x: independentAxisCoord,
						y: dependentAxisCoord
					} : {
						y: independentAxisCoord,
						x: dependentAxisCoord
					};
					var scatterPlotElement = this.state.formattedGraphicalItems.find(function(_ref12) {
						return _ref12.item.type.name === "Scatter";
					});
					if (scatterPlotElement) {
						activeCoordinate = _objectSpread(_objectSpread({}, activeCoordinate), scatterPlotElement.props.points[defaultIndex].tooltipPosition);
						activePayload = scatterPlotElement.props.points[defaultIndex].tooltipPayload;
					}
					var nextState = {
						activeTooltipIndex: defaultIndex,
						isTooltipActive: true,
						activeLabel,
						activePayload,
						activeCoordinate
					};
					this.setState(nextState);
					this.renderCursor(tooltipElem);
					this.accessibilityManager.setIndex(defaultIndex);
				}
			},
			{
				key: "getSnapshotBeforeUpdate",
				value: function getSnapshotBeforeUpdate(prevProps, prevState) {
					if (!this.props.accessibilityLayer) return null;
					if (this.state.tooltipTicks !== prevState.tooltipTicks) this.accessibilityManager.setDetails({ coordinateList: this.state.tooltipTicks });
					if (this.props.layout !== prevProps.layout) this.accessibilityManager.setDetails({ layout: this.props.layout });
					if (this.props.margin !== prevProps.margin) {
						var _this$props$margin$le2, _this$props$margin$to2;
						this.accessibilityManager.setDetails({ offset: {
							left: (_this$props$margin$le2 = this.props.margin.left) !== null && _this$props$margin$le2 !== void 0 ? _this$props$margin$le2 : 0,
							top: (_this$props$margin$to2 = this.props.margin.top) !== null && _this$props$margin$to2 !== void 0 ? _this$props$margin$to2 : 0
						} });
					}
					return null;
				}
			},
			{
				key: "componentDidUpdate",
				value: function componentDidUpdate(prevProps) {
					if (!isChildrenEqual([findChildByType(prevProps.children, Tooltip)], [findChildByType(this.props.children, Tooltip)])) this.displayDefaultTooltip();
				}
			},
			{
				key: "componentWillUnmount",
				value: function componentWillUnmount() {
					this.removeListener();
					this.throttleTriggeredAfterMouseMove.cancel();
				}
			},
			{
				key: "getTooltipEventType",
				value: function getTooltipEventType() {
					var tooltipItem = findChildByType(this.props.children, Tooltip);
					if (tooltipItem && typeof tooltipItem.props.shared === "boolean") {
						var eventType = tooltipItem.props.shared ? "axis" : "item";
						return validateTooltipEventTypes.indexOf(eventType) >= 0 ? eventType : defaultTooltipEventType;
					}
					return defaultTooltipEventType;
				}
			},
			{
				key: "getMouseInfo",
				value: function getMouseInfo(event) {
					if (!this.container) return null;
					var element = this.container;
					var boundingRect = element.getBoundingClientRect();
					var containerOffset = getOffset(boundingRect);
					var e = {
						chartX: Math.round(event.pageX - containerOffset.left),
						chartY: Math.round(event.pageY - containerOffset.top)
					};
					var scale = boundingRect.width / element.offsetWidth || 1;
					var rangeObj = this.inRange(e.chartX, e.chartY, scale);
					if (!rangeObj) return null;
					var _this$state9 = this.state, xAxisMap = _this$state9.xAxisMap, yAxisMap = _this$state9.yAxisMap;
					var tooltipEventType = this.getTooltipEventType();
					var toolTipData = getTooltipData(this.state, this.props.data, this.props.layout, rangeObj);
					if (tooltipEventType !== "axis" && xAxisMap && yAxisMap) {
						var xScale = getAnyElementOfObject(xAxisMap).scale;
						var yScale = getAnyElementOfObject(yAxisMap).scale;
						var xValue = xScale && xScale.invert ? xScale.invert(e.chartX) : null;
						var yValue = yScale && yScale.invert ? yScale.invert(e.chartY) : null;
						return _objectSpread(_objectSpread({}, e), {}, {
							xValue,
							yValue
						}, toolTipData);
					}
					if (toolTipData) return _objectSpread(_objectSpread({}, e), toolTipData);
					return null;
				}
			},
			{
				key: "inRange",
				value: function inRange(x$1, y$1) {
					var scale = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
					var layout = this.props.layout;
					var scaledX = x$1 / scale, scaledY = y$1 / scale;
					if (layout === "horizontal" || layout === "vertical") {
						var offset = this.state.offset;
						return scaledX >= offset.left && scaledX <= offset.left + offset.width && scaledY >= offset.top && scaledY <= offset.top + offset.height ? {
							x: scaledX,
							y: scaledY
						} : null;
					}
					var _this$state10 = this.state, angleAxisMap = _this$state10.angleAxisMap, radiusAxisMap = _this$state10.radiusAxisMap;
					if (angleAxisMap && radiusAxisMap) {
						var angleAxis = getAnyElementOfObject(angleAxisMap);
						return inRangeOfSector({
							x: scaledX,
							y: scaledY
						}, angleAxis);
					}
					return null;
				}
			},
			{
				key: "parseEventsOfWrapper",
				value: function parseEventsOfWrapper() {
					var children = this.props.children;
					var tooltipEventType = this.getTooltipEventType();
					var tooltipItem = findChildByType(children, Tooltip);
					var tooltipEvents = {};
					if (tooltipItem && tooltipEventType === "axis") if (tooltipItem.props.trigger === "click") tooltipEvents = { onClick: this.handleClick };
					else tooltipEvents = {
						onMouseEnter: this.handleMouseEnter,
						onDoubleClick: this.handleDoubleClick,
						onMouseMove: this.handleMouseMove,
						onMouseLeave: this.handleMouseLeave,
						onTouchMove: this.handleTouchMove,
						onTouchStart: this.handleTouchStart,
						onTouchEnd: this.handleTouchEnd,
						onContextMenu: this.handleContextMenu
					};
					return _objectSpread(_objectSpread({}, adaptEventHandlers(this.props, this.handleOuterEvent)), tooltipEvents);
				}
			},
			{
				key: "addListener",
				value: function addListener$1() {
					eventCenter.on(SYNC_EVENT, this.handleReceiveSyncEvent);
				}
			},
			{
				key: "removeListener",
				value: function removeListener() {
					eventCenter.removeListener(SYNC_EVENT, this.handleReceiveSyncEvent);
				}
			},
			{
				key: "filterFormatItem",
				value: function filterFormatItem(item, displayName, childIndex) {
					var formattedGraphicalItems = this.state.formattedGraphicalItems;
					for (var i$2 = 0, len = formattedGraphicalItems.length; i$2 < len; i$2++) {
						var entry = formattedGraphicalItems[i$2];
						if (entry.item === item || entry.props.key === item.key || displayName === getDisplayName(entry.item.type) && childIndex === entry.childIndex) return entry;
					}
					return null;
				}
			},
			{
				key: "renderClipPath",
				value: function renderClipPath() {
					var clipPathId = this.clipPathId;
					var _this$state$offset = this.state.offset, left = _this$state$offset.left, top = _this$state$offset.top, height = _this$state$offset.height, width = _this$state$offset.width;
					return /* @__PURE__ */ import_react.createElement("defs", null, /* @__PURE__ */ import_react.createElement("clipPath", { id: clipPathId }, /* @__PURE__ */ import_react.createElement("rect", {
						x: left,
						y: top,
						height,
						width
					})));
				}
			},
			{
				key: "getXScales",
				value: function getXScales() {
					var xAxisMap = this.state.xAxisMap;
					return xAxisMap ? Object.entries(xAxisMap).reduce(function(res, _ref13) {
						var _ref14 = _slicedToArray(_ref13, 2), axisId = _ref14[0], axisProps = _ref14[1];
						return _objectSpread(_objectSpread({}, res), {}, _defineProperty({}, axisId, axisProps.scale));
					}, {}) : null;
				}
			},
			{
				key: "getYScales",
				value: function getYScales() {
					var yAxisMap = this.state.yAxisMap;
					return yAxisMap ? Object.entries(yAxisMap).reduce(function(res, _ref15) {
						var _ref16 = _slicedToArray(_ref15, 2), axisId = _ref16[0], axisProps = _ref16[1];
						return _objectSpread(_objectSpread({}, res), {}, _defineProperty({}, axisId, axisProps.scale));
					}, {}) : null;
				}
			},
			{
				key: "getXScaleByAxisId",
				value: function getXScaleByAxisId(axisId) {
					var _this$state$xAxisMap;
					return (_this$state$xAxisMap = this.state.xAxisMap) === null || _this$state$xAxisMap === void 0 || (_this$state$xAxisMap = _this$state$xAxisMap[axisId]) === null || _this$state$xAxisMap === void 0 ? void 0 : _this$state$xAxisMap.scale;
				}
			},
			{
				key: "getYScaleByAxisId",
				value: function getYScaleByAxisId(axisId) {
					var _this$state$yAxisMap;
					return (_this$state$yAxisMap = this.state.yAxisMap) === null || _this$state$yAxisMap === void 0 || (_this$state$yAxisMap = _this$state$yAxisMap[axisId]) === null || _this$state$yAxisMap === void 0 ? void 0 : _this$state$yAxisMap.scale;
				}
			},
			{
				key: "getItemByXY",
				value: function getItemByXY(chartXY) {
					var _this$state11 = this.state, formattedGraphicalItems = _this$state11.formattedGraphicalItems, activeItem = _this$state11.activeItem;
					if (formattedGraphicalItems && formattedGraphicalItems.length) for (var i$2 = 0, len = formattedGraphicalItems.length; i$2 < len; i$2++) {
						var graphicalItem = formattedGraphicalItems[i$2];
						var props = graphicalItem.props, item = graphicalItem.item;
						var itemProps = item.type.defaultProps !== void 0 ? _objectSpread(_objectSpread({}, item.type.defaultProps), item.props) : item.props;
						var itemDisplayName = getDisplayName(item.type);
						if (itemDisplayName === "Bar") {
							var activeBarItem = (props.data || []).find(function(entry) {
								return isInRectangle(chartXY, entry);
							});
							if (activeBarItem) return {
								graphicalItem,
								payload: activeBarItem
							};
						} else if (itemDisplayName === "RadialBar") {
							var _activeBarItem = (props.data || []).find(function(entry) {
								return inRangeOfSector(chartXY, entry);
							});
							if (_activeBarItem) return {
								graphicalItem,
								payload: _activeBarItem
							};
						} else if (isFunnel(graphicalItem, activeItem) || isPie(graphicalItem, activeItem) || isScatter(graphicalItem, activeItem)) {
							var activeIndex = getActiveShapeIndexForTooltip({
								graphicalItem,
								activeTooltipItem: activeItem,
								itemData: itemProps.data
							});
							var childIndex = itemProps.activeIndex === void 0 ? activeIndex : itemProps.activeIndex;
							return {
								graphicalItem: _objectSpread(_objectSpread({}, graphicalItem), {}, { childIndex }),
								payload: isScatter(graphicalItem, activeItem) ? itemProps.data[activeIndex] : graphicalItem.props.data[activeIndex]
							};
						}
					}
					return null;
				}
			},
			{
				key: "render",
				value: function render() {
					var _this3 = this;
					if (!validateWidthHeight(this)) return null;
					var _this$props6 = this.props, children = _this$props6.children, className = _this$props6.className, width = _this$props6.width, height = _this$props6.height, style = _this$props6.style, compact$1 = _this$props6.compact, title = _this$props6.title, desc = _this$props6.desc;
					var attrs = filterProps(_objectWithoutProperties(_this$props6, _excluded2), false);
					if (compact$1) return /* @__PURE__ */ import_react.createElement(ChartLayoutContextProvider, {
						state: this.state,
						width: this.props.width,
						height: this.props.height,
						clipPathId: this.clipPathId
					}, /* @__PURE__ */ import_react.createElement(Surface, _extends({}, attrs, {
						width,
						height,
						title,
						desc
					}), this.renderClipPath(), renderByOrder(children, this.renderMap)));
					if (this.props.accessibilityLayer) {
						var _this$props$tabIndex, _this$props$role;
						attrs.tabIndex = (_this$props$tabIndex = this.props.tabIndex) !== null && _this$props$tabIndex !== void 0 ? _this$props$tabIndex : 0;
						attrs.role = (_this$props$role = this.props.role) !== null && _this$props$role !== void 0 ? _this$props$role : "application";
						attrs.onKeyDown = function(e) {
							_this3.accessibilityManager.keyboardEvent(e);
						};
						attrs.onFocus = function() {
							_this3.accessibilityManager.focus();
						};
					}
					var events = this.parseEventsOfWrapper();
					return /* @__PURE__ */ import_react.createElement(ChartLayoutContextProvider, {
						state: this.state,
						width: this.props.width,
						height: this.props.height,
						clipPathId: this.clipPathId
					}, /* @__PURE__ */ import_react.createElement("div", _extends({
						className: clsx_default("recharts-wrapper", className),
						style: _objectSpread({
							position: "relative",
							cursor: "default",
							width,
							height
						}, style)
					}, events, { ref: function ref(node) {
						_this3.container = node;
					} }), /* @__PURE__ */ import_react.createElement(Surface, _extends({}, attrs, {
						width,
						height,
						title,
						desc,
						style: FULL_WIDTH_AND_HEIGHT
					}), this.renderClipPath(), renderByOrder(children, this.renderMap)), this.renderLegend(), this.renderTooltip()));
				}
			}
		]);
	}(import_react.Component);
	_defineProperty(CategoricalChartWrapper, "displayName", chartName);
	_defineProperty(CategoricalChartWrapper, "defaultProps", _objectSpread({
		layout: "horizontal",
		stackOffset: "none",
		barCategoryGap: "10%",
		barGap: 4,
		margin: {
			top: 5,
			right: 5,
			bottom: 5,
			left: 5
		},
		reverseStackOrder: false,
		syncMethod: "index"
	}, defaultProps$4));
	_defineProperty(CategoricalChartWrapper, "getDerivedStateFromProps", function(nextProps, prevState) {
		var dataKey = nextProps.dataKey, data = nextProps.data, children = nextProps.children, width = nextProps.width, height = nextProps.height, layout = nextProps.layout, stackOffset = nextProps.stackOffset, margin = nextProps.margin;
		var dataStartIndex = prevState.dataStartIndex, dataEndIndex = prevState.dataEndIndex;
		if (prevState.updateId === void 0) {
			var defaultState = createDefaultState(nextProps);
			return _objectSpread(_objectSpread(_objectSpread({}, defaultState), {}, { updateId: 0 }, updateStateOfAxisMapsOffsetAndStackGroups(_objectSpread(_objectSpread({ props: nextProps }, defaultState), {}, { updateId: 0 }), prevState)), {}, {
				prevDataKey: dataKey,
				prevData: data,
				prevWidth: width,
				prevHeight: height,
				prevLayout: layout,
				prevStackOffset: stackOffset,
				prevMargin: margin,
				prevChildren: children
			});
		}
		if (dataKey !== prevState.prevDataKey || data !== prevState.prevData || width !== prevState.prevWidth || height !== prevState.prevHeight || layout !== prevState.prevLayout || stackOffset !== prevState.prevStackOffset || !shallowEqual(margin, prevState.prevMargin)) {
			var _defaultState = createDefaultState(nextProps);
			var keepFromPrevState = {
				chartX: prevState.chartX,
				chartY: prevState.chartY,
				isTooltipActive: prevState.isTooltipActive
			};
			var updatesToState = _objectSpread(_objectSpread({}, getTooltipData(prevState, data, layout)), {}, { updateId: prevState.updateId + 1 });
			var newState = _objectSpread(_objectSpread(_objectSpread({}, _defaultState), keepFromPrevState), updatesToState);
			return _objectSpread(_objectSpread(_objectSpread({}, newState), updateStateOfAxisMapsOffsetAndStackGroups(_objectSpread({ props: nextProps }, newState), prevState)), {}, {
				prevDataKey: dataKey,
				prevData: data,
				prevWidth: width,
				prevHeight: height,
				prevLayout: layout,
				prevStackOffset: stackOffset,
				prevMargin: margin,
				prevChildren: children
			});
		}
		if (!isChildrenEqual(children, prevState.prevChildren)) {
			var _brush$props$startInd, _brush$props, _brush$props$endIndex, _brush$props2;
			var brush = findChildByType(children, Brush);
			var startIndex = brush ? (_brush$props$startInd = (_brush$props = brush.props) === null || _brush$props === void 0 ? void 0 : _brush$props.startIndex) !== null && _brush$props$startInd !== void 0 ? _brush$props$startInd : dataStartIndex : dataStartIndex;
			var endIndex = brush ? (_brush$props$endIndex = (_brush$props2 = brush.props) === null || _brush$props2 === void 0 ? void 0 : _brush$props2.endIndex) !== null && _brush$props$endIndex !== void 0 ? _brush$props$endIndex : dataEndIndex : dataEndIndex;
			var hasDifferentStartOrEndIndex = startIndex !== dataStartIndex || endIndex !== dataEndIndex;
			var newUpdateId = !(0, import_isNil.default)(data) && !hasDifferentStartOrEndIndex ? prevState.updateId : prevState.updateId + 1;
			return _objectSpread(_objectSpread({ updateId: newUpdateId }, updateStateOfAxisMapsOffsetAndStackGroups(_objectSpread(_objectSpread({ props: nextProps }, prevState), {}, {
				updateId: newUpdateId,
				dataStartIndex: startIndex,
				dataEndIndex: endIndex
			}), prevState)), {}, {
				prevChildren: children,
				dataStartIndex: startIndex,
				dataEndIndex: endIndex
			});
		}
		return null;
	});
	_defineProperty(CategoricalChartWrapper, "renderActiveDot", function(option, props, key) {
		var dot;
		if (/* @__PURE__ */ (0, import_react.isValidElement)(option)) dot = /* @__PURE__ */ (0, import_react.cloneElement)(option, props);
		else if ((0, import_isFunction.default)(option)) dot = option(props);
		else dot = /* @__PURE__ */ import_react.createElement(Dot, props);
		return /* @__PURE__ */ import_react.createElement(Layer, {
			className: "recharts-active-dot",
			key
		}, dot);
	});
	var CategoricalChart = /* @__PURE__ */ (0, import_react.forwardRef)(function CategoricalChart$1(props, ref) {
		return /* @__PURE__ */ import_react.createElement(CategoricalChartWrapper, _extends({}, props, { ref }));
	});
	CategoricalChart.displayName = CategoricalChartWrapper.displayName;
	return CategoricalChart;
};
var LineChart = generateCategoricalChart({
	chartName: "LineChart",
	GraphicalChild: Line,
	axisComponents: [{
		axisType: "xAxis",
		AxisComp: XAxis
	}, {
		axisType: "yAxis",
		AxisComp: YAxis
	}],
	formatAxisMap
});
var BarChart = generateCategoricalChart({
	chartName: "BarChart",
	GraphicalChild: Bar,
	defaultTooltipEventType: "axis",
	validateTooltipEventTypes: ["axis", "item"],
	axisComponents: [{
		axisType: "xAxis",
		AxisComp: XAxis
	}, {
		axisType: "yAxis",
		AxisComp: YAxis
	}],
	formatAxisMap
});
var AreaChart = generateCategoricalChart({
	chartName: "AreaChart",
	GraphicalChild: Area,
	axisComponents: [{
		axisType: "xAxis",
		AxisComp: XAxis
	}, {
		axisType: "yAxis",
		AxisComp: YAxis
	}],
	formatAxisMap
});
var THEMES = {
	light: "",
	dark: ".dark"
};
var ChartContext = import_react.createContext(null);
function useChart() {
	const context = import_react.useContext(ChartContext);
	if (!context) throw new Error("useChart must be used within a <ChartContainer />");
	return context;
}
var ChartContainer = import_react.forwardRef(({ id, className, children, config: config$1, ...props }, ref) => {
	const uniqueId$1 = import_react.useId();
	const chartId = `chart-${id || uniqueId$1.replace(/:/g, "")}`;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ChartContext.Provider, {
		value: { config: config$1 },
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
			"data-chart": chartId,
			ref,
			className: cn("flex w-full h-full aspect-video justify-center text-xs [&_.recharts-cartesian-axis-tick_text]:fill-muted-foreground [&_.recharts-cartesian-grid_line[stroke='#ccc']]:stroke-border/50 [&_.recharts-curve.recharts-tooltip-cursor]:stroke-border [&_.recharts-dot[stroke='#fff']]:stroke-transparent [&_.recharts-layer]:outline-none [&_.recharts-polar-grid_[stroke='#ccc']]:stroke-border [&_.recharts-radial-bar-background-sector]:fill-muted [&_.recharts-rectangle.recharts-tooltip-cursor]:fill-muted [&_.recharts-reference-line_[stroke='#ccc']]:stroke-border [&_.recharts-sector[stroke='#fff']]:stroke-transparent [&_.recharts-sector]:outline-none [&_.recharts-surface]:outline-none", className),
			...props,
			children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(ChartStyle, {
				id: chartId,
				config: config$1
			}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ResponsiveContainer, { children })]
		})
	});
});
ChartContainer.displayName = "Chart";
var ChartStyle = ({ id, config: config$1 }) => {
	const colorConfig = Object.entries(config$1).filter(([, itemConfig]) => itemConfig.theme || itemConfig.color);
	if (!colorConfig.length) return null;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("style", { dangerouslySetInnerHTML: { __html: Object.entries(THEMES).map(([theme, prefix$2]) => `
${prefix$2} [data-chart="${id}"] {
${colorConfig.map(([key, itemConfig]) => {
		const color$1 = itemConfig.theme?.[theme] || itemConfig.color;
		return color$1 ? `  --color-${key}: ${color$1};` : null;
	}).filter(Boolean).join("\n")}
}
`).join("\n") } });
};
var ChartTooltipContent = import_react.forwardRef(({ active, payload, className, indicator = "dot", hideLabel = false, hideIndicator = false, label, labelFormatter, labelClassName, formatter, color: color$1, nameKey, labelKey }, ref) => {
	const { config: config$1 } = useChart();
	const tooltipLabel = import_react.useMemo(() => {
		if (hideLabel || !payload?.length) return null;
		const [item] = payload;
		const itemConfig = getPayloadConfigFromPayload(config$1, item, `${labelKey || item?.dataKey || item?.name || "value"}`);
		const value = !labelKey && typeof label === "string" ? config$1[label]?.label || label : itemConfig?.label;
		if (labelFormatter) return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
			className: cn("font-medium", labelClassName),
			children: labelFormatter(value, payload)
		});
		if (!value) return null;
		return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
			className: cn("font-medium", labelClassName),
			children: value
		});
	}, [
		label,
		labelFormatter,
		payload,
		hideLabel,
		labelClassName,
		config$1,
		labelKey
	]);
	if (!active || !payload?.length) return null;
	const nestLabel = payload.length === 1 && indicator !== "dot";
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
		ref,
		className: cn("grid min-w-[8rem] items-start gap-1.5 rounded-lg border border-border/50 bg-background px-2.5 py-1.5 text-xs shadow-xl", className),
		children: [!nestLabel ? tooltipLabel : null, /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
			className: "grid gap-1.5",
			children: payload.map((item, index) => {
				const itemConfig = getPayloadConfigFromPayload(config$1, item, `${nameKey || item.name || item.dataKey || "value"}`);
				const indicatorColor = color$1 || item.payload.fill || item.color;
				return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
					className: cn("flex w-full flex-wrap items-stretch gap-2 [&>svg]:h-2.5 [&>svg]:w-2.5 [&>svg]:text-muted-foreground", indicator === "dot" && "items-center"),
					children: formatter && item?.value !== void 0 && item.name ? formatter(item.value, item.name, item, index, item.payload) : /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [itemConfig?.icon ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(itemConfig.icon, {}) : !hideIndicator && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
						className: cn("shrink-0 rounded-[2px] border-[--color-border] bg-[--color-bg]", {
							"h-2.5 w-2.5": indicator === "dot",
							"w-1": indicator === "line",
							"w-0 border-[1.5px] border-dashed bg-transparent": indicator === "dashed",
							"my-0.5": nestLabel && indicator === "dashed"
						}),
						style: {
							"--color-bg": indicatorColor,
							"--color-border": indicatorColor
						}
					}), /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
						className: cn("flex flex-1 justify-between leading-none", nestLabel ? "items-end" : "items-center"),
						children: [/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
							className: "grid gap-1.5",
							children: [nestLabel ? tooltipLabel : null, /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
								className: "text-muted-foreground",
								children: itemConfig?.label || item.name
							})]
						}), item.value && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
							className: "font-mono font-medium tabular-nums text-foreground",
							children: item.value.toLocaleString()
						})]
					})] })
				}, item.dataKey);
			})
		})]
	});
});
ChartTooltipContent.displayName = "ChartTooltip";
var ChartLegendContent = import_react.forwardRef(({ className, hideIcon = false, payload, verticalAlign = "bottom", nameKey }, ref) => {
	const { config: config$1 } = useChart();
	if (!payload?.length) return null;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
		ref,
		className: cn("flex items-center justify-center gap-4", verticalAlign === "top" ? "pb-3" : "pt-3", className),
		children: payload.map((item) => {
			const itemConfig = getPayloadConfigFromPayload(config$1, item, `${nameKey || item.dataKey || "value"}`);
			return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
				className: cn("flex items-center gap-1.5 [&>svg]:h-3 [&>svg]:w-3 [&>svg]:text-muted-foreground"),
				children: [itemConfig?.icon && !hideIcon ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(itemConfig.icon, {}) : /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
					className: "h-2 w-2 shrink-0 rounded-[2px]",
					style: { backgroundColor: item.color }
				}), itemConfig?.label]
			}, item.value);
		})
	});
});
ChartLegendContent.displayName = "ChartLegend";
function getPayloadConfigFromPayload(config$1, payload, key) {
	if (typeof payload !== "object" || payload === null) return;
	const payloadPayload = "payload" in payload && typeof payload.payload === "object" && payload.payload !== null ? payload.payload : void 0;
	let configLabelKey = key;
	if (key in payload && typeof payload[key] === "string") configLabelKey = payload[key];
	else if (payloadPayload && key in payloadPayload && typeof payloadPayload[key] === "string") configLabelKey = payloadPayload[key];
	return configLabelKey in config$1 ? config$1[configLabelKey] : config$1[key];
}
var chartConfig = {
	revenueCurrent: {
		label: "Perodo Atual",
		color: "hsl(var(--chart-1))"
	},
	revenuePrevious: {
		label: "Perodo Anterior",
		color: "hsl(var(--muted-foreground))"
	}
};
function RevenueAreaChart({ currentData, previousData, comparisonEnabled, dateRange, loading }) {
	const chartData = (0, import_react.useMemo)(() => {
		if (!dateRange?.from || !dateRange?.to) return [];
		const daysSpan = differenceInDays(dateRange.to, dateRange.from) + 1;
		const normalizedData = Array.from({ length: daysSpan }).map((_, index) => {
			const currentDayDate = addDays(dateRange.from, index);
			const dateStr = format(currentDayDate, "yyyy-MM-dd");
			const revenueCurrent = currentData.filter((d) => d.date.startsWith(dateStr)).reduce((acc, curr) => acc + curr.revenue, 0);
			if (comparisonEnabled) {
				if (previousData.length > 0) {}
			}
			return {
				date: dateStr,
				displayDate: format(currentDayDate, "dd/MM"),
				revenueCurrent,
				revenuePrevious: 0,
				originalDateCurrent: currentDayDate
			};
		});
		if (comparisonEnabled && previousData.length > 0) {
			const sortedPrev = [...previousData].sort((a$2, b) => new Date(a$2.date).getTime() - new Date(b.date).getTime());
			if (sortedPrev.length > 0) {
				parseISO(sortedPrev[0].date);
				const likelyPrevStart = addDays(dateRange.from, -daysSpan);
				sortedPrev.forEach((item) => {
					const dayOffset = differenceInDays(parseISO(item.date), likelyPrevStart);
					if (dayOffset >= 0 && dayOffset < normalizedData.length) normalizedData[dayOffset].revenuePrevious += item.revenue;
				});
			}
		}
		return normalizedData;
	}, [
		currentData,
		previousData,
		comparisonEnabled,
		dateRange
	]);
	if (loading) return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Skeleton, { className: "h-[300px] w-full rounded-xl" });
	if (currentData.length === 0 && (!comparisonEnabled || previousData.length === 0)) return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
		className: "flex h-[300px] flex-col items-center justify-center rounded-xl border border-dashed bg-muted/20 text-muted-foreground",
		children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(SearchX, { className: "mb-4 h-10 w-10 opacity-20" }), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("p", {
			className: "text-sm font-medium",
			children: "Sem dados para o perodo"
		})]
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
		className: "w-full h-[350px]",
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ChartContainer, {
			config: chartConfig,
			className: "h-full w-full",
			children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ResponsiveContainer, {
				width: "100%",
				height: "100%",
				children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(AreaChart, {
					data: chartData,
					margin: {
						top: 10,
						right: 10,
						left: 0,
						bottom: 0
					},
					children: [
						/* @__PURE__ */ (0, import_jsx_runtime.jsx)("defs", { children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("linearGradient", {
							id: "fillCurrent",
							x1: "0",
							y1: "0",
							x2: "0",
							y2: "1",
							children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("stop", {
								offset: "5%",
								stopColor: "var(--color-revenueCurrent)",
								stopOpacity: .3
							}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("stop", {
								offset: "95%",
								stopColor: "var(--color-revenueCurrent)",
								stopOpacity: 0
							})]
						}) }),
						/* @__PURE__ */ (0, import_jsx_runtime.jsx)(CartesianGrid, {
							vertical: false,
							strokeDasharray: "3 3",
							stroke: "hsl(var(--border))"
						}),
						/* @__PURE__ */ (0, import_jsx_runtime.jsx)(XAxis, {
							dataKey: "displayDate",
							axisLine: false,
							tickLine: false,
							tick: {
								fontSize: 12,
								fill: "hsl(var(--muted-foreground))"
							},
							dy: 10,
							minTickGap: 30
						}),
						/* @__PURE__ */ (0, import_jsx_runtime.jsx)(YAxis, {
							axisLine: false,
							tickLine: false,
							tickFormatter: (val) => `R$ ${(val / 1e3).toFixed(0)}k`,
							tick: {
								fontSize: 12,
								fill: "hsl(var(--muted-foreground))"
							}
						}),
						/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Tooltip, { content: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ChartTooltipContent, { indicator: "dot" }) }),
						/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Legend, {
							verticalAlign: "top",
							height: 36
						}),
						comparisonEnabled && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Area, {
							type: "monotone",
							dataKey: "revenuePrevious",
							name: "Perodo Anterior",
							stroke: "var(--color-revenuePrevious)",
							strokeWidth: 2,
							strokeDasharray: "5 5",
							fill: "transparent",
							animationDuration: 1e3
						}),
						/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Area, {
							type: "monotone",
							dataKey: "revenueCurrent",
							name: "Perodo Atual",
							stroke: "var(--color-revenueCurrent)",
							fill: "url(#fillCurrent)",
							strokeWidth: 2,
							animationDuration: 1e3
						})
					]
				})
			})
		})
	});
}
var Table = import_react.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
	className: "relative w-full overflow-auto",
	children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("table", {
		ref,
		className: cn("w-full caption-bottom text-sm", className),
		...props
	})
}));
Table.displayName = "Table";
var TableHeader = import_react.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)("thead", {
	ref,
	className: cn("[&_tr]:border-b", className),
	...props
}));
TableHeader.displayName = "TableHeader";
var TableBody = import_react.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)("tbody", {
	ref,
	className: cn("[&_tr:last-child]:border-0", className),
	...props
}));
TableBody.displayName = "TableBody";
var TableFooter = import_react.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)("tfoot", {
	ref,
	className: cn("border-t bg-muted/50 font-medium [&>tr]:last:border-b-0", className),
	...props
}));
TableFooter.displayName = "TableFooter";
var TableRow = import_react.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)("tr", {
	ref,
	className: cn("border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted", className),
	...props
}));
TableRow.displayName = "TableRow";
var TableHead = import_react.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)("th", {
	ref,
	className: cn("h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0", className),
	...props
}));
TableHead.displayName = "TableHead";
var TableCell = import_react.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)("td", {
	ref,
	className: cn("p-4 align-middle [&:has([role=checkbox])]:pr-0", className),
	...props
}));
TableCell.displayName = "TableCell";
var TableCaption = import_react.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)("caption", {
	ref,
	className: cn("mt-4 text-sm text-muted-foreground", className),
	...props
}));
TableCaption.displayName = "TableCaption";
function PresenterTable({ data, loading }) {
	const [sortField, setSortField] = (0, import_react.useState)("sales");
	const [sortOrder, setSortOrder] = (0, import_react.useState)("desc");
	const [expandedRow, setExpandedRow] = (0, import_react.useState)(null);
	const presenterData = (0, import_react.useMemo)(() => {
		const grouped = data.reduce((acc, curr) => {
			if (!acc[curr.presenter]) acc[curr.presenter] = {
				presenter: curr.presenter,
				lives: 0,
				sales: 0,
				revenue: 0,
				conversion: 0,
				retention: 0,
				raw: []
			};
			acc[curr.presenter].lives += 1;
			acc[curr.presenter].sales += curr.sales;
			acc[curr.presenter].revenue += curr.revenue;
			acc[curr.presenter].conversion += curr.conversionRate;
			acc[curr.presenter].retention += curr.retentionRate;
			acc[curr.presenter].raw.push(curr);
			return acc;
		}, {});
		return Object.values(grouped).map((p) => ({
			...p,
			conversion: p.lives ? p.conversion / p.lives : 0,
			retention: p.lives ? p.retention / p.lives : 0,
			raw: p.raw.sort((a$2, b) => new Date(a$2.date).getTime() - new Date(b.date).getTime())
		}));
	}, [data]);
	const sortedData = (0, import_react.useMemo)(() => {
		if (sortOrder === "default") return presenterData;
		return [...presenterData].sort((a$2, b) => {
			const aValue = a$2[sortField];
			const bValue = b[sortField];
			if (typeof aValue === "string" && typeof bValue === "string") return sortOrder === "asc" ? aValue.localeCompare(bValue) : bValue.localeCompare(aValue);
			return sortOrder === "asc" ? aValue - bValue : bValue - aValue;
		});
	}, [
		presenterData,
		sortField,
		sortOrder
	]);
	const maxSales = Math.max(...presenterData.map((d) => d.sales));
	const minSales = Math.min(...presenterData.map((d) => d.sales));
	const handleSort = (field) => {
		if (sortField === field) setSortOrder((prev) => prev === "default" ? "desc" : prev === "desc" ? "asc" : "default");
		else {
			setSortField(field);
			setSortOrder("desc");
		}
	};
	const toggleExpand = (presenter) => {
		setExpandedRow(expandedRow === presenter ? null : presenter);
	};
	if (loading) return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
		className: "space-y-2",
		children: [
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Skeleton, { className: "h-10 w-full" }),
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Skeleton, { className: "h-12 w-full" }),
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Skeleton, { className: "h-12 w-full" }),
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Skeleton, { className: "h-12 w-full" })
		]
	});
	if (sortedData.length === 0) return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
		className: "p-8 text-center text-muted-foreground",
		children: "Nenhum dado disponvel para exibir na tabela."
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
		className: "overflow-hidden rounded-md border",
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Table, { children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(TableHeader, {
			className: "bg-gray-50",
			children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(TableRow, { children: [
				/* @__PURE__ */ (0, import_jsx_runtime.jsx)(TableHead, { className: "w-[50px]" }),
				/* @__PURE__ */ (0, import_jsx_runtime.jsxs)(TableHead, {
					className: "w-[200px] cursor-pointer hover:text-primary",
					onClick: () => handleSort("presenter"),
					children: [
						"Apresentador",
						" ",
						sortField === "presenter" && sortOrder !== "default" && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ArrowUpDown, { className: "ml-1 inline h-3 w-3" })
					]
				}),
				/* @__PURE__ */ (0, import_jsx_runtime.jsxs)(TableHead, {
					className: "cursor-pointer text-center hover:text-primary",
					onClick: () => handleSort("lives"),
					children: [
						"Lives",
						" ",
						sortField === "lives" && sortOrder !== "default" && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ArrowUpDown, { className: "ml-1 inline h-3 w-3" })
					]
				}),
				/* @__PURE__ */ (0, import_jsx_runtime.jsxs)(TableHead, {
					className: "cursor-pointer text-right hover:text-primary",
					onClick: () => handleSort("sales"),
					children: [
						"Vendas",
						" ",
						sortField === "sales" && sortOrder !== "default" && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ArrowUpDown, { className: "ml-1 inline h-3 w-3" })
					]
				}),
				/* @__PURE__ */ (0, import_jsx_runtime.jsxs)(TableHead, {
					className: "cursor-pointer text-right hover:text-primary",
					onClick: () => handleSort("revenue"),
					children: [
						"Faturamento",
						" ",
						sortField === "revenue" && sortOrder !== "default" && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ArrowUpDown, { className: "ml-1 inline h-3 w-3" })
					]
				}),
				/* @__PURE__ */ (0, import_jsx_runtime.jsxs)(TableHead, {
					className: "cursor-pointer text-center hover:text-primary",
					onClick: () => handleSort("conversion"),
					children: [
						"Converso",
						" ",
						sortField === "conversion" && sortOrder !== "default" && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ArrowUpDown, { className: "ml-1 inline h-3 w-3" })
					]
				}),
				/* @__PURE__ */ (0, import_jsx_runtime.jsxs)(TableHead, {
					className: "cursor-pointer text-center hover:text-primary",
					onClick: () => handleSort("retention"),
					children: [
						"Reteno",
						" ",
						sortField === "retention" && sortOrder !== "default" && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ArrowUpDown, { className: "ml-1 inline h-3 w-3" })
					]
				})
			] })
		}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(TableBody, { children: sortedData.map((row) => {
			const isBest = row.sales === maxSales && maxSales > 0;
			const isWorst = row.sales === minSales && presenterData.length > 1;
			const isExpanded = expandedRow === row.presenter;
			return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [/* @__PURE__ */ (0, import_jsx_runtime.jsxs)(TableRow, {
				className: cn("cursor-pointer transition-colors even:bg-slate-50 hover:bg-slate-100", isBest && "bg-[#D1FAE5] hover:bg-[#A7F3D0]", isWorst && "border-l-4 border-l-red-500 bg-red-50"),
				onClick: () => toggleExpand(row.presenter),
				children: [
					/* @__PURE__ */ (0, import_jsx_runtime.jsx)(TableCell, { children: isExpanded ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ChevronUp, { className: "h-4 w-4 text-gray-500" }) : /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ChevronDown, { className: "h-4 w-4 text-gray-500" }) }),
					/* @__PURE__ */ (0, import_jsx_runtime.jsx)(TableCell, {
						className: "font-medium",
						children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
							className: "flex items-center gap-2",
							children: [row.presenter, isBest && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Trophy, { className: "h-4 w-4 text-yellow-600" })]
						})
					}),
					/* @__PURE__ */ (0, import_jsx_runtime.jsx)(TableCell, {
						className: "text-center",
						children: row.lives
					}),
					/* @__PURE__ */ (0, import_jsx_runtime.jsx)(TableCell, {
						className: "text-right font-semibold",
						children: row.sales
					}),
					/* @__PURE__ */ (0, import_jsx_runtime.jsxs)(TableCell, {
						className: "text-right",
						children: ["R$ ", row.revenue.toLocaleString("pt-BR")]
					}),
					/* @__PURE__ */ (0, import_jsx_runtime.jsx)(TableCell, {
						className: "text-center",
						children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("span", {
							className: cn("rounded-full px-2 py-1 text-xs font-medium", row.conversion >= 5 ? "bg-green-100 text-green-700" : row.conversion >= 3 ? "bg-yellow-100 text-yellow-700" : "bg-red-100 text-red-700"),
							children: [row.conversion.toFixed(1), "%"]
						})
					}),
					/* @__PURE__ */ (0, import_jsx_runtime.jsx)(TableCell, {
						className: "text-center",
						children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("span", {
							className: cn("rounded-full px-2 py-1 text-xs font-medium", row.retention >= 60 ? "bg-green-100 text-green-700" : row.retention >= 40 ? "bg-yellow-100 text-yellow-700" : "bg-red-100 text-red-700"),
							children: [row.retention.toFixed(1), "%"]
						})
					})
				]
			}, row.presenter), isExpanded && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(TableRow, {
				className: "bg-white hover:bg-white",
				children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(TableCell, {
					colSpan: 7,
					className: "p-4",
					children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
						className: "flex flex-col gap-4 rounded-lg border bg-slate-50 p-4 sm:flex-row",
						children: [/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
							className: "flex-1",
							children: [/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("h4", {
								className: "mb-2 flex items-center text-sm font-semibold text-gray-700",
								children: [
									/* @__PURE__ */ (0, import_jsx_runtime.jsx)(TrendingUp, { className: "mr-2 h-4 w-4" }),
									"Evoluo de Vendas (",
									row.presenter,
									")"
								]
							}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
								className: "h-[200px] w-full",
								children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ResponsiveContainer, {
									width: "100%",
									height: "100%",
									children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(LineChart, {
										data: row.raw,
										children: [
											/* @__PURE__ */ (0, import_jsx_runtime.jsx)(XAxis, {
												dataKey: "date",
												tickFormatter: (v) => new Date(v).toLocaleDateString("pt-BR", {
													day: "2-digit",
													month: "2-digit"
												}),
												stroke: "#888888",
												fontSize: 12
											}),
											/* @__PURE__ */ (0, import_jsx_runtime.jsx)(YAxis, {
												stroke: "#888888",
												fontSize: 12
											}),
											/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Tooltip, { contentStyle: {
												borderRadius: "8px",
												border: "none",
												boxShadow: "0 4px 6px -1px rgb(0 0 0 / 0.1)"
											} }),
											/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Line, {
												type: "monotone",
												dataKey: "sales",
												stroke: "#3B82F6",
												strokeWidth: 2,
												dot: { r: 4 }
											})
										]
									})
								})
							})]
						}), /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
							className: "flex flex-col justify-center space-y-4 border-l pl-4 sm:w-48",
							children: [/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", { children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("p", {
								className: "text-xs text-muted-foreground",
								children: "Melhor Venda"
							}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("p", {
								className: "text-lg font-bold text-green-600",
								children: Math.max(...row.raw.map((r$1) => r$1.sales))
							})] }), /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", { children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("p", {
								className: "text-xs text-muted-foreground",
								children: "Mdia por Live"
							}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("p", {
								className: "text-lg font-bold text-blue-600",
								children: (row.sales / row.lives).toFixed(0)
							})] })]
						})]
					})
				})
			})] });
		}) })] })
	});
}
var WEEKDAYS_ORDER = [
	"Domingo",
	"Segunda-feira",
	"Tera-feira",
	"Quarta-feira",
	"Quinta-feira",
	"Sexta-feira",
	"Sbado"
];
var normalizeWeekday = (w) => {
	const lower = w.toLowerCase();
	if (lower.includes("segunda")) return "Segunda-feira";
	if (lower.includes("tera")) return "Tera-feira";
	if (lower.includes("quarta")) return "Quarta-feira";
	if (lower.includes("quinta")) return "Quinta-feira";
	if (lower.includes("sexta")) return "Sexta-feira";
	if (lower.includes("sbado")) return "Sbado";
	if (lower.includes("domingo")) return "Domingo";
	return w;
};
function WeekdayChart({ data, loading }) {
	const chartData = (0, import_react.useMemo)(() => {
		const grouped = data.reduce((acc, curr) => {
			const day = normalizeWeekday(curr.weekday);
			if (!acc[day]) acc[day] = {
				name: day,
				totalSales: 0,
				totalRevenue: 0,
				count: 0
			};
			acc[day].totalSales += curr.sales;
			acc[day].totalRevenue += curr.revenue;
			acc[day].count += 1;
			return acc;
		}, {});
		return WEEKDAYS_ORDER.map((day) => {
			const stats = grouped[day] || {
				name: day,
				totalSales: 0,
				totalRevenue: 0,
				count: 0
			};
			return {
				name: day.split("-")[0],
				fullName: day,
				avgSales: stats.count ? Math.round(stats.totalSales / stats.count) : 0,
				avgRevenue: stats.count ? stats.totalRevenue / stats.count : 0,
				count: stats.count
			};
		}).filter((d) => d.count > 0);
	}, [data]);
	const CustomTooltip = ({ active, payload, label }) => {
		if (active && payload && payload.length) {
			const data$1 = payload[0].payload;
			return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
				className: "rounded-lg border bg-white p-3 shadow-md text-sm",
				children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("p", {
					className: "font-semibold mb-2 text-gray-900",
					children: data$1.fullName
				}), /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
					className: "space-y-1",
					children: [
						/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("p", {
							className: "flex justify-between gap-4",
							children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
								className: "text-gray-500",
								children: "Mdia de Vendas:"
							}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
								className: "font-bold text-blue-600",
								children: data$1.avgSales
							})]
						}),
						/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("p", {
							className: "flex justify-between gap-4",
							children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
								className: "text-gray-500",
								children: "Mdia de Fat.:"
							}), /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("span", {
								className: "font-medium",
								children: ["R$ ", data$1.avgRevenue.toLocaleString("pt-BR")]
							})]
						}),
						/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("p", {
							className: "flex justify-between gap-4",
							children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
								className: "text-gray-500",
								children: "Total de Lives:"
							}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
								className: "font-medium",
								children: data$1.count
							})]
						})
					]
				})]
			});
		}
		return null;
	};
	if (loading) return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Skeleton, { className: "h-[350px] w-full rounded-xl" });
	if (chartData.length === 0) return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
		className: "flex h-[350px] items-center justify-center text-gray-500",
		children: "Dados insuficientes para gerar o grfico."
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
		className: "h-[350px] w-full p-4",
		children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("h3", {
			className: "mb-6 text-lg font-semibold text-gray-800",
			children: "Mdia de Vendas por Dia da Semana"
		}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ResponsiveContainer, {
			width: "100%",
			height: "85%",
			children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(BarChart, {
				data: chartData,
				children: [
					/* @__PURE__ */ (0, import_jsx_runtime.jsx)(CartesianGrid, {
						strokeDasharray: "3 3",
						vertical: false
					}),
					/* @__PURE__ */ (0, import_jsx_runtime.jsx)(XAxis, {
						dataKey: "name",
						axisLine: false,
						tickLine: false,
						dy: 10
					}),
					/* @__PURE__ */ (0, import_jsx_runtime.jsx)(YAxis, {
						axisLine: false,
						tickLine: false
					}),
					/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Tooltip, {
						content: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(CustomTooltip, {}),
						cursor: { fill: "#F3F4F6" }
					}),
					/* @__PURE__ */ (0, import_jsx_runtime.jsx)("defs", { children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("linearGradient", {
						id: "blueGradient",
						x1: "0",
						y1: "0",
						x2: "0",
						y2: "1",
						children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("stop", {
							offset: "0%",
							stopColor: "#3B82F6",
							stopOpacity: 1
						}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("stop", {
							offset: "100%",
							stopColor: "#60A5FA",
							stopOpacity: .8
						})]
					}) }),
					/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Bar, {
						dataKey: "avgSales",
						fill: "url(#blueGradient)",
						radius: [
							6,
							6,
							0,
							0
						],
						barSize: 50
					})
				]
			})
		})]
	});
}
function EmptyState({ icon: Icon, title, description, className, action }) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
		className: cn("flex flex-col items-center justify-center p-8 text-center animate-fade-in", className),
		children: [
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
				className: "flex h-16 w-16 items-center justify-center rounded-full bg-muted/50 mb-4",
				children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Icon, { className: "h-8 w-8 text-muted-foreground" })
			}),
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)("h3", {
				className: "text-lg font-semibold text-foreground mb-1",
				children: title
			}),
			description && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("p", {
				className: "text-sm text-muted-foreground max-w-sm mb-6",
				children: description
			}),
			action
		]
	});
}
function Lives() {
	const { allData, loading, error, fetchData } = useLivesStore();
	const [filters, setFilters] = (0, import_react.useState)({
		dateRange: {
			from: subDays(/* @__PURE__ */ new Date(), 30),
			to: /* @__PURE__ */ new Date()
		},
		presenters: [],
		weekdays: [],
		comparisonEnabled: false
	});
	(0, import_react.useEffect)(() => {
		if (allData.length === 0) fetchData();
	}, []);
	const comparisonRange = (0, import_react.useMemo)(() => {
		if (!filters.comparisonEnabled || !filters.dateRange?.from || !filters.dateRange?.to) return;
		const duration$2 = differenceInDays(filters.dateRange.to, filters.dateRange.from);
		const prevEnd = subDays(filters.dateRange.from, 1);
		return {
			from: subDays(prevEnd, duration$2),
			to: prevEnd
		};
	}, [filters.comparisonEnabled, filters.dateRange]);
	const filterData = (data, range$5) => {
		if (!range$5?.from || !range$5?.to) return [];
		const start = startOfDay(range$5.from);
		const end = endOfDay(range$5.to);
		return data.filter((item) => {
			if (!isWithinInterval(parseISO(item.date), {
				start,
				end
			})) return false;
			if (filters.presenters.length > 0 && !filters.presenters.includes(item.presenter)) return false;
			if (filters.weekdays.length > 0) {
				const normalizedItemDay = item.weekday.toLowerCase().split("-")[0];
				if (!filters.weekdays.some((w) => w.toLowerCase().includes(normalizedItemDay))) return false;
			}
			return true;
		});
	};
	const currentData = (0, import_react.useMemo)(() => filterData(allData, filters.dateRange), [allData, filters]);
	const previousData = (0, import_react.useMemo)(() => filterData(allData, comparisonRange), [
		allData,
		comparisonRange,
		filters.presenters,
		filters.weekdays
	]);
	const uniquePresenters = (0, import_react.useMemo)(() => {
		return Array.from(new Set(allData.map((d) => d.presenter))).sort();
	}, [allData]);
	const handleLiveAdded = () => {
		fetchData();
	};
	const containerStyle = { fontFamily: "\"Inter\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Helvetica, Arial, sans-serif" };
	if (error) return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
		className: "flex h-[80vh] flex-col items-center justify-center gap-4",
		children: [
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
				className: "rounded-full bg-red-100 p-4 text-red-600",
				children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(TriangleAlert, { size: 48 })
			}),
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)("h2", {
				className: "text-xl font-semibold text-gray-900",
				children: "Erro ao carregar dados"
			}),
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)("p", {
				className: "text-gray-500",
				children: "No foi possvel conectar ao Google Sheets."
			}),
			/* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Button, {
				onClick: fetchData,
				variant: "outline",
				children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(RefreshCw, { className: "mr-2 h-4 w-4" }), "Tentar Novamente"]
			})
		]
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
		className: "flex-1 p-4 md:p-8 max-w-[1600px] mx-auto w-full space-y-8",
		style: containerStyle,
		children: [
			/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("header", {
				className: "flex flex-col md:flex-row justify-between items-start md:items-center gap-4",
				children: [/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", { children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("h1", {
					className: "text-3xl font-bold tracking-tight text-gray-900",
					children: "Dashboard de Lives"
				}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("p", {
					className: "text-muted-foreground mt-1",
					children: "Acompanhe a performance, compare perodos e analise KPIs em tempo real."
				})] }), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(AddLiveModal, {
					presenters: uniquePresenters,
					onSuccess: handleLiveAdded
				})]
			}),
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)(LiveFilters, {
				presenters: uniquePresenters,
				onApply: setFilters,
				onClear: () => setFilters((prev) => ({
					...prev,
					comparisonEnabled: false
				})),
				loading,
				initialFilters: filters
			}),
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)("section", { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(LiveKPIs, {
				currentData,
				previousData,
				comparisonEnabled: filters.comparisonEnabled,
				loading
			}) }),
			currentData.length === 0 && !loading ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(EmptyState, {
				icon: Video,
				title: "Nenhuma live encontrada",
				description: "Tente ajustar os filtros ou selecionar um perodo diferente."
			}) : /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
				className: "grid grid-cols-1 lg:grid-cols-2 gap-6",
				children: [
					/* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Card, {
						className: "col-span-1 lg:col-span-2 xl:col-span-1 border shadow-sm",
						children: [/* @__PURE__ */ (0, import_jsx_runtime.jsxs)(CardHeader, { children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(CardTitle, { children: "Evoluo de Faturamento" }), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(CardDescription, { children: "Comparativo de performance financeira no perodo selecionado." })] }), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(CardContent, { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(RevenueAreaChart, {
							currentData,
							previousData,
							comparisonEnabled: filters.comparisonEnabled,
							dateRange: filters.dateRange,
							loading
						}) })]
					}),
					/* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Card, {
						className: "col-span-1 lg:col-span-2 xl:col-span-1 border shadow-sm",
						children: [/* @__PURE__ */ (0, import_jsx_runtime.jsxs)(CardHeader, { children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(CardTitle, { children: "Performance por Dia da Semana" }), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(CardDescription, { children: "Mdia de vendas e faturamento agrupados por dia." })] }), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(CardContent, { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(WeekdayChart, {
							data: currentData,
							loading
						}) })]
					}),
					/* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Card, {
						className: "col-span-1 lg:col-span-2 border shadow-sm",
						children: [/* @__PURE__ */ (0, import_jsx_runtime.jsxs)(CardHeader, { children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(CardTitle, { children: "Ranking de Apresentadores" }), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(CardDescription, { children: "Detalhamento de mtricas por especialista." })] }), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(CardContent, { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(PresenterTable, {
							data: currentData,
							loading
						}) })]
					})
				]
			})
		]
	});
}
export { Lives as default };

//# sourceMappingURL=Lives-DDOhWFc4.js.map